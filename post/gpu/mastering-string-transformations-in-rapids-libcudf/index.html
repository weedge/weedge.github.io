<!DOCTYPE html>
<html lang="zh-cn" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>译：掌握 RAPIDS libcudf 中的字符串转换 - 时间飘过</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="weedge" />
  <meta name="description" content="字符串数据的高效处理对于许多数据科学应用至关重要。为了从字符串数据中提取有价值的信息，RAPIDS libcudf提供了强大的工具来加速字符串数据转换。libcudf 是一个 C&#43;&#43; GPU DataFrame 库，用于加载、连接、聚合和过滤数据。
在数据科学中，字符串数据代表语音、文本、基因序列、日志记录和许多其他类型的信息。在使用字符串数据进行机器学习和特征工程时，必须经常对数据进行规范化和转换，然后才能将其应用于特定用例。libcudf 提供通用 API 和设备端实用程序，以支持各种自定义字符串操作。
这篇文章演示了如何使用 libcudf 通用 API 巧妙地转换字符串列。您将获得有关如何使用自定义内核和 libcudf 设备端实用程序解锁峰值性能的新知识。这篇文章还向您介绍了如何最好地管理 GPU 内存和高效构建 libcudf 列以加速字符串转换的示例。
(注：从文件中获取数据到buffer中，都需要通过字符串处理操作，特别是split操作，如果是数值，需要atoi，atof操作进行数据分析，向量化操作等， 和数据处理打交道的 super 马里奥 应该学会这个工具，这里直接使用底层操作库libcudf；集成的其他语言有java(JNI)和python(cython), 主要是方便和现有 大数据生态打通(会有一些内存方面的性能损耗)，大多是离线处理场景，特别是LLM的预训练场景)
" />

  <meta name="keywords" content="工作, 技术, 生活" />






<meta name="generator" content="Hugo 0.91.0" />


<link rel="canonical" href="https://weedge.github.io/post/gpu/mastering-string-transformations-in-rapids-libcudf/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.fa4b2b9f31b5c6d0b683db81157a9226e17b06e61911791ab547242a4a0556f2.css" integrity="sha256-&#43;ksrnzG1xtC2g9uBFXqSJuF7BuYZEXkatUckKkoFVvI=" media="screen" crossorigin="anonymous">




<link rel="stylesheet" href="/css/copy-to-clipboard.css">


<meta property="og:title" content="译：掌握 RAPIDS libcudf 中的字符串转换" />
<meta property="og:description" content="
字符串数据的高效处理对于许多数据科学应用至关重要。为了从字符串数据中提取有价值的信息，RAPIDS libcudf提供了强大的工具来加速字符串数据转换。libcudf 是一个 C&#43;&#43; GPU DataFrame 库，用于加载、连接、聚合和过滤数据。
在数据科学中，字符串数据代表语音、文本、基因序列、日志记录和许多其他类型的信息。在使用字符串数据进行机器学习和特征工程时，必须经常对数据进行规范化和转换，然后才能将其应用于特定用例。libcudf 提供通用 API 和设备端实用程序，以支持各种自定义字符串操作。
这篇文章演示了如何使用 libcudf 通用 API 巧妙地转换字符串列。您将获得有关如何使用自定义内核和 libcudf 设备端实用程序解锁峰值性能的新知识。这篇文章还向您介绍了如何最好地管理 GPU 内存和高效构建 libcudf 列以加速字符串转换的示例。
(注：从文件中获取数据到buffer中，都需要通过字符串处理操作，特别是split操作，如果是数值，需要atoi，atof操作进行数据分析，向量化操作等， 和数据处理打交道的 super 马里奥 应该学会这个工具，这里直接使用底层操作库libcudf；集成的其他语言有java(JNI)和python(cython), 主要是方便和现有 大数据生态打通(会有一些内存方面的性能损耗)，大多是离线处理场景，特别是LLM的预训练场景)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://weedge.github.io/post/gpu/mastering-string-transformations-in-rapids-libcudf/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-11-07T15:00:23+08:00" />
<meta property="article:modified_time" content="2023-11-07T15:00:23+08:00" />

<meta itemprop="name" content="译：掌握 RAPIDS libcudf 中的字符串转换">
<meta itemprop="description" content="
字符串数据的高效处理对于许多数据科学应用至关重要。为了从字符串数据中提取有价值的信息，RAPIDS libcudf提供了强大的工具来加速字符串数据转换。libcudf 是一个 C&#43;&#43; GPU DataFrame 库，用于加载、连接、聚合和过滤数据。
在数据科学中，字符串数据代表语音、文本、基因序列、日志记录和许多其他类型的信息。在使用字符串数据进行机器学习和特征工程时，必须经常对数据进行规范化和转换，然后才能将其应用于特定用例。libcudf 提供通用 API 和设备端实用程序，以支持各种自定义字符串操作。
这篇文章演示了如何使用 libcudf 通用 API 巧妙地转换字符串列。您将获得有关如何使用自定义内核和 libcudf 设备端实用程序解锁峰值性能的新知识。这篇文章还向您介绍了如何最好地管理 GPU 内存和高效构建 libcudf 列以加速字符串转换的示例。
(注：从文件中获取数据到buffer中，都需要通过字符串处理操作，特别是split操作，如果是数值，需要atoi，atof操作进行数据分析，向量化操作等， 和数据处理打交道的 super 马里奥 应该学会这个工具，这里直接使用底层操作库libcudf；集成的其他语言有java(JNI)和python(cython), 主要是方便和现有 大数据生态打通(会有一些内存方面的性能损耗)，大多是离线处理场景，特别是LLM的预训练场景)"><meta itemprop="datePublished" content="2023-11-07T15:00:23+08:00" />
<meta itemprop="dateModified" content="2023-11-07T15:00:23+08:00" />
<meta itemprop="wordCount" content="5805">
<meta itemprop="keywords" content="oneday,gpu,RAPIDS libcudf,string," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="译：掌握 RAPIDS libcudf 中的字符串转换"/>
<meta name="twitter:description" content="
字符串数据的高效处理对于许多数据科学应用至关重要。为了从字符串数据中提取有价值的信息，RAPIDS libcudf提供了强大的工具来加速字符串数据转换。libcudf 是一个 C&#43;&#43; GPU DataFrame 库，用于加载、连接、聚合和过滤数据。
在数据科学中，字符串数据代表语音、文本、基因序列、日志记录和许多其他类型的信息。在使用字符串数据进行机器学习和特征工程时，必须经常对数据进行规范化和转换，然后才能将其应用于特定用例。libcudf 提供通用 API 和设备端实用程序，以支持各种自定义字符串操作。
这篇文章演示了如何使用 libcudf 通用 API 巧妙地转换字符串列。您将获得有关如何使用自定义内核和 libcudf 设备端实用程序解锁峰值性能的新知识。这篇文章还向您介绍了如何最好地管理 GPU 内存和高效构建 libcudf 列以加速字符串转换的示例。
(注：从文件中获取数据到buffer中，都需要通过字符串处理操作，特别是split操作，如果是数值，需要atoi，atof操作进行数据分析，向量化操作等， 和数据处理打交道的 super 马里奥 应该学会这个工具，这里直接使用底层操作库libcudf；集成的其他语言有java(JNI)和python(cython), 主要是方便和现有 大数据生态打通(会有一些内存方面的性能损耗)，大多是离线处理场景，特别是LLM的预训练场景)"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">时间飘过</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://weedge.github.io/">主页</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://weedge.github.io/post/">归档</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://weedge.github.io/tags/">标签</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://weedge.github.io/categories/">分类</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://weedge.github.io/about/">About</a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      时间飘过
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://weedge.github.io/">主页</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://weedge.github.io/post/">归档</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://weedge.github.io/tags/">标签</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://weedge.github.io/categories/">分类</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://weedge.github.io/about/">About</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">译：掌握 RAPIDS libcudf 中的字符串转换</h1>
      
      <div class="post-meta">
        <time datetime="2023-11-07" class="post-time">
          2023-11-07
        </time>
        <div class="post-category">
            <a href="https://weedge.github.io/categories/%E6%8A%80%E6%9C%AF/"> 技术 </a>
            
          </div>
        

        
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#引入字符串arrow格式">引入字符串Arrow格式</a></li>
    <li><a href="#字符串编辑功能示例">字符串编辑功能示例</a></li>
    <li><a href="#使用-libcudf-api-转换字符串">使用 libcudf API 转换字符串</a></li>
    <li><a href="#使用自定义内核转换字符串">使用自定义内核转换字符串</a>
      <ul>
        <li><a href="#内核-malloc-调用的性能限制">内核 malloc 调用的性能限制</a></li>
        <li><a href="#malloc内核">Malloc内核</a></li>
        <li><a href="#预分配工作内存以消除瓶颈">预分配工作内存以消除瓶颈</a></li>
        <li><a href="#预分配内核">预分配内核</a></li>
        <li><a href="#优化列创建以缩短计算时间">优化列创建以缩短计算时间</a></li>
        <li><a href="#优化内核第-1-部分">优化内核：第 1 部分</a></li>
        <li><a href="#优化内核第-2-部分">优化内核：第 2 部分</a></li>
      </ul>
    </li>
    <li><a href="#峰值性能分析">峰值性能分析</a></li>
    <li><a href="#概要">概要</a></li>
    <li><a href="#reference">Reference</a></li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <p><img src="https://github.com/weedge/mypic/raw/master/oneday/mastering-string-transformations-in-rapids-libcudf/1.png" alt="img"></p>
<p>字符串数据的高效处理对于许多数据科学应用至关重要。为了从字符串数据中提取有价值的信息，<a href="https://github.com/rapidsai/cudf">RAPIDS libcudf</a>提供了强大的工具来加速字符串数据转换。libcudf 是一个 C++ GPU DataFrame 库，用于加载、连接、聚合和过滤数据。</p>
<p>在数据科学中，字符串数据代表语音、文本、基因序列、日志记录和许多其他类型的信息。在使用字符串数据进行机器学习和特征工程时，必须经常对数据进行规范化和转换，然后才能将其应用于特定用例。libcudf 提供通用 API 和设备端实用程序，以支持各种自定义字符串操作。</p>
<p>这篇文章演示了如何使用 libcudf 通用 API 巧妙地转换字符串列。您将获得有关如何使用自定义内核和 libcudf 设备端实用程序解锁峰值性能的新知识。这篇文章还向您介绍了如何最好地管理 GPU 内存和高效构建 libcudf 列以加速字符串转换的示例。</p>
<p>(<strong>注</strong>：从文件中获取数据到buffer中，都需要通过字符串处理操作，特别是split操作，如果是数值，需要atoi，atof操作进行数据分析，向量化操作等， 和数据处理打交道的 super 马里奥 应该学会这个工具，这里直接使用底层操作库libcudf；集成的其他语言有java(JNI)和python(cython), 主要是方便和现有 大数据生态打通(会有一些内存方面的性能损耗)，大多是离线处理场景，特别是LLM的预训练场景)</p>
<h2 id="引入字符串arrow格式">引入字符串Arrow格式</h2>
<p><a href="https://arrow.apache.org/docs/format/Columnar.html#variable-size-binary-layout">libcudf 使用Arrow 格式</a>将字符串数据存储在设备内存中，该格式将字符串列表示为两个子列：<code>chars and offsets</code> 图 1所示。</p>
<p>该<code>chars</code>列将字符串数据保存为连续存储在内存中的 UTF-8 编码字符字节。</p>
<p>该<code>offsets</code>列包含递增的整数序列，这些整数是标识 chars 数据数组中每个单独字符串的开头的字节位置。最后的偏移量元素是 chars 列中的字节总数。这意味着行中单个字符串的大小<code>i</code>定义为 ( <code>offsets[i+1]-offsets[i])</code>。</p>
<p><img src="https://github.com/weedge/mypic/raw/master/oneday/mastering-string-transformations-in-rapids-libcudf/2.png" alt="显示字符串向量 {&ldquo;this&rdquo;, &ldquo;is&rdquo;, &ldquo;a&rdquo;, &ldquo;column&rdquo;, &ldquo;of&rdquo;, &ldquo;strings&rdquo;} 及其表示为大小为 6 的字符串类型列的示意图，从而产生“偏移量” INT32 类型的子列和 INT8 类型的“字符”子列。"><em>图 1. 示意图显示箭头格式如何表示带有<code>chars</code>子<code>offsets</code>列的字符串列</em></p>
<h2 id="字符串编辑功能示例">字符串编辑功能示例</h2>
<p>为了说明字符串转换示例，请考虑一个函数，该函数接收两个输入字符串列并生成一个经过编辑的输出字符串列。</p>
<p>输入数据具有以下形式：“name”列包含用空格分隔的名字和姓氏，以及包含“public”或“private”状态的“visibilities”列。</p>
<p>我们提出了“redact”函数，该函数对输入数据进行操作以生成由姓氏的第一个首字母后跟空格和整个名字组成的输出数据。但是，如果相应的可见性列是“private”，则输出字符串应完全编辑为“X X”。</p>
<p><img src="https://github.com/weedge/mypic/raw/master/oneday/mastering-string-transformations-in-rapids-libcudf/3.png" alt="该表显示“编辑”字符串转换示例，该转换接收名称和可见性字符串列作为输入，并接收部分或完全编辑的数据作为输出。"></p>
<p><em>表 1.“编辑”字符串转换示例，该转换接收名称和可见性字符串列作为输入，并接收部分或完全编辑的数据作为输出</em></p>
<h2 id="使用-libcudf-api-转换字符串">使用 libcudf API 转换字符串</h2>
<p>首先，可以使用<a href="https://docs.rapids.ai/api/libcudf/nightly/group__strings__apis.html">libcudf strings API</a>完成字符串转换。通用 API 是一个很好的起点，也是比较性能的良好基准。</p>
<p><strong>API 函数对整个字符串列进行操作，每个函数至少启动一个内核，并为每个字符串分配一个线程。每个线程在 GPU 上并行处理单行数据，并输出单行作为新输出列的一部分</strong>。</p>
<p>要使用通用 API 完成 redact 示例函数，请按照以下步骤操作：</p>
<ol>
<li>使用以下命令将“visibilities”字符串列转换为布尔列<code>contains</code></li>
<li>每当布尔列中的相应行条目为“false”时，通过复制“X X”，从名称列创建一个新的字符串列</li>
<li>将“redacted”列拆分为名字和姓氏列</li>
<li>将姓氏的第一个字符切片作为姓氏首字母</li>
<li>通过使用空格 (“ “) 分隔符连接最后一个姓名缩写列和第一个姓名列来构建输出列。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// convert the visibility label into a boolean
</span><span class="c1"></span><span class="k">auto</span> <span class="k">const</span> <span class="n">visible</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">::</span><span class="n">string_scalar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&#34;public&#34;</span><span class="p">));</span>
<span class="k">auto</span> <span class="k">const</span> <span class="n">allowed</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">::</span><span class="n">strings</span><span class="o">::</span><span class="n">contains</span><span class="p">(</span><span class="n">visibilities</span><span class="p">,</span> <span class="n">visible</span><span class="p">);</span>

<span class="c1">// redact names 
</span><span class="c1"></span><span class="k">auto</span> <span class="k">const</span> <span class="n">redaction</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">::</span><span class="n">string_scalar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&#34;X X&#34;</span><span class="p">));</span>
<span class="k">auto</span> <span class="k">const</span> <span class="n">redacted</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">::</span><span class="n">copy_if_else</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">redaction</span><span class="p">,</span> <span class="n">allowed</span><span class="o">-&gt;</span><span class="n">view</span><span class="p">());</span>

<span class="c1">// split the first name and last initial into two columns
</span><span class="c1"></span><span class="k">auto</span> <span class="k">const</span> <span class="n">sv</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">::</span><span class="n">strings_column_view</span><span class="p">(</span><span class="n">redacted</span><span class="o">-&gt;</span><span class="n">view</span><span class="p">())</span>
<span class="k">auto</span> <span class="k">const</span> <span class="n">first_last</span>  <span class="o">=</span> <span class="n">cudf</span><span class="o">::</span><span class="n">strings</span><span class="o">::</span><span class="n">split</span><span class="p">(</span><span class="n">sv</span><span class="p">);</span>
<span class="k">auto</span> <span class="k">const</span> <span class="n">first</span> <span class="o">=</span> <span class="n">first_last</span><span class="o">-&gt;</span><span class="n">view</span><span class="p">().</span><span class="n">column</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">auto</span> <span class="k">const</span> <span class="n">last</span>  <span class="o">=</span> <span class="n">first_last</span><span class="o">-&gt;</span><span class="n">view</span><span class="p">().</span><span class="n">column</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="k">auto</span> <span class="k">const</span> <span class="n">last_initial</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">::</span><span class="n">strings</span><span class="o">::</span><span class="n">slice_strings</span><span class="p">(</span><span class="n">last</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>  

<span class="c1">// assemble a result column
</span><span class="c1"></span><span class="k">auto</span> <span class="k">const</span> <span class="n">tv</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">::</span><span class="n">table_view</span><span class="p">({</span><span class="n">last_initial</span><span class="o">-&gt;</span><span class="n">view</span><span class="p">(),</span> <span class="n">first</span><span class="p">});</span>
<span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">::</span><span class="n">strings</span><span class="o">::</span><span class="n">concatenate</span><span class="p">(</span><span class="n">tv</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&#34; &#34;</span><span class="p">));</span>
</code></pre></div><p>在具有 600K 行数据的 A6000 上，此方法大约需要 3.5 毫秒。此示例使用<code>contains</code>,<code>copy_if_else, split, slice_strings</code>和<code>concatenate</code>来完成自定义字符串转换。<a href="https://developer.nvidia.com/nsight-systems">Nsight Systems</a>的分析显示该<code>split</code>函数花费的时间最长，其次是<code>slice_strings</code>和<code>concatenate</code>。</p>
<p>图 2 显示了来自 Nsight Systems 的 redact 示例的分析数据，显示了每秒高达约 6 亿个元素的端到端字符串处理。这些区域对应于与每个功能相关的 NVTX 范围。浅蓝色范围对应于 CUDA 内核运行的时间段。</p>
<p><img src="https://github.com/weedge/mypic/raw/master/oneday/mastering-string-transformations-in-rapids-libcudf/4.png" alt="显示使用 libcudf strings API 实现的 redact 示例的分析数据的水平条形图。 时间线显示了 contains、copy_if_else、split、slice_strings 和 concatenate 在 600K 到 10M 的行数范围内运行。 时间线将内核执行与字符串 API 函数重叠。 "></p>
<p><em>图 2. 对来自 Nsight Systems 的 redact 示例的数据进行分析</em></p>
<h2 id="使用自定义内核转换字符串">使用自定义内核转换字符串</h2>
<p>libcudf strings API 是一个快速高效的字符串转换工具包，但有时性能关键的函数需要运行得更快。libcudf 字符串 API 中额外工作的一个关键来源是为每个 API 调用在全局设备内存中创建至少一个新字符串列，从而提供了将多个 API 调用组合到自定义内核中的机会。</p>
<h3 id="内核-malloc-调用的性能限制">内核 malloc 调用的性能限制</h3>
<p>首先，我们将构建一个自定义内核来实现编辑示例转换。在设计这个内核时，我们必须记住 libcudf 字符串列是不可变的。</p>
<p>字符串列无法就地更改，因为字符字节是连续存储的，并且对字符串长度的任何更改都会使偏移量数据无效。因此，<code>redact_kernel</code>自定义内核通过使用 libcudf 列工厂来构建新的字符串列<code>offsets</code>和<code>chars</code>子列。</p>
<p>在第一种方法中，每行的输出字符串是使用内核内部的 malloc 调用在<a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#dynamic-global-memory-allocation-and-operations">动态设备内存(dynamic device memory)</a>中创建的。自定义内核输出是指向每行输出的设备指针向量，并且该向量用作字符串列工厂的输入。</p>
<p>自定义内核接受 <a href="https://docs.rapids.ai/api/libcudf/nightly/classcudf_1_1column__device__view.html"><code>cudf::column_device_view</code></a>来访问字符串列数据，并使用该<code>element</code>方法返回<a href="https://docs.rapids.ai/api/libcudf/nightly/classcudf_1_1string__view.html"><code>cudf::string_view</code></a>表示指定行索引处的字符串数据。内核输出是一个向量类型<code>cudf::string_view</code>，它保存指向设备内存的指针，其中包含输出字符串以及该字符串的大小（以字节为单位）。</p>
<p>该类<code>cudf::string_view</code>与  C++17 <code>std::string_view</code> 类类似，但专门为 libcudf 实现，并将固定长度的字符数据包装在设备内存中编码为 UTF-8。它具有许多与std相关函数相同的特性（例如<code>find</code>，<code>substr</code>功能）以及 限制（没有空终止符）。<code>cudf::string_view</code>表示存储在设备内存中的字符序列，因此我们可以在此处使用它来记录输出向量的 malloc 内存。</p>
<h3 id="malloc内核">Malloc内核</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// note the column_device_view inputs to the kernel
</span><span class="c1"></span>
<span class="n">__global__</span> <span class="kt">void</span> <span class="nf">redact_kernel</span><span class="p">(</span><span class="n">cudf</span><span class="o">::</span><span class="n">column_device_view</span> <span class="k">const</span> <span class="n">d_names</span><span class="p">,</span>
                              <span class="n">cudf</span><span class="o">::</span><span class="n">column_device_view</span> <span class="k">const</span> <span class="n">d_visibilities</span><span class="p">,</span>
                              <span class="n">cudf</span><span class="o">::</span><span class="n">string_view</span> <span class="n">redaction</span><span class="p">,</span>
                              <span class="n">cudf</span><span class="o">::</span><span class="n">string_view</span><span class="o">*</span> <span class="n">d_output</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// get index for this thread
</span><span class="c1"></span>  <span class="k">auto</span> <span class="n">index</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">d_names</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="k">return</span><span class="p">;</span>

  <span class="k">auto</span> <span class="k">const</span> <span class="n">visible</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">::</span><span class="n">string_view</span><span class="p">(</span><span class="s">&#34;public&#34;</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>

  <span class="k">auto</span> <span class="k">const</span> <span class="n">name</span> <span class="o">=</span> <span class="n">d_names</span><span class="p">.</span><span class="n">element</span><span class="o">&lt;</span><span class="n">cudf</span><span class="o">::</span><span class="n">string_view</span><span class="o">&gt;</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
  <span class="k">auto</span> <span class="k">const</span> <span class="n">vis</span>  <span class="o">=</span> <span class="n">d_visibilities</span><span class="p">.</span><span class="n">element</span><span class="o">&lt;</span><span class="n">cudf</span><span class="o">::</span><span class="n">string_view</span><span class="o">&gt;</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">vis</span> <span class="o">==</span> <span class="n">visible</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="k">const</span> <span class="n">space_idx</span>    <span class="o">=</span> <span class="n">name</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">);</span>
    <span class="k">auto</span> <span class="k">const</span> <span class="n">first</span>        <span class="o">=</span> <span class="n">name</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">space_idx</span><span class="p">);</span>
    <span class="k">auto</span> <span class="k">const</span> <span class="n">last_initial</span> <span class="o">=</span> <span class="n">name</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">space_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">auto</span> <span class="k">const</span> <span class="n">output_size</span>  <span class="o">=</span> <span class="n">first</span><span class="p">.</span><span class="n">size_bytes</span><span class="p">()</span> <span class="o">+</span> <span class="n">last_initial</span><span class="p">.</span><span class="n">size_bytes</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    
    <span class="kt">char</span><span class="o">*</span> <span class="n">output_ptr</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">malloc</span><span class="p">(</span><span class="n">output_size</span><span class="p">));</span>

    <span class="c1">// build output string
</span><span class="c1"></span>    <span class="n">d_output</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>  <span class="o">=</span> <span class="n">cudf</span><span class="o">::</span><span class="n">string_view</span><span class="p">{</span><span class="n">output_ptr</span><span class="p">,</span> <span class="n">output_size</span><span class="p">};</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">output_ptr</span><span class="p">,</span> <span class="n">last_initial</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">last_initial</span><span class="p">.</span><span class="n">size_bytes</span><span class="p">());</span>
    <span class="n">output_ptr</span> <span class="o">+=</span> <span class="n">last_initial</span><span class="p">.</span><span class="n">size_bytes</span><span class="p">();</span>
    <span class="o">*</span><span class="n">output_ptr</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">output_ptr</span><span class="p">,</span> <span class="n">first</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">first</span><span class="p">.</span><span class="n">size_bytes</span><span class="p">());</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">d_output</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">::</span><span class="n">string_view</span><span class="p">{</span><span class="n">redaction</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">redaction</span><span class="p">.</span><span class="n">size_bytes</span><span class="p">()};</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">__global__</span> <span class="kt">void</span> <span class="nf">free_kernel</span><span class="p">(</span><span class="n">cudf</span><span class="o">::</span><span class="n">string_view</span> <span class="n">redaction</span><span class="p">,</span> <span class="n">cudf</span><span class="o">::</span><span class="n">string_view</span><span class="o">*</span> <span class="n">d_output</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">index</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">count</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">d_output</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">data</span><span class="p">());</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">!=</span> <span class="n">redaction</span><span class="p">.</span><span class="n">data</span><span class="p">())</span> <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span> <span class="c1">// free everything that does match the redaction string
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>在测量内核性能之前，这似乎是一种合理的方法。这种方法在具有 60 万行数据的 A6000 上大约需要 108 毫秒，比上面使用 libcudf strings API 提供的解决方案慢了 30 倍以上。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">redact_kernel         60.3ms
free_kernel           45.5ms
make_strings_column    0.5ms
</code></pre></div><p>主要瓶颈是<code>malloc/free</code>两个内核内部的调用。CUDA动态设备内存需要<code>malloc/free</code>同步内核中的调用，导致并行执行退化为顺序执行。</p>
<p>（<strong>注</strong>：这个方法主要是为了对比 提前分配内存的消除核内分配内存的情况，以及后面的内存资源管理rmm）</p>
<h3 id="预分配工作内存以消除瓶颈">预分配工作内存以消除瓶颈</h3>
<p>通过在启动内核之前用预先<code>malloc/free</code>分配的工作内存替换内核中的调用<code>malloc/free</code>来消除瓶颈。</p>
<p>对于redact示例，此示例中每个字符串的输出大小不应大于输入字符串本身，因为逻辑仅删除字符。因此，可以使用与输入缓冲区大小相同的单个设备内存缓冲区。使用输入偏移量来定位每行位置。</p>
<p>访问字符串列的偏移量涉及用<code>cudf::strings_column_view</code>包装<code>cudf::column_view</code>并调用其<code> offsets_begin</code>方法。还可以使用<code>chars_size</code>方法访问<code>chars</code>子列的大小。然后在内核之前调用<code>rmm::device_uvector</code>预先分配内存，来存储字符输出数据。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">auto</span> <span class="k">const</span> <span class="n">scv</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">::</span><span class="n">strings_column_view</span><span class="p">(</span><span class="n">names</span><span class="p">);</span>
<span class="k">auto</span> <span class="k">const</span> <span class="n">offsets</span> <span class="o">=</span> <span class="n">scv</span><span class="p">.</span><span class="n">offsets_begin</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">working_memory</span> <span class="o">=</span> <span class="n">rmm</span><span class="o">::</span><span class="n">device_uvector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">scv</span><span class="p">.</span><span class="n">chars_size</span><span class="p">(),</span> <span class="n">stream</span><span class="p">);</span>
</code></pre></div><h3 id="预分配内核">预分配内核</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">__global__</span> <span class="kt">void</span> <span class="nf">redact_kernel</span><span class="p">(</span><span class="n">cudf</span><span class="o">::</span><span class="n">column_device_view</span> <span class="k">const</span> <span class="n">d_names</span><span class="p">,</span>
                              <span class="n">cudf</span><span class="o">::</span><span class="n">column_device_view</span> <span class="k">const</span> <span class="n">d_visibilities</span><span class="p">,</span>
                              <span class="n">cudf</span><span class="o">::</span><span class="n">string_view</span> <span class="n">redaction</span><span class="p">,</span>
                              <span class="kt">char</span><span class="o">*</span> <span class="n">working_memory</span><span class="p">,</span>
                              <span class="n">cudf</span><span class="o">::</span><span class="n">offset_type</span> <span class="k">const</span><span class="o">*</span> <span class="n">d_offsets</span><span class="p">,</span>
                              <span class="n">cudf</span><span class="o">::</span><span class="n">string_view</span><span class="o">*</span> <span class="n">d_output</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">index</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">d_names</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="k">return</span><span class="p">;</span>

  <span class="k">auto</span> <span class="k">const</span> <span class="n">visible</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">::</span><span class="n">string_view</span><span class="p">(</span><span class="s">&#34;public&#34;</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>

  <span class="k">auto</span> <span class="k">const</span> <span class="n">name</span> <span class="o">=</span> <span class="n">d_names</span><span class="p">.</span><span class="n">element</span><span class="o">&lt;</span><span class="n">cudf</span><span class="o">::</span><span class="n">string_view</span><span class="o">&gt;</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
  <span class="k">auto</span> <span class="k">const</span> <span class="n">vis</span>  <span class="o">=</span> <span class="n">d_visibilities</span><span class="p">.</span><span class="n">element</span><span class="o">&lt;</span><span class="n">cudf</span><span class="o">::</span><span class="n">string_view</span><span class="o">&gt;</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">vis</span> <span class="o">==</span> <span class="n">visible</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="k">const</span> <span class="n">space_idx</span>    <span class="o">=</span> <span class="n">name</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">);</span>
    <span class="k">auto</span> <span class="k">const</span> <span class="n">first</span>        <span class="o">=</span> <span class="n">name</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">space_idx</span><span class="p">);</span>
    <span class="k">auto</span> <span class="k">const</span> <span class="n">last_initial</span> <span class="o">=</span> <span class="n">name</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">space_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">auto</span> <span class="k">const</span> <span class="n">output_size</span>  <span class="o">=</span> <span class="n">first</span><span class="p">.</span><span class="n">size_bytes</span><span class="p">()</span> <span class="o">+</span> <span class="n">last_initial</span><span class="p">.</span><span class="n">size_bytes</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// resolve output string location
</span><span class="c1"></span>    <span class="kt">char</span><span class="o">*</span> <span class="n">output_ptr</span> <span class="o">=</span> <span class="n">working_memory</span> <span class="o">+</span> <span class="n">d_offsets</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="n">d_output</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>  <span class="o">=</span> <span class="n">cudf</span><span class="o">::</span><span class="n">string_view</span><span class="p">{</span><span class="n">output_ptr</span><span class="p">,</span> <span class="n">output_size</span><span class="p">};</span>

    <span class="c1">// build output string into output_ptr
</span><span class="c1"></span>    <span class="n">memcpy</span><span class="p">(</span><span class="n">output_ptr</span><span class="p">,</span> <span class="n">last_initial</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">last_initial</span><span class="p">.</span><span class="n">size_bytes</span><span class="p">());</span>
    <span class="n">output_ptr</span> <span class="o">+=</span> <span class="n">last_initial</span><span class="p">.</span><span class="n">size_bytes</span><span class="p">();</span>
    <span class="o">*</span><span class="n">output_ptr</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">output_ptr</span><span class="p">,</span> <span class="n">first</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">first</span><span class="p">.</span><span class="n">size_bytes</span><span class="p">());</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">d_output</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">::</span><span class="n">string_view</span><span class="p">{</span><span class="n">redaction</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">redaction</span><span class="p">.</span><span class="n">size_bytes</span><span class="p">()};</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>内核输出一个传递 <code>cudf::string_view</code> 给 <strong><a href="https://docs.rapids.ai/api/libcudf/nightly/group__column__factories.html#ga163234e4e6b8f95d7a8f1796a0c3c79d"><code>cudf::make_strings_column</code></a></strong> 工厂函数的对象向量。该函数的第二个参数用于识别输出列中的空条目。本文中的示例没有 null 条目，因此<code>cudf::string_view{nullptr,0}</code>使用 nullptr 占位符。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">auto</span> <span class="n">str_ptrs</span> <span class="o">=</span> <span class="n">rmm</span><span class="o">::</span><span class="n">device_uvector</span><span class="o">&lt;</span><span class="n">cudf</span><span class="o">::</span><span class="n">string_view</span><span class="o">&gt;</span><span class="p">(</span><span class="n">names</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">stream</span><span class="p">);</span>

<span class="n">redact_kernel</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span> <span class="n">block_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stream</span><span class="p">.</span><span class="n">value</span><span class="p">()</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">d_names</span><span class="p">,</span>
                                                         <span class="o">*</span><span class="n">d_visibilities</span><span class="p">,</span>
                                                         <span class="n">d_redaction</span><span class="p">.</span><span class="n">value</span><span class="p">(),</span>
                                                         <span class="n">working_memory</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>
                                                         <span class="n">offsets</span><span class="p">,</span>
                                                         <span class="n">str_ptrs</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>

<span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">::</span><span class="n">make_strings_column</span><span class="p">(</span><span class="n">str_ptrs</span><span class="p">,</span> <span class="n">cudf</span><span class="o">::</span><span class="n">string_view</span><span class="p">{</span><span class="k">nullptr</span><span class="p">,</span><span class="mi">0</span><span class="p">},</span> <span class="n">stream</span><span class="p">);</span>
</code></pre></div><p>这种方法在具有 60 万行数据的 A6000 上大约需要 1.1 毫秒，因此比基线快 2 倍以上。大致细分如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">  redact_kernel            66us
  make_strings_column     400us
</code></pre></div><p>剩余时间花费在<code>cudaMalloc, cudaFree, cudaMemcpy,</code>管理临时<code>rmm::device_uvector</code>实例的典型开销中。如果保证所有输出字符串的大小等于或小于输入字符串，则此方法效果很好。</p>
<p>总体而言，使用 RAPIDS RMM 切换到批量工作内存分配是一项重大改进，也是自定义字符串函数的良好解决方案。</p>
<h3 id="优化列创建以缩短计算时间">优化列创建以缩短计算时间</h3>
<p>有没有办法进一步改善这一点？现在的瓶颈是<code>cudf::make_strings_column</code> 工厂函数，它从 <code>cudf::string_view</code> 对象向量构建两个字符串列组件 <code>offsets</code> 和  <code>chars</code>。</p>
<p>在 libcudf 中，包含了许多工厂函数来构建字符串列。前面示例中使用的工厂函数获取<code>cudf::string_view</code>对象的<code>cudf::device_span</code>，然后通过对底层字符数据执行<code>gather</code>来构造列，以构建偏移量和字符子列。<code>rmm::device_uvector</code>可自动转换为<code>cudf::device_span</code>，而无需复制任何数据。</p>
<p>但是，如果直接构建字符向量和偏移向量，则可以使用不同的工厂函数，该函数只需创建字符串列，而不需要收集来复制数据。</p>
<p><code>sizes_kernel</code>首先传递输入数据，以计算每个输出行的确切输出大小：</p>
<h3 id="优化内核第-1-部分">优化内核：第 1 部分</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">__global__</span> <span class="kt">void</span> <span class="nf">sizes_kernel</span><span class="p">(</span><span class="n">cudf</span><span class="o">::</span><span class="n">column_device_view</span> <span class="k">const</span> <span class="n">d_names</span><span class="p">,</span>
                             <span class="n">cudf</span><span class="o">::</span><span class="n">column_device_view</span> <span class="k">const</span> <span class="n">d_visibilities</span><span class="p">,</span>
                             <span class="n">cudf</span><span class="o">::</span><span class="n">size_type</span><span class="o">*</span> <span class="n">d_sizes</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">index</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">d_names</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="k">return</span><span class="p">;</span>

  <span class="k">auto</span> <span class="k">const</span> <span class="n">visible</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">::</span><span class="n">string_view</span><span class="p">(</span><span class="s">&#34;public&#34;</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
  <span class="k">auto</span> <span class="k">const</span> <span class="n">redaction</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">::</span><span class="n">string_view</span><span class="p">(</span><span class="s">&#34;X X&#34;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

  <span class="k">auto</span> <span class="k">const</span> <span class="n">name</span> <span class="o">=</span> <span class="n">d_names</span><span class="p">.</span><span class="n">element</span><span class="o">&lt;</span><span class="n">cudf</span><span class="o">::</span><span class="n">string_view</span><span class="o">&gt;</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
  <span class="k">auto</span> <span class="k">const</span> <span class="n">vis</span>  <span class="o">=</span> <span class="n">d_visibilities</span><span class="p">.</span><span class="n">element</span><span class="o">&lt;</span><span class="n">cudf</span><span class="o">::</span><span class="n">string_view</span><span class="o">&gt;</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>

  <span class="n">cudf</span><span class="o">::</span><span class="n">size_type</span> <span class="n">result</span> <span class="o">=</span> <span class="n">redaction</span><span class="p">.</span><span class="n">size_bytes</span><span class="p">();</span> <span class="c1">// init to redaction size
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">vis</span> <span class="o">==</span> <span class="n">visible</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="k">const</span> <span class="n">space_idx</span>    <span class="o">=</span> <span class="n">name</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">);</span>
    <span class="k">auto</span> <span class="k">const</span> <span class="n">first</span>        <span class="o">=</span> <span class="n">name</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">space_idx</span><span class="p">);</span>
    <span class="k">auto</span> <span class="k">const</span> <span class="n">last_initial</span> <span class="o">=</span> <span class="n">name</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">space_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">first</span><span class="p">.</span><span class="n">size_bytes</span><span class="p">()</span> <span class="o">+</span> <span class="n">last_initial</span><span class="p">.</span><span class="n">size_bytes</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">d_sizes</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>然后通过执行 in-place <code>exclusive_scan</code>将输出大小转换为偏移量。请注意，<code>offsets</code>向量是用<code>names.size()+1</code>元素创建的。最后一个条目将是字节总数（所有大小加在一起），而第一个条目将为 0。这些都由<code>exclusive_scan</code>调用处理。从<code>offsets</code>列的最后一个条目检索<code>chars</code>列的大小，以构建字符向量。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// create offsets vector
</span><span class="c1"></span><span class="k">auto</span> <span class="n">offsets</span> <span class="o">=</span> <span class="n">rmm</span><span class="o">::</span><span class="n">device_uvector</span><span class="o">&lt;</span><span class="n">cudf</span><span class="o">::</span><span class="n">size_type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">names</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span>

<span class="c1">// compute output sizes
</span><span class="c1"></span><span class="n">sizes_kernel</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span> <span class="n">block_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stream</span><span class="p">.</span><span class="n">value</span><span class="p">()</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span>
  <span class="o">*</span><span class="n">d_names</span><span class="p">,</span> <span class="o">*</span><span class="n">d_visibilities</span><span class="p">,</span> <span class="n">offsets</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>

<span class="n">thrust</span><span class="o">::</span><span class="n">exclusive_scan</span><span class="p">(</span><span class="n">rmm</span><span class="o">::</span><span class="n">exec_policy</span><span class="p">(</span><span class="n">stream</span><span class="p">),</span> <span class="n">offsets</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">offsets</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">offsets</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
</code></pre></div><p><code>redact_kernel</code>逻辑仍然非常相同，只是它接受输出<code>d_offsets</code>向量来解析每行的输出位置：</p>
<h3 id="优化内核第-2-部分">优化内核：第 2 部分</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">__global__</span> <span class="kt">void</span> <span class="nf">redact_kernel</span><span class="p">(</span><span class="n">cudf</span><span class="o">::</span><span class="n">column_device_view</span> <span class="k">const</span> <span class="n">d_names</span><span class="p">,</span>
                              <span class="n">cudf</span><span class="o">::</span><span class="n">column_device_view</span> <span class="k">const</span> <span class="n">d_visibilities</span><span class="p">,</span>
                              <span class="n">cudf</span><span class="o">::</span><span class="n">size_type</span> <span class="k">const</span><span class="o">*</span> <span class="n">d_offsets</span><span class="p">,</span>
                              <span class="kt">char</span><span class="o">*</span> <span class="n">d_chars</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">index</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">d_names</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="k">return</span><span class="p">;</span>

  <span class="k">auto</span> <span class="k">const</span> <span class="n">visible</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">::</span><span class="n">string_view</span><span class="p">(</span><span class="s">&#34;public&#34;</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
  <span class="k">auto</span> <span class="k">const</span> <span class="n">redaction</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">::</span><span class="n">string_view</span><span class="p">(</span><span class="s">&#34;X X&#34;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

  <span class="c1">// resolve output_ptr using the offsets vector
</span><span class="c1"></span>  <span class="kt">char</span><span class="o">*</span> <span class="n">output_ptr</span>   <span class="o">=</span> <span class="n">d_chars</span> <span class="o">+</span> <span class="n">d_offsets</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

  <span class="k">auto</span> <span class="k">const</span> <span class="n">name</span> <span class="o">=</span> <span class="n">d_names</span><span class="p">.</span><span class="n">element</span><span class="o">&lt;</span><span class="n">cudf</span><span class="o">::</span><span class="n">string_view</span><span class="o">&gt;</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
  <span class="k">auto</span> <span class="k">const</span> <span class="n">vis</span> <span class="o">=</span> <span class="n">d_visibilities</span><span class="p">.</span><span class="n">element</span><span class="o">&lt;</span><span class="n">cudf</span><span class="o">::</span><span class="n">string_view</span><span class="o">&gt;</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">vis</span> <span class="o">==</span> <span class="n">visible</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="k">const</span> <span class="n">space_idx</span>    <span class="o">=</span> <span class="n">name</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">);</span>
    <span class="k">auto</span> <span class="k">const</span> <span class="n">first</span>        <span class="o">=</span> <span class="n">name</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">space_idx</span><span class="p">);</span>
    <span class="k">auto</span> <span class="k">const</span> <span class="n">last_initial</span> <span class="o">=</span> <span class="n">name</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">space_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">auto</span> <span class="k">const</span> <span class="n">output_size</span>  <span class="o">=</span> <span class="n">first</span><span class="p">.</span><span class="n">size_bytes</span><span class="p">()</span> <span class="o">+</span> <span class="n">last_initial</span><span class="p">.</span><span class="n">size_bytes</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// build output string
</span><span class="c1"></span>    <span class="n">memcpy</span><span class="p">(</span><span class="n">output_ptr</span><span class="p">,</span> <span class="n">last_initial</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">last_initial</span><span class="p">.</span><span class="n">size_bytes</span><span class="p">());</span>
    <span class="n">output_ptr</span> <span class="o">+=</span> <span class="n">last_initial</span><span class="p">.</span><span class="n">size_bytes</span><span class="p">();</span>
    <span class="o">*</span><span class="n">output_ptr</span><span class="o">++</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">output_ptr</span><span class="p">,</span> <span class="n">first</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">first</span><span class="p">.</span><span class="n">size_bytes</span><span class="p">());</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">output_ptr</span><span class="p">,</span> <span class="n">redaction</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">redaction</span><span class="p">.</span><span class="n">size_bytes</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>从<code>d_offsets</code>列的最后一个条目检索输出<code>d_chars</code>列的大小以分配字符向量。内核使用预先计算的偏移向量启动并返回填充的字符向量。最后，libcudf 字符串列工厂创建输出字符串列。</p>
<p>此<a href="https://docs.rapids.ai/api/libcudf/nightly/group__column__factories.html#ga86f7623f0d230c96491ef88d665385cc"><code>cudf::make_strings_column</code></a>工厂函数构建字符串列而不复制数据。<code>offsets</code>数据和<code> chars</code>数据已经采用正确的预期格式，该工厂只是从每个向量中移动数据并在其周围创建列结构。完成后，<code>offsets</code>和<code>chars</code>的<code>rmm::device_uvectors</code>为空，它们的数据已移动到输出列中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">cudf</span><span class="o">::</span><span class="n">size_type</span> <span class="n">output_size</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">.</span><span class="n">back_element</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">chars</span> <span class="o">=</span> <span class="n">rmm</span><span class="o">::</span><span class="n">device_uvector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">output_size</span><span class="p">,</span> <span class="n">stream</span><span class="p">);</span>

<span class="n">redact_kernel</span><span class="o">&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span> <span class="n">block_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stream</span><span class="p">.</span><span class="n">value</span><span class="p">()</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span>
    <span class="o">*</span><span class="n">d_names</span><span class="p">,</span> <span class="o">*</span><span class="n">d_visibilities</span><span class="p">,</span> <span class="n">offsets</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">chars</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>

<span class="c1">// from pre-assembled offsets and character buffers
</span><span class="c1"></span><span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">::</span><span class="n">make_strings_column</span><span class="p">(</span><span class="n">names</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">offsets</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">chars</span><span class="p">));</span>
</code></pre></div><p>这种方法在具有 600K 行数据的 A6000 上大约需要 300 us (0.3 ms)，比之前的方法提高了 2 倍以上。您可能会注意到<code>sizes_kernel</code>和<code>redact_kernel</code>共享很多相同的逻辑：一次测量输出的大小，然后再次填充输出。</p>
<p>从代码质量的角度来看，将转换重构为由<code>sizes_kernel</code>和<code>redact_kernel</code>调用的设备函数是有益的。从性能角度来看，您可能会惊讶地发现转换的计算成本被支付了两倍。</p>
<p>内存管理和更高效的列创建的好处通常超过执行两次转换的计算成本。</p>
<p>表 2 显示了本文讨论的四种解决方案的计算时间、内核计数和处理的字节数。“内核启动总数”反映了启动的内核总数，包括计算内核和辅助内核。“处理的总字节数”是累积的 DRAM 读取和写入吞吐量，“处理的最小字节数”是我们的测试输入和输出的平均每行 37.9 字节。理想的“内存带宽有限”情况假设带宽为 768 GB/s，这是 A6000 的理论峰值吞吐量。</p>
<p><img src="https://github.com/weedge/mypic/raw/master/oneday/mastering-string-transformations-in-rapids-libcudf/5.png" alt="该表显示了本文讨论的四种解决方案的计算时间、内核计数和处理的字节数。"></p>
<p><em>表 2. 本文讨论的四种解决方案的计算时间、内核计数和处理的字节数</em></p>
<p>由于内核启动次数减少和处理的总字节数减少，“优化内核”提供了最高的吞吐量。借助高效的自定义内核，内核启动总数从 31 次减少到 4 次，处理的总字节数从输入加输出大小的 12.6 倍减少到 1.75 倍。</p>
<p>因此，定制内核的吞吐量比用于编辑转换的通用字符串 API 高 10 倍以上。</p>
<h2 id="峰值性能分析">峰值性能分析</h2>
<p><a href="https://developer.nvidia.com/blog/fast-flexible-allocation-for-cuda-with-rapids-memory-manager/">RAPIDS 内存管理器 (RMM)</a>中的池内存资源是另一个可用于提高性能的工具。上面的示例使用默认的“CUDA 内存资源”来分配和释放全局设备内存。然而，分配工作内存所需的时间会增加字符串转换步骤之间的显着延迟。RMM 中的“内存池资源”通过预先分配大量内存并在处理过程中根据需要分配子分配来减少延迟。</p>
<p>使用 CUDA 内存资源，“优化内核”显示了 10 倍到 15 倍的加速，但由于分配大小的增加，加速在行数增加时开始下降（图 3）。使用池内存资源可以减轻这种影响，并比 libcudf strings API 方法保持 15-25 倍的加速。</p>
<p><img src="https://github.com/weedge/mypic/raw/master/oneday/mastering-string-transformations-in-rapids-libcudf/6.png" alt="对于 600K 到 10M 的行计数范围，使用自定义内核与 libcudf 字符串 API 的加速效果的散点图。 加速数据包括 4 个条件：“预分配内核”和“优化内核”，具有 CUDA 内存资源和池内存资源。 在每种情况下，池内存资源的性能均优于 CUDA 内存资源。 “优化内核 + RMM 池”显示大约 12-25 倍加速，“预分配内核 + RMM 池”显示 5-10 倍加速。"></p>
<p><em>图 3. 使用默认 CUDA 内存资源（实线）和池内存资源（虚线)的自定义内核“预分配内核”和“优化内核”的加速与使用默认 CUDA 内存资源的 libcudf 字符串 API 的加速</em></p>
<p>利用池内存资源，证明了端到端内存吞吐量接近两遍算法的理论极限。使用输入大小加上输出大小和计算时间来测量，“优化内核”的吞吐量达到 320-340 GB/s（图 4）。</p>
<p>两遍方法首先测量输出元素的大小，分配内存，然后使用输出设置内存。给定两遍处理算法，“优化内核”中的实现的性能接近内存带宽限制。“端到端内存吞吐量”定义为输入加输出大小（以 GB 为单位）除以计算时间。RTX A6000 内存带宽 (768 GB/s)。</p>
<p><img src="https://github.com/weedge/mypic/raw/master/oneday/mastering-string-transformations-in-rapids-libcudf/7.png" alt="散点图显示“优化内核”、“预分配内核”和“libcudf 字符串 API”的内存吞吐量与输入/输出行计数的函数关系。 “端到端内存吞吐量”定义为输入加输出大小（以 GB 为单位）除以计算时间。 使用池内存资源时，“libcudf strings API”饱和度约为 40 GB/s，“预分配内核”饱和度约为 150 GB/s，“优化内核”饱和度约为 340 GB/s。"></p>
<p><em>图 4. “优化内核”、“预分配内核”和“libcudf 字符串 API”的内存吞吐量与输入/输出行计数的关系</em></p>
<h2 id="概要">概要</h2>
<p>这篇文章演示了在 <a href="https://docs.rapids.ai/api/libcudf/nightly/index.html">libcudf</a> 中编写高效字符串数据转换的两种方法。libcudf 通用 API 对于开发人员来说快速、简单，并且提供良好的性能。libcudf 还提供了专为与自定义内核一起使用而设计的设备端实用程序，在本例中解锁了 10 倍以上的更快性能。</p>
<h2 id="reference">Reference</h2>
<ol>
<li><a href="https://developer.nvidia.com/blog/mastering-string-transformations-in-rapids-libcudf/">https://developer.nvidia.com/blog/mastering-string-transformations-in-rapids-libcudf/</a></li>
<li><a href="https://docs.rapids.ai/api/libcudf/nightly/index.html">https://docs.rapids.ai/api/libcudf/nightly/index.html</a></li>
<li><a href="https://github.com/rapidsai/cudf/tree/HEAD/cpp/examples/strings">https://github.com/rapidsai/cudf/tree/HEAD/cpp/examples/strings</a></li>
</ol>
    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">weedge</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
      2023-11-07
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://weedge.github.io/tags/oneday/">oneday</a>
          <a href="https://weedge.github.io/tags/gpu/">gpu</a>
          <a href="https://weedge.github.io/tags/rapids-libcudf/">RAPIDS libcudf</a>
          <a href="https://weedge.github.io/tags/string/">string</a>
          
        </div>

      
      <nav class="post-nav">
        
        
          <a class="next" href="/post/gpu/3.accelerated-vector-search-approximating-with-rapids-raft-ivf-flat/">
            <span class="next-text nav-default">译：加速向量搜索：RAPIDS RAFT IVF-Flat 近似算法</span>
            <span class="prev-text nav-mobile">下一篇</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  

  
  

  

  
  

  

  

  <div class="disqus-comment">
  <div class="disqus-button" id="load_disqus" onclick="load_disqus()">
    显示 Disqus 评论
  </div>
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_config = function () {
      this.page.url = "https://weedge.github.io/post/gpu/mastering-string-transformations-in-rapids-libcudf/";
    };
    function load_disqus() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'weedge';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);

      $('#load_disqus').remove();
    };
  </script>
  <noscript>Please enable JavaScript to view the
    <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
  </noscript>
  
  </div>

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="mailto:weege007@gmail.com" rel="me noopener" class="iconfont"
      title="email" >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://github.com/weedge" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>
  
    <a href="https://weibo.com/weedge" rel="me noopener" class="iconfont"
      title="weibo"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M385.714286 733.714286q12-19.428571 6.285714-39.428571t-25.714286-28.571429q-19.428571-8-41.714286-0.571429t-34.285714 26.285714q-12.571429 19.428571-7.428571 39.142857t24.571429 28.857143 42.571429 1.428571 35.714286-27.142857zm53.714286-69.142857q4.571429-7.428571 2-15.142857t-10-10.571429q-8-2.857143-16.285714 2.857143t-12.285714 10.571429q-9.714286 17.714286 7.428571 25.714286 8 2.857143 16.571429 2.857143t12.571429-10.571429zm99.428571 61.142857q-25.714286 58.285714-90.285714 85.714286t-128 6.857143q-61.142857-19.428571-84.285714-72.285714t3.714286-107.142857q26.857143-53.142857 86.571429-79.428571t120.285714-10.857143q63.428571 16.571429 90.571429 68.285714t1.428571 108.857143zm178.285714-91.428571q-5.142857-54.857143-50.857143-97.142857t-119.142857-62.285714-156.857143-12q-127.428571 13.142857-211.142857 80.857143t-75.714286 151.142857q5.142857 54.857143 50.857143 97.142857t119.142857 62.285714 156.857143 12q127.428571-13.142857 211.142857-80.857143t75.714286-151.142857zm176 2.285714q0 38.857143-21.142857 79.714286t-62.285714 78.285714-96.285714 67.142857-129.142857 47.428571-154.571429 17.714286-157.142857-19.142857-137.428571-53.142857-98-86.285714-37.142857-114q0-65.714286 39.714286-140t112.857143-147.428571q96.571429-96.571429 195.142857-134.857143t140.857143 4q37.142857 36.571429 11.428571 119.428571-2.285714 8-0.571429 11.428571t5.714286 4 8.285714 2.857143 7.714286-2l3.428571-1.142857q79.428571-33.714286 140.571429-33.714286t87.428571 34.857143q25.714286 36 0 101.714286-1.142857 7.428571-2.571429 11.428571t2.571429 7.142857 6.857143 4.285714 9.714286 3.428571q32.571429 10.285714 58.857143 26.857143t45.714286 46.571429 19.428571 66.571429zm-42.285714-356.571429q24 26.857143 31.142857 62t-3.714286 67.142857q-4.571429 13.142857-16.857143 19.428571t-25.428571 2.285714q-13.142857-4.571429-19.428571-16.857143t-2.285714-25.428571q11.428571-36-13.714286-63.428571t-61.142857-20q-13.714286 2.857143-25.714286-4.571429t-14.285714-21.142857q-2.857143-13.714286 4.571429-25.428571t21.142857-14.571429q34.285714-7.428571 68 3.142857t57.714286 37.428571zm103.428571-93.142857q49.714286 54.857143 64.285714 127.142857t-7.714286 138q-5.142857 15.428571-19.428571 22.857143t-29.714286 2.285714-22.857143-19.428571-2.857143-29.714286q16-46.857143 5.714286-98.285714t-45.714286-90.285714q-35.428571-39.428571-84.571429-54.571429t-98.857143-4.857143q-16 3.428571-29.714286-5.428571t-17.142857-24.857143 5.428571-29.428571 24.857143-16.857143q70.285714-14.857143 139.428571 6.571429t118.857143 76.857143z"></path>
</svg>

    </a>


<a href="https://weedge.github.io/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2013 -
    2023
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        weedge
        
      </span></span>

  
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  









  <script id="dsq-count-scr" src="//weedge.disqus.com/count.js" async></script>






  <script src="/js/copy-to-clipboard.js"></script>


</body>
</html>
