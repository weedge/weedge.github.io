<!DOCTYPE html>
<html lang="zh-cn" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>[译]构建一个简单的数据库 - 时间飘过</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="weedge" />
  <meta name="description" content="用 C 从头开始编写 SQLite 克隆；
注：用chatGPT翻译&#43;人工稍微整理下，耗时一个多小时整理完成，使用这个简单的db from scratch试下效果, 代码简单；现在高中甚至初中生有在学这个。
原文地址： https://cstack.github.io/db_tutorial/
数据库如何工作？  数据以什么格式保存？（在内存和磁盘上） 它什么时候从内存移动到磁盘？ 为什么一张表只能有一个主键？ 回滚事务如何进行？ 索引是如何格式化的？ 全表扫描何时以及如何发生？ 准备好的语句以什么格式保存？  简而言之，数据库是如何工作的？
为了理解，我正在用 C 从头开始构建sqlite的克隆，并且我将记录我的过程。
 “我无法创造的东西，我就不明白。What I cannot create, I do not understand” ——理查德·费曼
 " />

  <meta name="keywords" content="工作, 技术, 生活" />






<meta name="generator" content="Hugo 0.91.0" />


<link rel="canonical" href="https://weedge.github.io/post/db_tutorial_zh/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.fa4b2b9f31b5c6d0b683db81157a9226e17b06e61911791ab547242a4a0556f2.css" integrity="sha256-&#43;ksrnzG1xtC2g9uBFXqSJuF7BuYZEXkatUckKkoFVvI=" media="screen" crossorigin="anonymous">




<link rel="stylesheet" href="/css/copy-to-clipboard.css">


<meta property="og:title" content="[译]构建一个简单的数据库" />
<meta property="og:description" content="用 C 从头开始编写 SQLite 克隆；
注：用chatGPT翻译&#43;人工稍微整理下，耗时一个多小时整理完成，使用这个简单的db from scratch试下效果, 代码简单；现在高中甚至初中生有在学这个。
原文地址： https://cstack.github.io/db_tutorial/
数据库如何工作？

数据以什么格式保存？（在内存和磁盘上）
它什么时候从内存移动到磁盘？
为什么一张表只能有一个主键？
回滚事务如何进行？
索引是如何格式化的？
全表扫描何时以及如何发生？
准备好的语句以什么格式保存？

简而言之，数据库是如何工作的？
为了理解，我正在用 C 从头开始构建sqlite的克隆，并且我将记录我的过程。

“我无法创造的东西，我就不明白。What I cannot create, I do not understand” ——理查德·费曼

" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://weedge.github.io/post/db_tutorial_zh/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2024-01-09T11:26:23+08:00" />
<meta property="article:modified_time" content="2024-01-09T11:26:23+08:00" />

<meta itemprop="name" content="[译]构建一个简单的数据库">
<meta itemprop="description" content="用 C 从头开始编写 SQLite 克隆；
注：用chatGPT翻译&#43;人工稍微整理下，耗时一个多小时整理完成，使用这个简单的db from scratch试下效果, 代码简单；现在高中甚至初中生有在学这个。
原文地址： https://cstack.github.io/db_tutorial/
数据库如何工作？

数据以什么格式保存？（在内存和磁盘上）
它什么时候从内存移动到磁盘？
为什么一张表只能有一个主键？
回滚事务如何进行？
索引是如何格式化的？
全表扫描何时以及如何发生？
准备好的语句以什么格式保存？

简而言之，数据库是如何工作的？
为了理解，我正在用 C 从头开始构建sqlite的克隆，并且我将记录我的过程。

“我无法创造的东西，我就不明白。What I cannot create, I do not understand” ——理查德·费曼

"><meta itemprop="datePublished" content="2024-01-09T11:26:23+08:00" />
<meta itemprop="dateModified" content="2024-01-09T11:26:23+08:00" />
<meta itemprop="wordCount" content="32247">
<meta itemprop="keywords" content="db," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="[译]构建一个简单的数据库"/>
<meta name="twitter:description" content="用 C 从头开始编写 SQLite 克隆；
注：用chatGPT翻译&#43;人工稍微整理下，耗时一个多小时整理完成，使用这个简单的db from scratch试下效果, 代码简单；现在高中甚至初中生有在学这个。
原文地址： https://cstack.github.io/db_tutorial/
数据库如何工作？

数据以什么格式保存？（在内存和磁盘上）
它什么时候从内存移动到磁盘？
为什么一张表只能有一个主键？
回滚事务如何进行？
索引是如何格式化的？
全表扫描何时以及如何发生？
准备好的语句以什么格式保存？

简而言之，数据库是如何工作的？
为了理解，我正在用 C 从头开始构建sqlite的克隆，并且我将记录我的过程。

“我无法创造的东西，我就不明白。What I cannot create, I do not understand” ——理查德·费曼

"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->







</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">时间飘过</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://weedge.github.io/">主页</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://weedge.github.io/post/">归档</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://weedge.github.io/tags/">标签</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://weedge.github.io/categories/">分类</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://weedge.github.io/about/">About</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://weedge.github.io/perf-book-cn/zh/" rel="noopener" target="_blank">
              《现代CPU性能分析与优化》
              
              <i class="iconfont">
                <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6C496.064 467.648 528.64 500.224 528.64 500.224 534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92 0 0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"></path>
  <path d="M841.152 457.152c-30.528 0-54.784 24.512-54.784 54.656l0 274.752L237.696 786.56 237.696 237.696l206.016 0c6.656 0 10.752 0 13.248 0C487.68 237.696 512 213.184 512 182.848 512 152.32 487.36 128 456.96 128L183.04 128C153.216 128 128 152.576 128 182.848c0 3.136 0.256 6.272 0.768 9.28C128.256 195.136 128 198.272 128 201.408l0 639.488c0 0.064 0 0.192 0 0.256 0 0.128 0 0.192 0 0.32 0 30.528 24.512 54.784 54.784 54.784l646.976 0c6.592 0 9.728 0 11.712 0 28.736 0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344l0-20.352L896 561.408 896 512.128C896 481.792 871.424 457.152 841.152 457.152z"></path>
</svg>

              </i>
            </a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      时间飘过
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://weedge.github.io/">主页</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://weedge.github.io/post/">归档</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://weedge.github.io/tags/">标签</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://weedge.github.io/categories/">分类</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://weedge.github.io/about/">About</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://weedge.github.io/perf-book-cn/zh/" rel="noopener" target="_blank">
              《现代CPU性能分析与优化》
              
              <i class="iconfont">
                <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6C496.064 467.648 528.64 500.224 528.64 500.224 534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92 0 0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"></path>
  <path d="M841.152 457.152c-30.528 0-54.784 24.512-54.784 54.656l0 274.752L237.696 786.56 237.696 237.696l206.016 0c6.656 0 10.752 0 13.248 0C487.68 237.696 512 213.184 512 182.848 512 152.32 487.36 128 456.96 128L183.04 128C153.216 128 128 152.576 128 182.848c0 3.136 0.256 6.272 0.768 9.28C128.256 195.136 128 198.272 128 201.408l0 639.488c0 0.064 0 0.192 0 0.256 0 0.128 0 0.192 0 0.32 0 30.528 24.512 54.784 54.784 54.784l646.976 0c6.592 0 9.728 0 11.712 0 28.736 0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344l0-20.352L896 561.408 896 512.128C896 481.792 871.424 457.152 841.152 457.152z"></path>
</svg>

              </i>
            </a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">[译]构建一个简单的数据库</h1>
      
      <div class="post-meta">
        <time datetime="2024-01-09" class="post-time">
          2024-01-09
        </time>
        <div class="post-category">
            <a href="https://weedge.github.io/categories/%E6%8A%80%E6%9C%AF/"> 技术 </a>
            
          </div>
        

        
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#数据库如何工作">数据库如何工作？</a></li>
    <li><a href="#第一部分---简介和设置repl">第一部分 - 简介和设置REPL</a></li>
    <li><a href="#sqlite">Sqlite</a>
      <ul>
        <li><a href="#制作一个简单的-repl">制作一个简单的 REPL</a></li>
      </ul>
    </li>
    <li><a href="#第二部分---世界上最简单的sql编译器和虚拟机">第二部分 - 世界上最简单的SQL编译器和虚拟机</a></li>
    <li><a href="#第三部分---内存中追加方式单表数据库">第三部分 - 内存中、追加方式、单表数据库</a></li>
    <li><a href="#第四部分---我们的第一个测试bug">第四部分 - 我们的第一个测试（Bug）</a></li>
    <li><a href="#第五部分---持久化到磁盘">第五部分 - 持久化到磁盘</a>
      <ul>
        <li><a href="#结论">结论</a></li>
        <li><a href="#完整的变更">完整的变更</a></li>
      </ul>
    </li>
    <li><a href="#第六部分---游标抽象">第六部分 - 游标抽象</a></li>
    <li><a href="#第七部分---b-tree简介">第七部分 - B-Tree简介</a></li>
    <li><a href="#第八部分---b-tree叶节点格式">第八部分 - B-Tree叶节点格式</a>
      <ul>
        <li><a href="#替代表格式">替代表格式</a></li>
        <li><a href="#节点头格式">节点头格式</a></li>
        <li><a href="#叶节点格式">叶节点格式</a></li>
        <li><a href="#访问叶节点字段">访问叶节点字段</a></li>
        <li><a href="#pager和table对象的更改">Pager和Table对象的更改</a></li>
        <li><a href="#cursor对象的更改">Cursor对象的更改</a></li>
        <li><a href="#向叶节点插入数据">向叶节点插入数据</a></li>
        <li><a href="#打印常量的命令">打印常量的命令</a></li>
      </ul>
    </li>
    <li><a href="#树的可视化">树的可视化</a>
      <ul>
        <li><a href="#下一步计划">下一步计划</a></li>
        <li><a href="#完整的代码变更">完整的代码变更</a></li>
      </ul>
    </li>
    <li><a href="#第九部分---二分搜索和重复键">第九部分 - 二分搜索和重复键</a></li>
    <li><a href="#第十部分---分裂叶子节点">第十部分 - 分裂叶子节点</a></li>
    <li><a href="#分裂算法">分裂算法</a></li>
    <li><a href="#分配新页面">分配新页面</a>
      <ul>
        <li><a href="#叶子节点大小">叶子节点大小</a></li>
        <li><a href="#创建一个新的根节点">创建一个新的根节点</a></li>
        <li><a href="#内部节点格式">内部节点格式</a></li>
        <li><a href="#跟踪根节点状态">跟踪根节点状态</a></li>
        <li><a href="#打印树结构">打印树结构</a></li>
        <li><a href="#一个大问题">一个大问题</a></li>
      </ul>
    </li>
    <li><a href="#第十一部分---递归搜索-b-树">第十一部分 - 递归搜索 B 树</a>
      <ul>
        <li><a href="#测试">测试</a></li>
      </ul>
    </li>
    <li><a href="#第十二部分---扫描多层-b-树">第十二部分 - 扫描多层 B 树</a></li>
    <li><a href="#第十三部分---分裂叶子节点后更新父节点">第十三部分 - 分裂叶子节点后更新父节点</a></li>
    <li><a href="#第十四部分---拆分内部节点">第十四部分 - 拆分内部节点</a></li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <p>用 C 从头开始编写 SQLite 克隆；</p>
<p>注：用chatGPT翻译+人工稍微整理下，耗时一个多小时整理完成，使用这个简单的db from scratch试下效果, 代码简单；现在高中甚至初中生有在学这个。</p>
<p>原文地址： <a href="https://cstack.github.io/db_tutorial/">https://cstack.github.io/db_tutorial/</a></p>
<h2 id="数据库如何工作">数据库如何工作？</h2>
<ul>
<li>数据以什么格式保存？（在内存和磁盘上）</li>
<li>它什么时候从内存移动到磁盘？</li>
<li>为什么一张表只能有一个主键？</li>
<li>回滚事务如何进行？</li>
<li>索引是如何格式化的？</li>
<li>全表扫描何时以及如何发生？</li>
<li>准备好的语句以什么格式保存？</li>
</ul>
<p>简而言之，数据库是如何<strong>工作的</strong>？</p>
<p>为了理解，我正在用 C 从头开始构建<a href="https://www.sqlite.org/arch.html">sqlite</a>的克隆，并且我将记录我的过程。</p>
<blockquote>
<p>“我无法创造的东西，我就不明白。<em>What I cannot create, I do not understand</em>” ——<a href="https://en.m.wikiquote.org/wiki/Richard_Feynman">理查德·费曼</a></p>
</blockquote>
<p><img src="https://cstack.github.io/db_tutorial/assets/images/arch2.gif" alt="sqlite 架构（https://www.sqlite.org/arch.html）"></p>
<h2 id="第一部分---简介和设置repl">第一部分 - 简介和设置REPL</h2>
<p>作为一名网页开发者，我每天都在工作中使用关系数据库，但它们对我来说就像一个黑匣子。我有一些问题：</p>
<ul>
<li>数据保存在什么格式中？（在内存和磁盘上）</li>
<li>何时将数据从内存移动到磁盘？</li>
<li>为什么每个表只能有一个主键？</li>
<li>事务回滚是如何工作的？</li>
<li>索引是如何格式化的？</li>
<li>何时以及如何进行全表扫描？</li>
<li>准备好的语句保存在什么格式中？</li>
</ul>
<p>换句话说，数据库是如何<strong>工作</strong>的呢？</p>
<p>为了弄清楚这些问题，我正在从零开始编写一个数据库。它的模型是基于SQLite的，因为它设计得很小，比MySQL或PostgreSQL少了一些特性，所以我更有希望能理解它。整个数据库存储在单个文件中！</p>
<h2 id="sqlite">Sqlite</h2>
<p>在他们的网站上有很多关于sqlite内部的<a href="https://www.sqlite.org/arch.html">文档</a>，而且我也有一本<a href="https://play.google.com/store/books/details?id=9Z6IQQnX1JEC">《SQLite数据库系统：设计与实现》</a>的副本(看是否可以撸一遍，仅翻译，看sqlite具体版本源码了解细节)。</p>
<p><img src="https://cstack.github.io/db_tutorial/assets/images/arch1.gif" alt="sqlite"></p>
<p>sqlite 架构 (<a href="https://www.sqlite.org/zipvfs/doc/trunk/www/howitworks.wiki">https://www.sqlite.org/zipvfs/doc/trunk/www/howitworks.wiki</a>)</p>
<p>一个查询需要通过一系列组件来检索或修改数据。<strong>前端</strong>包括：</p>
<ul>
<li>分词器（tokenizer）</li>
<li>解析器（parser）</li>
<li>代码生成器（code generator）</li>
</ul>
<p>前端的输入是一个 SQL 查询，输出是 SQLite 虚拟机的字节码（实质上是一个可以操作数据库的编译程序）。</p>
<p><strong>后端</strong>包括：</p>
<ul>
<li>虚拟机（virtual machine）</li>
<li>B-树（B-tree）</li>
<li>页面管理器（pager）</li>
<li>操作系统接口（os interface）</li>
</ul>
<p><strong>虚拟机</strong>接受前端生成的字节码作为指令。然后，它可以对一个或多个表或索引执行操作，每个表或索引都存储在一个称为 B-树 的数据结构中。虚拟机实质上是针对字节码指令类型的一个大型开关语句。</p>
<p>每个<strong>B-树</strong>由许多节点组成，每个节点的长度为一个页面。B-树可以通过向页面管理器发出命令来从磁盘检索页面或将其保存回磁盘。</p>
<p><strong>页面管理器</strong>接收读取或写入数据页面的命令。它负责在数据库文件中适当的偏移位置读取/写入数据。它还在内存中保持最近访问的页面的缓存，并确定何时需要将这些页面写回磁盘。</p>
<p><strong>操作系统接口</strong>是一个根据 SQLite 编译的操作系统而不同的层。在本教程中，我不会支持多个平台。</p>
<p><a href="https://en.wiktionary.org/wiki/a_journey_of_a_thousand_miles_begins_with_a_single_step">千里之行始于足下</a>，所以让我们从一些更简单的事情开始：创建一个简单的 REPL。</p>
<h3 id="制作一个简单的-repl">制作一个简单的 REPL</h3>
<p>当你从命令行启动 SQLite 时，它会开始一个读取-执行-打印循环：</p>
<p>这段代码创建了一个简单的数据库 REPL（Read-Eval-Print Loop）。它包含了一些关键功能：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdbool.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">buffer</span><span class="p">;</span>
  <span class="n">size_t</span> <span class="n">buffer_length</span><span class="p">;</span>
  <span class="n">ssize_t</span> <span class="n">input_length</span><span class="p">;</span>
<span class="p">}</span> <span class="n">InputBuffer</span><span class="p">;</span>

<span class="n">InputBuffer</span><span class="o">*</span> <span class="nf">new_input_buffer</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">InputBuffer</span><span class="p">));</span>
  <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">input_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">input_buffer</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">print_prompt</span><span class="p">()</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&#34;db &gt; &#34;</span><span class="p">);</span> <span class="p">}</span>

<span class="kt">void</span> <span class="nf">read_input</span><span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ssize_t</span> <span class="n">bytes_read</span> <span class="o">=</span>
      <span class="n">getline</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">),</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer_length</span><span class="p">),</span> <span class="n">stdin</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">bytes_read</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error reading input</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Ignore trailing newline
</span><span class="c1"></span>  <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">input_length</span> <span class="o">=</span> <span class="n">bytes_read</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">bytes_read</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">close_input_buffer</span><span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">free</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span> <span class="o">=</span> <span class="n">new_input_buffer</span><span class="p">();</span>
  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print_prompt</span><span class="p">();</span>
    <span class="n">read_input</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;.exit&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">close_input_buffer</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">);</span>
      <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Unrecognized command &#39;%s&#39;.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这段代码创建了一个基本的交互式命令行界面，类似于 SQLite 的命令行界面。它能够读取用户输入，并检测特定的命令（如 <code>.exit</code>）以退出循环，否则会显示错误消息。这是一个很好的起点，接下来可以在此基础上逐步构建更多功能，实现数据库的基本交互。</p>
<p>让我们创建一个简单的REPL。</p>
<p>首先，我们需要一个无限循环的主函数，它会打印提示符，获取输入行，然后处理该输入行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span> <span class="o">=</span> <span class="n">new_input_buffer</span><span class="p">();</span>
  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print_prompt</span><span class="p">();</span>
    <span class="n">read_input</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;.exit&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">close_input_buffer</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">);</span>
      <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Unrecognized command &#39;%s&#39;.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>接下来，我们定义<code>InputBuffer</code>作为围绕我们需要存储以与 <a href="http://man7.org/linux/man-pages/man3/getline.3.html">getline()</a> 交互所需状态的小包装器。（稍后会详细解释）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">buffer</span><span class="p">;</span>
  <span class="n">size_t</span> <span class="n">buffer_length</span><span class="p">;</span>
  <span class="n">ssize_t</span> <span class="n">input_length</span><span class="p">;</span>
<span class="p">}</span> <span class="n">InputBuffer</span><span class="p">;</span>

<span class="n">InputBuffer</span><span class="o">*</span> <span class="nf">new_input_buffer</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">InputBuffer</span><span class="p">));</span>
  <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">input_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">input_buffer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>接下来，<code>print_prompt()</code>用于向用户打印提示。我们在读取每行输入之前都会这样做。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">print_prompt</span><span class="p">()</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&#34;db &gt; &#34;</span><span class="p">);</span> <span class="p">}</span>
</code></pre></div><p>要读取一行输入，我们使用 <a href="http://man7.org/linux/man-pages/man3/getline.3.html">getline()</a>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">ssize_t</span> <span class="nf">getline</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">lineptr</span><span class="p">,</span> <span class="n">size_t</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="n">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>
</code></pre></div><ul>
<li><code>lineptr</code>：指向我们用于指向包含读取行的缓冲区的变量的指针。如果设置为<code>NULL</code>，它将由<code>getline</code>进行分配，因此即使命令失败，用户也应该释放它。</li>
<li><code>n</code>：指向我们用于保存分配缓冲区大小的变量的指针。</li>
<li><code>stream</code>：要从中读取的输入流。我们将从标准输入读取。</li>
</ul>
<p><code>返回值</code>：读取的字节数，可能小于缓冲区的大小。</p>
<p>我们告诉 <code>getline</code> 将读取的行存储在 <code>input_buffer-&gt;buffer</code> 中，并将分配缓冲区的大小存储在 <code>input_buffer-&gt;buffer_length</code> 中。我们将返回值存储在 <code>input_buffer-&gt;input_length</code> 中。</p>
<p><code>buffer</code> 最初为空，因此 <code>getline</code> 分配足够的内存来存储输入行，并使 <code>buffer</code> 指向它。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">read_input</span><span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ssize_t</span> <span class="n">bytes_read</span> <span class="o">=</span>
      <span class="n">getline</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">),</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer_length</span><span class="p">),</span> <span class="n">stdin</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">bytes_read</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error reading input</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// 忽略行尾的换行符
</span><span class="c1"></span>  <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">input_length</span> <span class="o">=</span> <span class="n">bytes_read</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">bytes_read</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>接下来，我们需要定义一个函数来释放为 <code>InputBuffer *</code> 实例和该结构的 <code>buffer</code> 元素分配的内存（<code>getline</code> 在 <code>read_input</code> 中为 <code>input_buffer-&gt;buffer</code> 分配内存）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">close_input_buffer</span><span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">free</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>最后，我们解析并执行命令。目前只有一个可识别的命令：<code>.exit</code>，用于终止程序。否则，我们会打印错误消息并继续循环。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;.exit&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">close_input_buffer</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Unrecognized command &#39;%s&#39;.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>让我们试试看！</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">~ ./db
db &gt; .tables
Unrecognized <span class="nb">command</span> <span class="s1">&#39;.tables&#39;</span>.
db &gt; .exit
~
</code></pre></div><p>好了，我们有一个工作的REPL。在下一部分中，我们将开始开发我们的命令语言。与此同时，以下是本节的整个程序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdbool.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">buffer</span><span class="p">;</span>
  <span class="n">size_t</span> <span class="n">buffer_length</span><span class="p">;</span>
  <span class="n">ssize_t</span> <span class="n">input_length</span><span class="p">;</span>
<span class="p">}</span> <span class="n">InputBuffer</span><span class="p">;</span>

<span class="n">InputBuffer</span><span class="o">*</span> <span class="nf">new_input_buffer</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">InputBuffer</span><span class="p">));</span>
  <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">input_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">input_buffer</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">print_prompt</span><span class="p">()</span> <span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&#34;db &gt; &#34;</span><span class="p">);</span> <span class="p">}</span>

<span class="kt">void</span> <span class="nf">read_input</span><span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ssize_t</span> <span class="n">bytes_read</span> <span class="o">=</span>
      <span class="n">getline</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">),</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer_length</span><span class="p">),</span> <span class="n">stdin</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">bytes_read</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error reading input</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// 忽略行尾的换行符
</span><span class="c1"></span>  <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">input_length</span> <span class="o">=</span> <span class="n">bytes_read</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">bytes_read</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">close_input_buffer</span><span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">free</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span> <span class="o">=</span> <span class="n">new_input_buffer</span><span class="p">();</span>
  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print_prompt</span><span class="p">();</span>
    <span class="n">read_input</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;.exit&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">close_input_buffer</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">);</span>
      <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Unrecognized command &#39;%s&#39;.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="第二部分---世界上最简单的sql编译器和虚拟机">第二部分 - 世界上最简单的SQL编译器和虚拟机</h2>
<p>我们正在制作一个 SQLite 的克隆版本。SQLite 的“前端”是一个 SQL 编译器，它解析字符串并输出称为字节码的内部表示形式。</p>
<p>这个字节码被传递给虚拟机，然后由虚拟机执行。</p>
<p><img src="https://cstack.github.io/db_tutorial/assets/images/arch2.gif" alt="SQLite Architecture"></p>
<p>将任务分成两个步骤有几个优点：</p>
<ul>
<li>减少了每个部分的复杂性（例如，虚拟机不需要担心语法错误）</li>
<li>允许编译常见查询一次，并缓存字节码以提高性能</li>
</ul>
<p>有了这个想法，让我们重构我们的 <code>main</code> 函数，并在此过程中支持两个新关键字：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"> <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
   <span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span> <span class="o">=</span> <span class="n">new_input_buffer</span><span class="p">();</span>
   <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">print_prompt</span><span class="p">();</span>
     <span class="n">read_input</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">);</span>

<span class="o">-</span>    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;.exit&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="o">-</span>      <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
<span class="o">-</span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="o">-</span>      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Unrecognized command &#39;%s&#39;.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
<span class="o">+</span>    <span class="k">if</span> <span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>      <span class="k">switch</span> <span class="p">(</span><span class="n">do_meta_command</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">))</span> <span class="p">{</span>
<span class="o">+</span>        <span class="k">case</span> <span class="p">(</span><span class="n">META_COMMAND_SUCCESS</span><span class="p">)</span><span class="o">:</span>
<span class="o">+</span>          <span class="k">continue</span><span class="p">;</span>
<span class="o">+</span>        <span class="k">case</span> <span class="p">(</span><span class="n">META_COMMAND_UNRECOGNIZED_COMMAND</span><span class="p">)</span><span class="o">:</span>
<span class="o">+</span>          <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Unrecognized command &#39;%s&#39;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
<span class="o">+</span>          <span class="k">continue</span><span class="p">;</span>
<span class="o">+</span>      <span class="p">}</span>
     <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>    <span class="n">Statement</span> <span class="n">statement</span><span class="p">;</span>
<span class="o">+</span>    <span class="k">switch</span> <span class="p">(</span><span class="n">prepare_statement</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">statement</span><span class="p">))</span> <span class="p">{</span>
<span class="o">+</span>      <span class="k">case</span> <span class="p">(</span><span class="n">PREPARE_SUCCESS</span><span class="p">)</span><span class="o">:</span>
<span class="o">+</span>        <span class="k">break</span><span class="p">;</span>
<span class="o">+</span>      <span class="k">case</span> <span class="p">(</span><span class="n">PREPARE_UNRECOGNIZED_STATEMENT</span><span class="p">)</span><span class="o">:</span>
<span class="o">+</span>        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Unrecognized keyword at start of &#39;%s&#39;.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
<span class="o">+</span>               <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
<span class="o">+</span>        <span class="k">continue</span><span class="p">;</span>
<span class="o">+</span>    <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>    <span class="n">execute_statement</span><span class="p">(</span><span class="o">&amp;</span><span class="n">statement</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Executed.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
   <span class="p">}</span>
 <span class="p">}</span>
</code></pre></div><p>像 <code>.exit</code> 这样的非 SQL 语句被称为“元命令”。它们都以点号开头，所以我们检查它们并在一个单独的函数中处理它们。</p>
<p>接下来，我们添加了一个步骤，将输入行转换为我们内部的语句表示形式。这是我们 SQLite 前端的简单版本。</p>
<p>最后，我们将准备好的语句传递给 <code>execute_statement</code>。这个函数最终会成为我们的虚拟机。</p>
<p>两个新函数的返回值都是枚举，表示成功或失败：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="n">META_COMMAND_SUCCESS</span><span class="p">,</span>
  <span class="n">META_COMMAND_UNRECOGNIZED_COMMAND</span>
<span class="p">}</span> <span class="n">MetaCommandResult</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">PREPARE_SUCCESS</span><span class="p">,</span> <span class="n">PREPARE_UNRECOGNIZED_STATEMENT</span> <span class="p">}</span> <span class="n">PrepareResult</span><span class="p">;</span>
</code></pre></div><p>“Unrecognized statement”？这似乎有点像异常。我不太喜欢使用异常（而且C甚至不支持异常），所以我在尽可能的地方使用枚举结果代码。如果我的switch语句没有处理枚举的某个成员，C编译器会报错，所以我们可以更有信心地处理函数的每个结果。预计将来会添加更多的结果代码。</p>
<p><code>do_meta_command</code> 只是现有功能的一个包装器，为更多的命令留出空间：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">MetaCommandResult</span> <span class="nf">do_meta_command</span><span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;.exit&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">META_COMMAND_UNRECOGNIZED_COMMAND</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>我们的“准备语句”现在只包含一个具有两个可能值的枚举。随着我们允许语句中包含参数，它将包含更多数据：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">STATEMENT_INSERT</span><span class="p">,</span> <span class="n">STATEMENT_SELECT</span> <span class="p">}</span> <span class="n">StatementType</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">StatementType</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Statement</span><span class="p">;</span>
</code></pre></div><p><code>prepare_statement</code>（我们的“SQL编译器”）现在不理解SQL。事实上，它只理解两个单词：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">PrepareResult</span> <span class="nf">prepare_statement</span><span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span><span class="p">,</span>
                                <span class="n">Statement</span><span class="o">*</span> <span class="n">statement</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;insert&#34;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">statement</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">STATEMENT_INSERT</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">PREPARE_SUCCESS</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;select&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">statement</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">STATEMENT_SELECT</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">PREPARE_SUCCESS</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">PREPARE_UNRECOGNIZED_STATEMENT</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>请注意，我们对“insert”使用了 <code>strncmp</code>，因为“insert”关键字后面会跟着数据。（例如 <code>insert 1 cstack foo@bar.com</code>）</p>
<p>最后，<code>execute_statement</code> 包含一些存根：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">execute_statement</span><span class="p">(</span><span class="n">Statement</span><span class="o">*</span> <span class="n">statement</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">statement</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="p">(</span><span class="n">STATEMENT_INSERT</span><span class="p">)</span><span class="o">:</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;This is where we would do an insert.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="p">(</span><span class="n">STATEMENT_SELECT</span><span class="p">)</span><span class="o">:</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;This is where we would do a select.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>请注意，它不返回任何错误代码，因为目前还没有可能出错的地方。</p>
<p>通过这些重构，我们现在可以识别两个新的关键字！</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">~ ./db
db &gt; insert foo bar
This is where we would <span class="k">do</span> an insert.
Executed.
db &gt; delete foo
Unrecognized keyword at start of <span class="s1">&#39;delete foo&#39;</span>.
db &gt; <span class="k">select</span>
This is where we would <span class="k">do</span> a <span class="k">select</span>.
Executed.
db &gt; .tables
Unrecognized <span class="nb">command</span> <span class="s1">&#39;.tables&#39;</span>
db &gt; .exit
~
</code></pre></div><p>我们的数据库框架正在成型……如果它能存储数据岂不是更好？在下一部分中，我们将实现 <code>insert</code> 和 <code>select</code>，创建世界上最糟糕的数据存储。在此期间，以下是此部分的整个差异：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="err">@@</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span> <span class="o">+</span><span class="mi">10</span><span class="p">,</span><span class="mi">23</span> <span class="err">@@</span> <span class="k">struct</span> <span class="n">InputBuffer_t</span> <span class="p">{</span>
 <span class="p">}</span> <span class="n">InputBuffer</span><span class="p">;</span>
 
<span class="o">+</span><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
<span class="o">+</span>  <span class="n">META_COMMAND_SUCCESS</span><span class="p">,</span>
<span class="o">+</span>  <span class="n">META_COMMAND_UNRECOGNIZED_COMMAND</span>
<span class="o">+</span><span class="p">}</span> <span class="n">MetaCommandResult</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">PREPARE_SUCCESS</span><span class="p">,</span> <span class="n">PREPARE_UNRECOGNIZED_STATEMENT</span> <span class="p">}</span> <span class="n">PrepareResult</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">STATEMENT_INSERT</span><span class="p">,</span> <span class="n">STATEMENT_SELECT</span> <span class="p">}</span> <span class="n">StatementType</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
<span class="o">+</span>  <span class="n">StatementType</span> <span class="n">type</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span> <span class="n">Statement</span><span class="p">;</span>
<span class="o">+</span>
 <span class="n">InputBuffer</span><span class="o">*</span> <span class="n">new_input_buffer</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">InputBuffer</span><span class="p">));</span>
   <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">40</span><span class="p">,</span><span class="mi">17</span> <span class="o">+</span><span class="mi">57</span><span class="p">,</span><span class="mi">67</span> <span class="err">@@</span> <span class="kt">void</span> <span class="n">close_input_buffer</span><span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">free</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">);</span>
 <span class="p">}</span>
 
<span class="o">+</span><span class="n">MetaCommandResult</span> <span class="n">do_meta_command</span><span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;.exit&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="n">close_input_buffer</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="o">+</span>    <span class="k">return</span> <span class="n">META_COMMAND_UNRECOGNIZED_COMMAND</span><span class="p">;</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span><span class="n">PrepareResult</span> <span class="n">prepare_statement</span><span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span><span class="p">,</span>
<span class="o">+</span>                                <span class="n">Statement</span><span class="o">*</span> <span class="n">statement</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;insert&#34;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="n">statement</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">STATEMENT_INSERT</span><span class="p">;</span>
<span class="o">+</span>    <span class="k">return</span> <span class="n">PREPARE_SUCCESS</span><span class="p">;</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;select&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="n">statement</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">STATEMENT_SELECT</span><span class="p">;</span>
<span class="o">+</span>    <span class="k">return</span> <span class="n">PREPARE_SUCCESS</span><span class="p">;</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="k">return</span> <span class="n">PREPARE_UNRECOGNIZED_STATEMENT</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span><span class="kt">void</span> <span class="n">execute_statement</span><span class="p">(</span><span class="n">Statement</span><span class="o">*</span> <span class="n">statement</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="k">switch</span> <span class="p">(</span><span class="n">statement</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="k">case</span> <span class="p">(</span><span class="n">STATEMENT_INSERT</span><span class="p">)</span><span class="o">:</span>
<span class="o">+</span>      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;This is where we would do an insert.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="o">+</span>      <span class="k">break</span><span class="p">;</span>
<span class="o">+</span>    <span class="k">case</span> <span class="p">(</span><span class="n">STATEMENT_SELECT</span><span class="p">)</span><span class="o">:</span>
<span class="o">+</span>      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;This is where we would do a select.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="o">+</span>      <span class="k">break</span><span class="p">;</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
 <span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
   <span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span> <span class="o">=</span> <span class="n">new_input_buffer</span><span class="p">();</span>
   <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">print_prompt</span><span class="p">();</span>
     <span class="n">read_input</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">);</span>
 
<span class="o">-</span>    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;.exit&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="o">-</span>      <span class="n">close_input_buffer</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">);</span>
<span class="o">-</span>      <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
<span class="o">-</span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="o">-</span>      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Unrecognized command &#39;%s&#39;.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
<span class="o">+</span>    <span class="k">if</span> <span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>      <span class="k">switch</span> <span class="p">(</span><span class="n">do_meta_command</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">))</span> <span class="p">{</span>
<span class="o">+</span>        <span class="k">case</span> <span class="p">(</span><span class="n">META_COMMAND_SUCCESS</span><span class="p">)</span><span class="o">:</span>
<span class="o">+</span>          <span class="k">continue</span><span class="p">;</span>
<span class="o">+</span>        <span class="k">case</span> <span class="p">(</span><span class="n">META_COMMAND_UNRECOGNIZED_COMMAND</span><span class="p">)</span><span class="o">:</span>
<span class="o">+</span>          <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Unrecognized command &#39;%s&#39;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
<span class="o">+</span>          <span class="k">continue</span><span class="p">;</span>
<span class="o">+</span>      <span class="p">}</span>
     <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>    <span class="n">Statement</span> <span class="n">statement</span><span class="p">;</span>
<span class="o">+</span>    <span class="k">switch</span> <span class="p">(</span><span class="n">prepare_statement</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">statement</span><span class="p">))</span> <span class="p">{</span>
<span class="o">+</span>      <span class="k">case</span> <span class="p">(</span><span class="n">PREPARE_SUCCESS</span><span class="p">)</span><span class="o">:</span>
<span class="o">+</span>        <span class="k">break</span><span class="p">;</span>
<span class="o">+</span>      <span class="k">case</span> <span class="p">(</span><span class="n">PREPARE_UNRECOGNIZED_STATEMENT</span><span class="p">)</span><span class="o">:</span>
<span class="o">+</span>        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Unrecognized keyword at start of &#39;%s&#39;.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
<span class="o">+</span>               <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
<span class="o">+</span>        <span class="k">continue</span><span class="p">;</span>
<span class="o">+</span>    <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>    <span class="n">execute_statement</span><span class="p">(</span><span class="o">&amp;</span><span class="n">statement</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Executed.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
   <span class="p">}</span>
 <span class="p">}</span>
</code></pre></div><h2 id="第三部分---内存中追加方式单表数据库">第三部分 - 内存中、追加方式、单表数据库</h2>
<p>我们将通过在数据库上设置许多限制来以小范围开始。暂时，它将会：</p>
<ul>
<li>支持两种操作：插入一行和打印所有行</li>
<li>仅存在于内存中（不会持久化到磁盘）</li>
<li>仅支持一个硬编码的表</li>
</ul>
<p>我们的硬编码表将存储用户信息，结构如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">列名</th>
<th style="text-align:left">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">id</td>
<td style="text-align:left">整数</td>
</tr>
<tr>
<td style="text-align:left">username</td>
<td style="text-align:left">可变长度文本</td>
</tr>
<tr>
<td style="text-align:left">email</td>
<td style="text-align:left">可变长度文本</td>
</tr>
</tbody>
</table>
<p>这是一个简单的模式，但它使我们能够支持多种数据类型和不同大小的文本数据类型。</p>
<p>这部分我们需要修改 <code>prepare_statement</code> 函数来解析参数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;insert&#34;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">statement</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">STATEMENT_INSERT</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">args_assigned</span> <span class="o">=</span> <span class="n">sscanf</span><span class="p">(</span>
    <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;insert %d %s %s&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">statement</span><span class="o">-&gt;</span><span class="n">row_to_insert</span><span class="p">.</span><span class="n">id</span><span class="p">),</span>
    <span class="n">statement</span><span class="o">-&gt;</span><span class="n">row_to_insert</span><span class="p">.</span><span class="n">username</span><span class="p">,</span> <span class="n">statement</span><span class="o">-&gt;</span><span class="n">row_to_insert</span><span class="p">.</span><span class="n">email</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">args_assigned</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">PREPARE_SYNTAX_ERROR</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">PREPARE_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>我们将解析的参数存储到语句对象内的新 <code>Row</code> 数据结构中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define COLUMN_USERNAME_SIZE 32
</span><span class="cp">#define COLUMN_EMAIL_SIZE 255
</span><span class="cp"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="n">id</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">username</span><span class="p">[</span><span class="n">COLUMN_USERNAME_SIZE</span><span class="p">];</span>
  <span class="kt">char</span> <span class="n">email</span><span class="p">[</span><span class="n">COLUMN_EMAIL_SIZE</span><span class="p">];</span>
<span class="p">}</span> <span class="n">Row</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">StatementType</span> <span class="n">type</span><span class="p">;</span>
  <span class="n">Row</span> <span class="n">row_to_insert</span><span class="p">;</span>  <span class="c1">// 仅在插入语句中使用
</span><span class="c1"></span><span class="p">}</span> <span class="n">Statement</span><span class="p">;</span>
</code></pre></div><p>接下来，我们需要将这些数据复制到表示表的某个数据结构中。SQLite 使用 B 树进行快速查找、插入和删除。我们将从简单的结构开始。就像 B 树一样，它将行分组到称为页面的内存块中，但是它们不会像树那样排列，而是像数组那样排列。</p>
<p>我的计划如下：</p>
<ul>
<li>将行存储在称为页面的内存块中</li>
<li>每个页面存储尽可能多的行</li>
<li>行被序列化为与每个页面一起的紧凑表示形式</li>
<li>页面仅在需要时分配</li>
<li>保留一个指向页面的固定大小数组</li>
</ul>
<p>首先，我们来定义行的紧凑表示形式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define size_of_attribute(Struct, Attribute) sizeof(((Struct*)0)-&gt;Attribute)
</span><span class="cp"></span>
<span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">ID_SIZE</span> <span class="o">=</span> <span class="n">size_of_attribute</span><span class="p">(</span><span class="n">Row</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">USERNAME_SIZE</span> <span class="o">=</span> <span class="n">size_of_attribute</span><span class="p">(</span><span class="n">Row</span><span class="p">,</span> <span class="n">username</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">EMAIL_SIZE</span> <span class="o">=</span> <span class="n">size_of_attribute</span><span class="p">(</span><span class="n">Row</span><span class="p">,</span> <span class="n">email</span><span class="p">);</span>
<span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">ID_OFFSET</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">USERNAME_OFFSET</span> <span class="o">=</span> <span class="n">ID_OFFSET</span> <span class="o">+</span> <span class="n">ID_SIZE</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">EMAIL_OFFSET</span> <span class="o">=</span> <span class="n">USERNAME_OFFSET</span> <span class="o">+</span> <span class="n">USERNAME_SIZE</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">ROW_SIZE</span> <span class="o">=</span> <span class="n">ID_SIZE</span> <span class="o">+</span> <span class="n">USERNAME_SIZE</span> <span class="o">+</span> <span class="n">EMAIL_SIZE</span><span class="p">;</span>
</code></pre></div><p>这意味着序列化行的布局将如下所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">列名</th>
<th style="text-align:left">大小（字节）</th>
<th style="text-align:left">偏移量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">id</td>
<td style="text-align:left">4</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">username</td>
<td style="text-align:left">32</td>
<td style="text-align:left">4</td>
</tr>
<tr>
<td style="text-align:left">email</td>
<td style="text-align:left">255</td>
<td style="text-align:left">36</td>
</tr>
<tr>
<td style="text-align:left">总计</td>
<td style="text-align:left">291</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>我们还需要编写代码，将紧凑表示形式转换为原始行数据，以及从原始行数据转换回紧凑表示形式。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">serialize_row</span><span class="p">(</span><span class="n">Row</span><span class="o">*</span> <span class="n">source</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">destination</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">destination</span> <span class="o">+</span> <span class="n">ID_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">source</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">),</span> <span class="n">ID_SIZE</span><span class="p">);</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">destination</span> <span class="o">+</span> <span class="n">USERNAME_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">source</span><span class="o">-&gt;</span><span class="n">username</span><span class="p">),</span> <span class="n">USERNAME_SIZE</span><span class="p">);</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">destination</span> <span class="o">+</span> <span class="n">EMAIL_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">source</span><span class="o">-&gt;</span><span class="n">email</span><span class="p">),</span> <span class="n">EMAIL_SIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">deserialize_row</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">source</span><span class="p">,</span> <span class="n">Row</span><span class="o">*</span> <span class="n">destination</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">destination</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">),</span> <span class="n">source</span> <span class="o">+</span> <span class="n">ID_OFFSET</span><span class="p">,</span> <span class="n">ID_SIZE</span><span class="p">);</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">destination</span><span class="o">-&gt;</span><span class="n">username</span><span class="p">),</span> <span class="n">source</span> <span class="o">+</span> <span class="n">USERNAME_OFFSET</span><span class="p">,</span> <span class="n">USERNAME_SIZE</span><span class="p">);</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">destination</span><span class="o">-&gt;</span><span class="n">email</span><span class="p">),</span> <span class="n">source</span> <span class="o">+</span> <span class="n">EMAIL_OFFSET</span><span class="p">,</span> <span class="n">EMAIL_SIZE</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>接下来是 <code>Table</code> 结构，它指向行的页面并跟踪行的数量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">PAGE_SIZE</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
<span class="cp">#define TABLE_MAX_PAGES 100
</span><span class="cp"></span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">ROWS_PER_PAGE</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="n">ROW_SIZE</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">TABLE_MAX_ROWS</span> <span class="o">=</span> <span class="n">ROWS_PER_PAGE</span> <span class="o">*</span> <span class="n">TABLE_MAX_PAGES</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="n">num_rows</span><span class="p">;</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">pages</span><span class="p">[</span><span class="n">TABLE_MAX_PAGES</span><span class="p">];</span>
<span class="p">}</span> <span class="n">Table</span><span class="p">;</span>
</code></pre></div><p>我将页面大小设置为4千字节，因为它与大多数计算机体系结构的虚拟内存系统中使用的页面大小相同。这意味着数据库中的一个页面对应于操作系统中使用的一个页面。操作系统会整体地将页面移入和移出内存，而不会将其拆分。</p>
<p>我设置了一个最大为100个的页面分配的任意限制。当我们转换为树结构时，我们数据库的最大大小仅受文件的最大大小限制。（尽管我们仍然限制了一次在内存中保留的页面数）</p>
<p>行不应该跨越页面边界。由于页面可能不会相邻存在于内存中，这个假设使得读取/写入行更容易。</p>
<p>至于在内存中为特定行读取/写入的位置，我们可以这样计算：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span><span class="o">*</span> <span class="nf">row_slot</span><span class="p">(</span><span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">row_num</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="n">page_num</span> <span class="o">=</span> <span class="n">row_num</span> <span class="o">/</span> <span class="n">ROWS_PER_PAGE</span><span class="p">;</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">page</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 仅在访问页面时分配内存
</span><span class="c1"></span>    <span class="n">page</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kt">uint32_t</span> <span class="n">row_offset</span> <span class="o">=</span> <span class="n">row_num</span> <span class="o">%</span> <span class="n">ROWS_PER</span>

<span class="n">_PAGE</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">byte_offset</span> <span class="o">=</span> <span class="n">row_offset</span> <span class="o">*</span> <span class="n">ROW_SIZE</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">page</span> <span class="o">+</span> <span class="n">byte_offset</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>现在我们可以修改 <code>execute_statement</code> 从我们的表结构中读写数据：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">ExecuteResult</span> <span class="nf">execute_insert</span><span class="p">(</span><span class="n">Statement</span><span class="o">*</span> <span class="n">statement</span><span class="p">,</span> <span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">&gt;=</span> <span class="n">TABLE_MAX_ROWS</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">EXECUTE_TABLE_FULL</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Row</span><span class="o">*</span> <span class="n">row_to_insert</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">statement</span><span class="o">-&gt;</span><span class="n">row_to_insert</span><span class="p">);</span>

  <span class="n">serialize_row</span><span class="p">(</span><span class="n">row_to_insert</span><span class="p">,</span> <span class="n">row_slot</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span><span class="p">));</span>
  <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">EXECUTE_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">ExecuteResult</span> <span class="nf">execute_select</span><span class="p">(</span><span class="n">Statement</span><span class="o">*</span> <span class="n">statement</span><span class="p">,</span> <span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Row</span> <span class="n">row</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">deserialize_row</span><span class="p">(</span><span class="n">row_slot</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">row</span><span class="p">);</span>
    <span class="n">print_row</span><span class="p">(</span><span class="o">&amp;</span><span class="n">row</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">EXECUTE_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">ExecuteResult</span> <span class="nf">execute_statement</span><span class="p">(</span><span class="n">Statement</span><span class="o">*</span> <span class="n">statement</span><span class="p">,</span> <span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">statement</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="p">(</span><span class="n">STATEMENT_INSERT</span><span class="p">)</span><span class="o">:</span>
      <span class="k">return</span> <span class="n">execute_insert</span><span class="p">(</span><span class="n">statement</span><span class="p">,</span> <span class="n">table</span><span class="p">);</span>
    <span class="k">case</span> <span class="p">(</span><span class="n">STATEMENT_SELECT</span><span class="p">)</span><span class="o">:</span>
      <span class="k">return</span> <span class="n">execute_select</span><span class="p">(</span><span class="n">statement</span><span class="p">,</span> <span class="n">table</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>最后，我们需要初始化表，创建相应的内存释放函数，并处理一些其他错误情况：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">Table</span><span class="o">*</span> <span class="nf">new_table</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Table</span><span class="o">*</span> <span class="n">table</span> <span class="o">=</span> <span class="p">(</span><span class="n">Table</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Table</span><span class="p">));</span>
  <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TABLE_MAX_PAGES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">table</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">table</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_table</span><span class="p">(</span><span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">free</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="n">free</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="n">Table</span><span class="o">*</span> <span class="n">table</span> <span class="o">=</span> <span class="n">new_table</span><span class="p">();</span>
  <span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span> <span class="o">=</span> <span class="n">new_input_buffer</span><span class="p">();</span>
  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print_prompt</span><span class="p">();</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="k">switch</span> <span class="p">(</span><span class="n">prepare_statement</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">statement</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">case</span> <span class="p">(</span><span class="n">PREPARE_SUCCESS</span><span class="p">)</span><span class="o">:</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="p">(</span><span class="n">PREPARE_SYNTAX_ERROR</span><span class="p">)</span><span class="o">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Syntax error. Could not parse statement.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="k">case</span> <span class="p">(</span><span class="n">PREPARE_UNRECOGNIZED_STATEMENT</span><span class="p">)</span><span class="o">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Unrecognized keyword at start of &#39;%s&#39;.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
               <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">execute_statement</span><span class="p">(</span><span class="o">&amp;</span><span class="n">statement</span><span class="p">,</span> <span class="n">table</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">case</span> <span class="p">(</span><span class="n">EXECUTE_SUCCESS</span><span class="p">)</span><span class="o">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Executed.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="p">(</span><span class="n">EXECUTE_TABLE_FULL</span><span class="p">)</span><span class="o">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error: Table full.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这些修改后，我们可以实际在数据库中保存数据了！</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="o">~</span><span class="w"> </span><span class="p">.</span><span class="o">/</span><span class="n">db</span><span class="w">
</span><span class="w"></span><span class="n">db</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="k">insert</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">cstack</span><span class="w"> </span><span class="n">foo</span><span class="o">@</span><span class="n">bar</span><span class="p">.</span><span class="n">com</span><span class="w">
</span><span class="w"></span><span class="n">Executed</span><span class="p">.</span><span class="w">
</span><span class="w"></span><span class="n">db</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="k">insert</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">bob</span><span class="w"> </span><span class="n">bob</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="w">
</span><span class="w"></span><span class="n">Executed</span><span class="p">.</span><span class="w">
</span><span class="w"></span><span class="n">db</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="k">select</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">cstack</span><span class="p">,</span><span class="w"> </span><span class="n">foo</span><span class="o">@</span><span class="n">bar</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">bob</span><span class="p">,</span><span class="w"> </span><span class="n">bob</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="n">Executed</span><span class="p">.</span><span class="w">
</span><span class="w"></span><span class="n">db</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="k">insert</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="w"></span><span class="n">Syntax</span><span class="w"> </span><span class="n">error</span><span class="p">.</span><span class="w"> </span><span class="n">Could</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="n">parse</span><span class="w"> </span><span class="k">statement</span><span class="p">.</span><span class="w">
</span><span class="w"></span><span class="n">db</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">.</span><span class="n">exit</span><span class="w">
</span></code></pre></div><p>现在是写一些测试的好时机，有几个原因：</p>
<ul>
<li>我们打算大幅改变存储表的数据结构，测试可以捕捉到回归问题。</li>
<li>还有一些边缘案例我们尚未手动测试（例如，填满表）</li>
</ul>
<p>我们将在下一部分解决这些问题。现在，这是本部分的全部修改内容。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="err">@@</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span> <span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span> <span class="err">@@</span>
 <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span> <span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp"></span> <span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="o">+</span><span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">stdint</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>

 <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
   <span class="kt">char</span><span class="o">*</span> <span class="n">buffer</span><span class="p">;</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span> <span class="o">+</span><span class="mi">11</span><span class="p">,</span><span class="mi">105</span> <span class="err">@@</span> <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
 <span class="p">}</span> <span class="n">InputBuffer</span><span class="p">;</span>

<span class="o">+</span><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">EXECUTE_SUCCESS</span><span class="p">,</span> <span class="n">EXECUTE_TABLE_FULL</span> <span class="p">}</span> <span class="n">ExecuteResult</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
<span class="o">+</span>  <span class="n">META_COMMAND_SUCCESS</span><span class="p">,</span>
<span class="o">+</span>  <span class="n">META_COMMAND_UNRECOGNIZED_COMMAND</span>
<span class="o">+</span><span class="p">}</span> <span class="n">MetaCommandResult</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
<span class="o">+</span>  <span class="n">PREPARE_SUCCESS</span><span class="p">,</span>
<span class="o">+</span>  <span class="n">PREPARE_SYNTAX_ERROR</span><span class="p">,</span>
<span class="o">+</span>  <span class="n">PREPARE_UNRECOGNIZED_STATEMENT</span>
<span class="o">+</span> <span class="p">}</span> <span class="n">PrepareResult</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">STATEMENT_INSERT</span><span class="p">,</span> <span class="n">STATEMENT_SELECT</span> <span class="p">}</span> <span class="n">StatementType</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span><span class="err">#</span><span class="n">define</span> <span class="n">COLUMN_USERNAME_SIZE</span> <span class="mi">32</span>
<span class="o">+</span><span class="err">#</span><span class="n">define</span> <span class="n">COLUMN_EMAIL_SIZE</span> <span class="mi">255</span>
<span class="o">+</span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">id</span><span class="p">;</span>
<span class="o">+</span>  <span class="kt">char</span> <span class="n">username</span><span class="p">[</span><span class="n">COLUMN_USERNAME_SIZE</span><span class="p">];</span>
<span class="o">+</span>  <span class="kt">char</span> <span class="n">email</span><span class="p">[</span><span class="n">COLUMN_EMAIL_SIZE</span><span class="p">];</span>
<span class="o">+</span><span class="p">}</span> <span class="n">Row</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
<span class="o">+</span>  <span class="n">StatementType</span> <span class="n">type</span><span class="p">;</span>
<span class="o">+</span>  <span class="n">Row</span> <span class="n">row_to_insert</span><span class="p">;</span> <span class="c1">//only used by insert statement
</span><span class="c1"></span><span class="o">+</span><span class="p">}</span> <span class="n">Statement</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span><span class="err">#</span><span class="n">define</span> <span class="n">size_of_attribute</span><span class="p">(</span><span class="n">Struct</span><span class="p">,</span> <span class="n">Attribute</span><span class="p">)</span> <span class="k">sizeof</span><span class="p">(((</span><span class="n">Struct</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Attribute</span><span class="p">)</span>
<span class="o">+</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">ID_SIZE</span> <span class="o">=</span> <span class="n">size_of_attribute</span><span class="p">(</span><span class="n">Row</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">USERNAME_SIZE</span> <span class="o">=</span> <span class="n">size_of_attribute</span><span class="p">(</span><span class="n">Row</span><span class="p">,</span> <span class="n">username</span><span class="p">);</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">EMAIL_SIZE</span> <span class="o">=</span> <span class="n">size_of_attribute</span><span class="p">(</span><span class="n">Row</span><span class="p">,</span> <span class="n">email</span><span class="p">);</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">ID_OFFSET</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">USERNAME_OFFSET</span> <span class="o">=</span> <span class="n">ID_OFFSET</span> <span class="o">+</span> <span class="n">ID_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">EMAIL_OFFSET</span> <span class="o">=</span> <span class="n">USERNAME_OFFSET</span> <span class="o">+</span> <span class="n">USERNAME_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">ROW_SIZE</span> <span class="o">=</span> <span class="n">ID_SIZE</span> <span class="o">+</span> <span class="n">USERNAME_SIZE</span> <span class="o">+</span> <span class="n">EMAIL_SIZE</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">PAGE_SIZE</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
<span class="o">+</span><span class="err">#</span><span class="n">define</span> <span class="n">TABLE_MAX_PAGES</span> <span class="mi">100</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">ROWS_PER_PAGE</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="n">ROW_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">TABLE_MAX_ROWS</span> <span class="o">=</span> <span class="n">ROWS_PER_PAGE</span> <span class="o">*</span> <span class="n">TABLE_MAX_PAGES</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">num_rows</span><span class="p">;</span>
<span class="o">+</span>  <span class="kt">void</span><span class="o">*</span> <span class="n">pages</span><span class="p">[</span><span class="n">TABLE_MAX_PAGES</span><span class="p">];</span>
<span class="o">+</span><span class="p">}</span> <span class="n">Table</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span><span class="kt">void</span> <span class="n">print_row</span><span class="p">(</span><span class="n">Row</span><span class="o">*</span> <span class="n">row</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;(%d, %s, %s)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">row</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">row</span><span class="o">-&gt;</span><span class="n">username</span><span class="p">,</span> <span class="n">row</span><span class="o">-&gt;</span><span class="n">email</span><span class="p">);</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span><span class="kt">void</span> <span class="n">serialize_row</span><span class="p">(</span><span class="n">Row</span><span class="o">*</span> <span class="n">source</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">destination</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="n">memcpy</span><span class="p">(</span><span class="n">destination</span> <span class="o">+</span> <span class="n">ID_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">source</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">),</span> <span class="n">ID_SIZE</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">memcpy</span><span class="p">(</span><span class="n">destination</span> <span class="o">+</span> <span class="n">USERNAME_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">source</span><span class="o">-&gt;</span><span class="n">username</span><span class="p">),</span> <span class="n">USERNAME_SIZE</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">memcpy</span><span class="p">(</span><span class="n">destination</span> <span class="o">+</span> <span class="n">EMAIL_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">source</span><span class="o">-&gt;</span><span class="n">email</span><span class="p">),</span> <span class="n">EMAIL_SIZE</span><span class="p">);</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span><span class="kt">void</span> <span class="n">deserialize_row</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">source</span><span class="p">,</span> <span class="n">Row</span><span class="o">*</span> <span class="n">destination</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">destination</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">),</span> <span class="n">source</span> <span class="o">+</span> <span class="n">ID_OFFSET</span><span class="p">,</span> <span class="n">ID_SIZE</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">destination</span><span class="o">-&gt;</span><span class="n">username</span><span class="p">),</span> <span class="n">source</span> <span class="o">+</span> <span class="n">USERNAME_OFFSET</span><span class="p">,</span> <span class="n">USERNAME_SIZE</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">destination</span><span class="o">-&gt;</span><span class="n">email</span><span class="p">),</span> <span class="n">source</span> <span class="o">+</span> <span class="n">EMAIL_OFFSET</span><span class="p">,</span> <span class="n">EMAIL_SIZE</span><span class="p">);</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span><span class="kt">void</span><span class="o">*</span> <span class="n">row_slot</span><span class="p">(</span><span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">row_num</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">page_num</span> <span class="o">=</span> <span class="n">row_num</span> <span class="o">/</span> <span class="n">ROWS_PER_PAGE</span><span class="p">;</span>
<span class="o">+</span>  <span class="kt">void</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">];</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>     <span class="c1">// Allocate memory only when we try to access page
</span><span class="c1"></span><span class="o">+</span>     <span class="n">page</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">row_offset</span> <span class="o">=</span> <span class="n">row_num</span> <span class="o">%</span> <span class="n">ROWS_PER_PAGE</span><span class="p">;</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">byte_offset</span> <span class="o">=</span> <span class="n">row_offset</span> <span class="o">*</span> <span class="n">ROW_SIZE</span><span class="p">;</span>
<span class="o">+</span>  <span class="k">return</span> <span class="n">page</span> <span class="o">+</span> <span class="n">byte_offset</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span><span class="n">Table</span><span class="o">*</span> <span class="n">new_table</span><span class="p">()</span> <span class="p">{</span>
<span class="o">+</span>  <span class="n">Table</span><span class="o">*</span> <span class="n">table</span> <span class="o">=</span> <span class="p">(</span><span class="n">Table</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Table</span><span class="p">));</span>
<span class="o">+</span>  <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">+</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TABLE_MAX_PAGES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>     <span class="n">table</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>  <span class="k">return</span> <span class="n">table</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span><span class="kt">void</span> <span class="n">free_table</span><span class="p">(</span><span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>     <span class="n">free</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>  <span class="n">free</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
 <span class="n">InputBuffer</span><span class="o">*</span> <span class="n">new_input_buffer</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">InputBuffer</span><span class="p">));</span>
   <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">40</span><span class="p">,</span><span class="mi">17</span> <span class="o">+</span><span class="mi">140</span><span class="p">,</span><span class="mi">105</span> <span class="err">@@</span> <span class="kt">void</span> <span class="n">close_input_buffer</span><span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">free</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">);</span>
 <span class="p">}</span>

<span class="o">+</span><span class="n">MetaCommandResult</span> <span class="n">do_meta_command</span><span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span><span class="p">,</span> <span class="n">Table</span> <span class="o">*</span><span class="n">table</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;.exit&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="n">close_input_buffer</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">free_table</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="o">+</span>    <span class="k">return</span> <span class="n">META_COMMAND_UNRECOGNIZED_COMMAND</span><span class="p">;</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span><span class="n">PrepareResult</span> <span class="n">prepare_statement</span><span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span><span class="p">,</span>
<span class="o">+</span>                                <span class="n">Statement</span><span class="o">*</span> <span class="n">statement</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;insert&#34;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="n">statement</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">STATEMENT_INSERT</span><span class="p">;</span>
<span class="o">+</span>    <span class="kt">int</span> <span class="n">args_assigned</span> <span class="o">=</span> <span class="n">sscanf</span><span class="p">(</span>
<span class="o">+</span>	<span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;insert %d %s %s&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">statement</span><span class="o">-&gt;</span><span class="n">row_to_insert</span><span class="p">.</span><span class="n">id</span><span class="p">),</span>
<span class="o">+</span>	<span class="n">statement</span><span class="o">-&gt;</span><span class="n">row_to_insert</span><span class="p">.</span><span class="n">username</span><span class="p">,</span> <span class="n">statement</span><span class="o">-&gt;</span><span class="n">row_to_insert</span><span class="p">.</span><span class="n">email</span>
<span class="o">+</span>	<span class="p">);</span>
<span class="o">+</span>    <span class="k">if</span> <span class="p">(</span><span class="n">args_assigned</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>	<span class="k">return</span> <span class="n">PREPARE_SYNTAX_ERROR</span><span class="p">;</span>
<span class="o">+</span>    <span class="p">}</span>
<span class="o">+</span>    <span class="k">return</span> <span class="n">PREPARE_SUCCESS</span><span class="p">;</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;select&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="n">statement</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">STATEMENT_SELECT</span><span class="p">;</span>
<span class="o">+</span>    <span class="k">return</span> <span class="n">PREPARE_SUCCESS</span><span class="p">;</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="k">return</span> <span class="n">PREPARE_UNRECOGNIZED_STATEMENT</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span><span class="n">ExecuteResult</span> <span class="n">execute_insert</span><span class="p">(</span><span class="n">Statement</span><span class="o">*</span> <span class="n">statement</span><span class="p">,</span> <span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">&gt;=</span> <span class="n">TABLE_MAX_ROWS</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>     <span class="k">return</span> <span class="n">EXECUTE_TABLE_FULL</span><span class="p">;</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="n">Row</span><span class="o">*</span> <span class="n">row_to_insert</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">statement</span><span class="o">-&gt;</span><span class="n">row_to_insert</span><span class="p">);</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="n">serialize_row</span><span class="p">(</span><span class="n">row_to_insert</span><span class="p">,</span> <span class="n">row_slot</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span><span class="p">));</span>
<span class="o">+</span>  <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="k">return</span> <span class="n">EXECUTE_SUCCESS</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span><span class="n">ExecuteResult</span> <span class="n">execute_select</span><span class="p">(</span><span class="n">Statement</span><span class="o">*</span> <span class="n">statement</span><span class="p">,</span> <span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="n">Row</span> <span class="n">row</span><span class="p">;</span>
<span class="o">+</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>     <span class="n">deserialize_row</span><span class="p">(</span><span class="n">row_slot</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">row</span><span class="p">);</span>
<span class="o">+</span>     <span class="n">print_row</span><span class="p">(</span><span class="o">&amp;</span><span class="n">row</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>  <span class="k">return</span> <span class="n">EXECUTE_SUCCESS</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span><span class="n">ExecuteResult</span> <span class="n">execute_statement</span><span class="p">(</span><span class="n">Statement</span><span class="o">*</span> <span class="n">statement</span><span class="p">,</span> <span class="n">Table</span> <span class="o">*</span><span class="n">table</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="k">switch</span> <span class="p">(</span><span class="n">statement</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="k">case</span> <span class="p">(</span><span class="n">STATEMENT_INSERT</span><span class="p">)</span><span class="o">:</span>
<span class="o">+</span>       	<span class="k">return</span> <span class="n">execute_insert</span><span class="p">(</span><span class="n">statement</span><span class="p">,</span> <span class="n">table</span><span class="p">);</span>
<span class="o">+</span>    <span class="k">case</span> <span class="p">(</span><span class="n">STATEMENT_SELECT</span><span class="p">)</span><span class="o">:</span>
<span class="o">+</span>	<span class="k">return</span> <span class="n">execute_select</span><span class="p">(</span><span class="n">statement</span><span class="p">,</span> <span class="n">table</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
 <span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
<span class="o">+</span>  <span class="n">Table</span><span class="o">*</span> <span class="n">table</span> <span class="o">=</span> <span class="n">new_table</span><span class="p">();</span>
   <span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span> <span class="o">=</span> <span class="n">new_input_buffer</span><span class="p">();</span>
   <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">print_prompt</span><span class="p">();</span>
     <span class="n">read_input</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">);</span>

<span class="o">-</span>    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;.exit&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="o">-</span>      <span class="n">close_input_buffer</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">);</span>
<span class="o">-</span>      <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
<span class="o">-</span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="o">-</span>      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Unrecognized command &#39;%s&#39;.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
<span class="o">+</span>    <span class="k">if</span> <span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>      <span class="k">switch</span> <span class="p">(</span><span class="n">do_meta_command</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">,</span> <span class="n">table</span><span class="p">))</span> <span class="p">{</span>
<span class="o">+</span>        <span class="k">case</span> <span class="p">(</span><span class="n">META_COMMAND_SUCCESS</span><span class="p">)</span><span class="o">:</span>
<span class="o">+</span>          <span class="k">continue</span><span class="p">;</span>
<span class="o">+</span>        <span class="k">case</span> <span class="p">(</span><span class="n">META_COMMAND_UNRECOGNIZED_COMMAND</span><span class="p">)</span><span class="o">:</span>
<span class="o">+</span>          <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Unrecognized command &#39;%s&#39;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
<span class="o">+</span>          <span class="k">continue</span><span class="p">;</span>
<span class="o">+</span>      <span class="p">}</span>
<span class="o">+</span>    <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>    <span class="n">Statement</span> <span class="n">statement</span><span class="p">;</span>
<span class="o">+</span>    <span class="k">switch</span> <span class="p">(</span><span class="n">prepare_statement</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">statement</span><span class="p">))</span> <span class="p">{</span>
<span class="o">+</span>      <span class="k">case</span> <span class="p">(</span><span class="n">PREPARE_SUCCESS</span><span class="p">)</span><span class="o">:</span>
<span class="o">+</span>        <span class="k">break</span><span class="p">;</span>
<span class="o">+</span>      <span class="k">case</span> <span class="p">(</span><span class="n">PREPARE_SYNTAX_ERROR</span><span class="p">)</span><span class="o">:</span>
<span class="o">+</span>	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Syntax error. Could not parse statement.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="o">+</span>	<span class="k">continue</span><span class="p">;</span>
<span class="o">+</span>      <span class="k">case</span> <span class="p">(</span><span class="n">PREPARE_UNRECOGNIZED_STATEMENT</span><span class="p">)</span><span class="o">:</span>
<span class="o">+</span>        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Unrecognized keyword at start of &#39;%s&#39;.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
<span class="o">+</span>               <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
<span class="o">+</span>        <span class="k">continue</span><span class="p">;</span>
<span class="o">+</span>    <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>    <span class="k">switch</span> <span class="p">(</span><span class="n">execute_statement</span><span class="p">(</span><span class="o">&amp;</span><span class="n">statement</span><span class="p">,</span> <span class="n">table</span><span class="p">))</span> <span class="p">{</span>
<span class="o">+</span>	<span class="k">case</span> <span class="p">(</span><span class="n">EXECUTE_SUCCESS</span><span class="p">)</span><span class="o">:</span>
<span class="o">+</span>	    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Executed.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="o">+</span>	    <span class="k">break</span><span class="p">;</span>
<span class="o">+</span>	<span class="k">case</span> <span class="p">(</span><span class="n">EXECUTE_TABLE_FULL</span><span class="p">)</span><span class="o">:</span>
<span class="o">+</span>	    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error: Table full.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="o">+</span>	    <span class="k">break</span><span class="p">;</span>
     <span class="p">}</span>
   <span class="p">}</span>
 <span class="p">}</span>
</code></pre></div><h2 id="第四部分---我们的第一个测试bug">第四部分 - 我们的第一个测试（Bug）</h2>
<p>我们已经能够向数据库中插入行并打印所有行了。让我们花点时间来测试我们到目前为止做得怎么样。</p>
<p>我将使用 <a href="http://rspec.info/">rspec</a> 来编写我的测试，因为我对它比较熟悉，而且语法相对易读。</p>
<p>我将定义一个简短的辅助函数来向我们的数据库程序发送一系列命令，然后对输出进行断言：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ruby" data-lang="ruby"><span class="n">describe</span> <span class="s1">&#39;database&#39;</span> <span class="k">do</span>
  <span class="k">def</span> <span class="nf">run_script</span><span class="p">(</span><span class="n">commands</span><span class="p">)</span>
    <span class="n">raw_output</span> <span class="o">=</span> <span class="kp">nil</span>
    <span class="no">IO</span><span class="o">.</span><span class="n">popen</span><span class="p">(</span><span class="s2">&#34;./db&#34;</span><span class="p">,</span> <span class="s2">&#34;r+&#34;</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">pipe</span><span class="o">|</span>
      <span class="n">commands</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">command</span><span class="o">|</span>
        <span class="n">pipe</span><span class="o">.</span><span class="n">puts</span> <span class="n">command</span>
      <span class="k">end</span>

      <span class="n">pipe</span><span class="o">.</span><span class="n">close_write</span>

      <span class="c1"># Read entire output</span>
      <span class="n">raw_output</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">.</span><span class="n">gets</span><span class="p">(</span><span class="kp">nil</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="n">raw_output</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&#34;</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">it</span> <span class="s1">&#39;inserts and retrieves a row&#39;</span> <span class="k">do</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">run_script</span><span class="p">(</span><span class="o">[</span>
      <span class="s2">&#34;insert 1 user1 person1@example.com&#34;</span><span class="p">,</span>
      <span class="s2">&#34;select&#34;</span><span class="p">,</span>
      <span class="s2">&#34;.exit&#34;</span><span class="p">,</span>
    <span class="o">]</span><span class="p">)</span>
    <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">match_array</span><span class="p">(</span><span class="o">[</span>
      <span class="s2">&#34;db &gt; Executed.&#34;</span><span class="p">,</span>
      <span class="s2">&#34;db &gt; (1, user1, person1@example.com)&#34;</span><span class="p">,</span>
      <span class="s2">&#34;Executed.&#34;</span><span class="p">,</span>
      <span class="s2">&#34;db &gt; &#34;</span><span class="p">,</span>
    <span class="o">]</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div><p>这个简单的测试确保我们得到了我们放入的内容。而且确实通过了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">bundle <span class="nb">exec</span> rspec
.

Finished in 0.00871 seconds <span class="o">(</span>files took 0.09506 seconds to load<span class="o">)</span>
<span class="m">1</span> example, <span class="m">0</span> failures
</code></pre></div><p>现在可以测试向数据库插入大量行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ruby" data-lang="ruby"><span class="n">it</span> <span class="s1">&#39;prints error message when table is full&#39;</span> <span class="k">do</span>
  <span class="n">script</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">1401</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
    <span class="s2">&#34;insert </span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2"> user</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2"> person</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">@example.com&#34;</span>
  <span class="k">end</span>
  <span class="n">script</span> <span class="o">&lt;&lt;</span> <span class="s2">&#34;.exit&#34;</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">run_script</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
  <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="o">[-</span><span class="mi">2</span><span class="o">]</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">eq</span><span class="p">(</span><span class="s1">&#39;db &gt; Error: Table full.&#39;</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div><p>再次运行测试…</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">bundle <span class="nb">exec</span> rspec
..

Finished in 0.01553 seconds <span class="o">(</span>files took 0.08156 seconds to load<span class="o">)</span>
<span class="m">2</span> examples, <span class="m">0</span> failures
</code></pre></div><p>太棒了，成功了！我们的数据库现在可以容纳1400行，因为我们将最大页面数设置为100，并且一页可以容纳14行。</p>
<p>我们可能没有正确处理存储文本字段。可以通过以下示例轻松进行测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ruby" data-lang="ruby"><span class="n">it</span> <span class="s1">&#39;allows inserting strings that are the maximum length&#39;</span> <span class="k">do</span>
  <span class="n">long_username</span> <span class="o">=</span> <span class="s2">&#34;a&#34;</span><span class="o">*</span><span class="mi">32</span>
  <span class="n">long_email</span> <span class="o">=</span> <span class="s2">&#34;a&#34;</span><span class="o">*</span><span class="mi">255</span>
  <span class="n">script</span> <span class="o">=</span> <span class="o">[</span>
    <span class="s2">&#34;insert 1 </span><span class="si">#{</span><span class="n">long_username</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">long_email</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">,</span>
    <span class="s2">&#34;select&#34;</span><span class="p">,</span>
    <span class="s2">&#34;.exit&#34;</span><span class="p">,</span>
  <span class="o">]</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">run_script</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
  <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">match_array</span><span class="p">(</span><span class="o">[</span>
    <span class="s2">&#34;db &gt; Executed.&#34;</span><span class="p">,</span>
    <span class="s2">&#34;db &gt; (1, </span><span class="si">#{</span><span class="n">long_username</span><span class="si">}</span><span class="s2">, </span><span class="si">#{</span><span class="n">long_email</span><span class="si">}</span><span class="s2">)&#34;</span><span class="p">,</span>
    <span class="s2">&#34;Executed.&#34;</span><span class="p">,</span>
    <span class="s2">&#34;db &gt; &#34;</span><span class="p">,</span>
  <span class="o">]</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div><p>测试失败了！</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">Failures:

  1<span class="o">)</span> database allows inserting strings that are the maximum length
     Failure/Error: raw_output.split<span class="o">(</span><span class="s2">&#34;\n&#34;</span><span class="o">)</span>

     ArgumentError:
       invalid byte sequence in UTF-8
     <span class="c1"># ./spec/main_spec.rb:14:in `split&#39;</span>
     <span class="c1"># ./spec/main_spec.rb:14:in `run_script&#39;</span>
     <span class="c1"># ./spec/main_spec.rb:48:in `block (2 levels) in &lt;top (required)&gt;&#39;</span>
</code></pre></div><p>我们试着自己测试一下，会发现在尝试打印出行时出现了一些奇怪的字符。（我缩写了长字符串）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">db &gt; insert <span class="m">1</span> aaaaa... aaaaa...
Executed.
db &gt; <span class="k">select</span>
<span class="o">(</span>1, aaaaa...aaa<span class="se">\�</span>, aaaaa...aaa<span class="se">\�</span><span class="o">)</span>
Executed.
db &gt;
</code></pre></div><p>发生了什么？如果您查看我们对“Row”的定义，我们为用户名准确分配了32字节，为电子邮件准确分配了255字节。但是，<a href="http://www.cprogramming.com/tutorial/c/lesson9.html">C字符串</a>应该以空字符结尾，而我们没有为其分配空间。解决方法是多分配一个字节：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"> <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">COLUMN_EMAIL_SIZE</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
 <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
   <span class="kt">uint32_t</span> <span class="n">id</span><span class="p">;</span>
<span class="o">-</span>  <span class="kt">char</span> <span class="n">username</span><span class="p">[</span><span class="n">COLUMN_USERNAME_SIZE</span><span class="p">];</span>
<span class="o">-</span>  <span class="kt">char</span> <span class="n">email</span><span class="p">[</span><span class="n">COLUMN_EMAIL_SIZE</span><span class="p">];</span>
<span class="o">+</span>  <span class="kt">char</span> <span class="n">username</span><span class="p">[</span><span class="n">COLUMN_USERNAME_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="o">+</span>  <span class="kt">char</span> <span class="n">email</span><span class="p">[</span><span class="n">COLUMN_EMAIL_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
 <span class="p">}</span> <span class="n">Row</span><span class="p">;</span>
</code></pre></div><p>确实解决了问题：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"> bundle <span class="nb">exec</span> rspec
...

Finished in 0.0188 seconds <span class="o">(</span>files took 0.08516 seconds to load<span class="o">)</span>
<span class="m">3</span> examples, <span class="m">0</span> failures
</code></pre></div><p>我们不应该允许插入长度超过列大小的用户名或电子邮件。对此的规范如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ruby" data-lang="ruby"><span class="n">it</span> <span class="s1">&#39;prints error message if strings are too long&#39;</span> <span class="k">do</span>
  <span class="n">long_username</span> <span class="o">=</span> <span class="s2">&#34;a&#34;</span><span class="o">*</span><span class="mi">33</span>
  <span class="n">long_email</span> <span class="o">=</span> <span class="s2">&#34;a&#34;</span><span class="o">*</span><span class="mi">256</span>
  <span class="n">script</span> <span class="o">=</span> <span class="o">[</span>
    <span class="s2">&#34;insert 1 </span><span class="si">#{</span><span class="n">long_username</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">long_email</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">,</span>
    <span class="s2">&#34;select&#34;</span><span class="p">,</span>
    <span class="s2">&#34;.exit&#34;</span><span class="p">,</span>
  <span class="o">]</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">run_script</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
  <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">match_array</span><span class="p">(</span><span class="o">[</span>
    <span class="s2">&#34;db &gt; String is too long.&#34;</span><span class="p">,</span>
    <span class="s2">&#34;db &gt; Executed.&#34;</span><span class="p">,</span>
    <span class="s2">&#34;db &gt; &#34;</span><span class="p">,</span>
  <span class="o">]</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div><p>为了做到这一点，我们需要升级我们的解析器。提醒一下，我们目前正在使用<a href="https://linux.die.net/man/3/scanf">scanf()</a>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;insert&#34;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">statement</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">STATEMENT_INSERT</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">args_assigned</span> <span class="o">=</span> <span class="n">sscanf</span><span class="p">(</span>
      <span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;insert %d %s %s&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">statement</span><span class="o">-&gt;</span><span class="n">row_to_insert</span><span class="p">.</span><span class="n">id</span><span class="p">),</span>
      <span class="n">statement</span><span class="o">-&gt;</span><span class="n">row_to_insert</span><span class="p">.</span><span class="n">username</span><span class="p">,</span> <span class="n">statement</span><span class="o">-&gt;</span><span class="n">row_to_insert</span><span class="p">.</span><span class="n">email</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">args_assigned</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">PREPARE_SYNTAX_ERROR</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">PREPARE_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>但是<a href="https://stackoverflow.com/questions/2430303/disadvantages-of-scanf">scanf存在一些缺点</a>。如果它读取的字符串大于其读入的缓冲区，它将导致缓冲区溢出，并开始向意外位置写入。我们希望在将其复制到<code>Row</code>结构之前检查每个字符串的长度。为了做到这一点，我们需要通过空格对输入进行划分。</p>
<p>我将使用<a href="http://www.cplusplus.com/reference/cstring/strtok/">strtok()</a>来完成这个过程。如果您亲眼目睹它的运行，可能更容易理解：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span><span class="n">PrepareResult</span> <span class="n">prepare_insert</span><span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span><span class="p">,</span> <span class="n">Statement</span><span class="o">*</span> <span class="n">statement</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="n">statement</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">STATEMENT_INSERT</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="kt">char</span><span class="o">*</span> <span class="n">keyword</span> <span class="o">=</span> <span class="n">strtok</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">);</span>
<span class="o">+</span>  <span class="kt">char</span><span class="o">*</span> <span class="n">id_string</span> <span class="o">=</span> <span class="n">strtok</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">);</span>
<span class="o">+</span>  <span class="kt">char</span><span class="o">*</span> <span class="n">username</span> <span class="o">=</span> <span class="n">strtok</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">);</span>
<span class="o">+</span>  <span class="kt">char</span><span class="o">*</span> <span class="n">email</span> <span class="o">=</span> <span class="n">strtok</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">);</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">id_string</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">username</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">email</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="k">return</span> <span class="n">PREPARE_SYNTAX_ERROR</span><span class="p">;</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">id_string</span><span class="p">);</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">username</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">COLUMN_USERNAME_SIZE</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="k">return</span> <span class="n">PREPARE_STRING_TOO_LONG</span><span class="p">;</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">email</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">COLUMN_EMAIL_SIZE</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="k">return</span> <span class="n">PREPARE_STRING_TOO_LONG</span><span class="p">;</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="n">statement</span><span class="o">-&gt;</span><span class="n">row_to_insert</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
<span class="o">+</span>  <span class="n">strcpy</span><span class="p">(</span><span class="n">statement</span><span class="o">-&gt;</span><span class="n">row_to_insert</span><span class="p">.</span><span class="n">username</span><span class="p">,</span> <span class="n">username</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">strcpy</span><span class="p">(</span><span class="n">statement</span><span class="o">-&gt;</span><span class="n">row_to_insert</span><span class="p">.</span><span class="n">email</span><span class="p">,</span> <span class="n">email</span><span class="p">);</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="k">return</span> <span class="n">PREPARE_SUCCESS</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
 <span class="n">PrepareResult</span> <span class="n">prepare_statement</span><span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span><span class="p">,</span>
                                 <span class="n">Statement</span><span class="o">*</span> <span class="n">statement</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;insert&#34;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="k">return</span> <span class="n">prepare_insert</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">,</span> <span class="n">statement</span><span class="p">);</span>
   <span class="p">}</span>
</code></pre></div><p>对输入缓冲区连续调用<code>strtok</code>函数，通过插入空字符来将其分成子字符串（在我们的情况下是空格作为分隔符）。它返回子字符串的起始指针。</p>
<p>我们可以对每个文本值调用<a href="http://www.cplusplus.com/reference/cstring/strlen/">strlen()</a>来查看其是否太长。</p>
<p>我们可以像处理其他错误代码一样处理错误：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"> enum PrepareResult_t {
   PREPARE_SUCCESS,
<span class="gi">+  PREPARE_STRING_TOO_LONG,
</span><span class="gi"></span>   PREPARE_SYNTAX_ERROR,
   PREPARE_UNRECOGNIZED_STATEMENT
 };
 switch (prepare_statement(input_buffer, &amp;statement)) {
   case (PREPARE_SUCCESS):
     break;
<span class="gi">+  case (PREPARE_STRING_TOO_LONG):
</span><span class="gi">+    printf(&#34;String is too long.\n&#34;);
</span><span class="gi">+    continue;
</span><span class="gi"></span>   case (PREPARE_SYNTAX_ERROR):
     printf(&#34;Syntax error. Could not parse statement.\n&#34;);
     continue;
</code></pre></div><p>这样我们的测试就通过了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">bundle exec rspec
....

Finished in 0.02284 seconds (files took 0.116 seconds to load)
4 examples, 0 failures
</code></pre></div><p>在这里，我们也可以处理一个额外的错误情况：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ruby" data-lang="ruby"><span class="n">it</span> <span class="s1">&#39;prints an error message if id is negative&#39;</span> <span class="k">do</span>
  <span class="n">script</span> <span class="o">=</span> <span class="o">[</span>
    <span class="s2">&#34;insert -1 cstack foo@bar.com&#34;</span><span class="p">,</span>
    <span class="s2">&#34;select&#34;</span><span class="p">,</span>
    <span class="s2">&#34;.exit&#34;</span><span class="p">,</span>
  <span class="o">]</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">run_script</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
  <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">match_array</span><span class="p">(</span><span class="o">[</span>
    <span class="s2">&#34;db &gt; ID must be positive.&#34;</span><span class="p">,</span>
    <span class="s2">&#34;db &gt; Executed.&#34;</span><span class="p">,</span>
    <span class="s2">&#34;db &gt; &#34;</span><span class="p">,</span>
  <span class="o">]</span><span class="p">)</span>
<span class="k">end</span>

</code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">
 <span class="k">enum</span> <span class="n">PrepareResult_t</span> <span class="p">{</span>
   <span class="n">PREPARE_SUCCESS</span><span class="p">,</span>
<span class="o">+</span>  <span class="n">PREPARE_NEGATIVE_ID</span><span class="p">,</span>
   <span class="n">PREPARE_STRING_TOO_LONG</span><span class="p">,</span>
   <span class="n">PREPARE_SYNTAX_ERROR</span><span class="p">,</span>
   <span class="n">PREPARE_UNRECOGNIZED_STATEMENT</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">148</span><span class="p">,</span><span class="mi">9</span> <span class="o">+</span><span class="mi">147</span><span class="p">,</span><span class="mi">6</span> <span class="err">@@</span> <span class="n">PrepareResult</span> <span class="n">prepare_insert</span><span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span><span class="p">,</span> <span class="n">Statement</span><span class="o">*</span> <span class="n">statement</span><span class="p">)</span> <span class="p">{</span>
   <span class="p">}</span>

   <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">id_string</span><span class="p">);</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="k">return</span> <span class="n">PREPARE_NEGATIVE_ID</span><span class="p">;</span>
<span class="o">+</span>  <span class="p">}</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">username</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">COLUMN_USERNAME_SIZE</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">return</span> <span class="n">PREPARE_STRING_TOO_LONG</span><span class="p">;</span>
   <span class="p">}</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">230</span><span class="p">,</span><span class="mi">9</span> <span class="o">+</span><span class="mi">226</span><span class="p">,</span><span class="mi">6</span> <span class="err">@@</span> <span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
     <span class="k">switch</span> <span class="p">(</span><span class="n">prepare_statement</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">statement</span><span class="p">))</span> <span class="p">{</span>
       <span class="k">case</span> <span class="p">(</span><span class="n">PREPARE_SUCCESS</span><span class="p">)</span><span class="o">:</span>
         <span class="k">break</span><span class="p">;</span>
<span class="o">+</span>      <span class="k">case</span> <span class="p">(</span><span class="n">PREPARE_NEGATIVE_ID</span><span class="p">)</span><span class="o">:</span>
<span class="o">+</span>        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;ID must be positive.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="o">+</span>        <span class="k">continue</span><span class="p">;</span>
       <span class="k">case</span> <span class="p">(</span><span class="n">PREPARE_STRING_TOO_LONG</span><span class="p">)</span><span class="o">:</span>
         <span class="n">printf</span><span class="p">(</span><span class="s">&#34;String is too long.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
         <span class="k">continue</span><span class="p">;</span>
</code></pre></div><p>好了，现在测试足够了。接下来是一个非常重要的特性：持久性！我们将把数据库保存到文件中，然后再读取出来。</p>
<p>接下来会很棒。</p>
<p>这是本部分的完整差异：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gu">@@ -22,6 +22,8 @@
</span><span class="gu"></span>
 enum PrepareResult_t {
   PREPARE_SUCCESS,
<span class="gi">+  PREPARE_NEGATIVE_ID,
</span><span class="gi">+  PREPARE_STRING_TOO_LONG,
</span><span class="gi"></span>   PREPARE_SYNTAX_ERROR,
   PREPARE_UNRECOGNIZED_STATEMENT
  };
<span class="gu">@@ -34,8 +36,8 @@
</span><span class="gu"></span> #define COLUMN_EMAIL_SIZE 255
 typedef struct {
   uint32_t id;
<span class="gd">-  char username[COLUMN_USERNAME_SIZE];
</span><span class="gd">-  char email[COLUMN_EMAIL_SIZE];
</span><span class="gd"></span><span class="gi">+  char username[COLUMN_USERNAME_SIZE + 1];
</span><span class="gi">+  char email[COLUMN_EMAIL_SIZE + 1];
</span><span class="gi"></span> } Row;

<span class="gu">@@ -150,18 +152,40 @@ MetaCommandResult do_meta_command(InputBuffer* input_buffer, Table *table) {
</span><span class="gu"></span>   }
 }

<span class="gd">-PrepareResult prepare_statement(InputBuffer* input_buffer,
</span><span class="gd">-                                Statement* statement) {
</span><span class="gd">-  if (strncmp(input_buffer-&gt;buffer, &#34;insert&#34;, 6) == 0) {
</span><span class="gd"></span><span class="gi">+PrepareResult prepare_insert(InputBuffer* input_buffer, Statement* statement) {
</span><span class="gi"></span>   statement-&gt;type = STATEMENT_INSERT;
<span class="gd">-  int args_assigned = sscanf(
</span><span class="gd">-     input_buffer-&gt;buffer, &#34;insert %d %s %s&#34;, &amp;(statement-&gt;row_to_insert.id),
</span><span class="gd"></span>

<span class="gd">-     statement-&gt;row_to_insert.username, statement-&gt;row_to_insert.email
</span><span class="gd">-     );
</span><span class="gd">-  if (args_assigned &lt; 3) {
</span><span class="gd"></span><span class="gi">+
</span><span class="gi">+  char* keyword = strtok(input_buffer-&gt;buffer, &#34; &#34;);
</span><span class="gi">+  char* id_string = strtok(NULL, &#34; &#34;);
</span><span class="gi">+  char* username = strtok(NULL, &#34; &#34;);
</span><span class="gi">+  char* email = strtok(NULL, &#34; &#34;);
</span><span class="gi">+
</span><span class="gi">+  if (id_string == NULL || username == NULL || email == NULL) {
</span><span class="gi"></span>      return PREPARE_SYNTAX_ERROR;
   }
<span class="gi">+
</span><span class="gi">+  int id = atoi(id_string);
</span><span class="gi">+  if (id &lt; 0) {
</span><span class="gi">+     return PREPARE_NEGATIVE_ID;
</span><span class="gi">+  }
</span><span class="gi">+  if (strlen(username) &gt; COLUMN_USERNAME_SIZE) {
</span><span class="gi">+     return PREPARE_STRING_TOO_LONG;
</span><span class="gi">+  }
</span><span class="gi">+  if (strlen(email) &gt; COLUMN_EMAIL_SIZE) {
</span><span class="gi">+     return PREPARE_STRING_TOO_LONG;
</span><span class="gi">+  }
</span><span class="gi">+
</span><span class="gi">+  statement-&gt;row_to_insert.id = id;
</span><span class="gi">+  strcpy(statement-&gt;row_to_insert.username, username);
</span><span class="gi">+  strcpy(statement-&gt;row_to_insert.email, email);
</span><span class="gi">+
</span><span class="gi">+  return PREPARE_SUCCESS;
</span><span class="gi">+
</span><span class="gi">+}
</span><span class="gi">+PrepareResult prepare_statement(InputBuffer* input_buffer,
</span><span class="gi">+                                Statement* statement) {
</span><span class="gi">+  if (strncmp(input_buffer-&gt;buffer, &#34;insert&#34;, 6) == 0) {
</span><span class="gi">+      return prepare_insert(input_buffer, statement);
</span><span class="gi"></span>   }
</code></pre></div><p>并且我们增加了测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ruby" data-lang="ruby"><span class="o">+</span><span class="n">describe</span> <span class="s1">&#39;database&#39;</span> <span class="k">do</span>
<span class="o">+</span>  <span class="k">def</span> <span class="nf">run_script</span><span class="p">(</span><span class="n">commands</span><span class="p">)</span>
<span class="o">+</span>    <span class="n">raw_output</span> <span class="o">=</span> <span class="kp">nil</span>
<span class="o">+</span>    <span class="no">IO</span><span class="o">.</span><span class="n">popen</span><span class="p">(</span><span class="s2">&#34;./db&#34;</span><span class="p">,</span> <span class="s2">&#34;r+&#34;</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">pipe</span><span class="o">|</span>
<span class="o">+</span>      <span class="n">commands</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">command</span><span class="o">|</span>
<span class="o">+</span>        <span class="n">pipe</span><span class="o">.</span><span class="n">puts</span> <span class="n">command</span>
<span class="o">+</span>      <span class="k">end</span>
<span class="o">+</span>
<span class="o">+</span>      <span class="n">pipe</span><span class="o">.</span><span class="n">close_write</span>
<span class="o">+</span>
<span class="o">+</span>      <span class="c1"># Read entire output</span>
<span class="o">+</span>      <span class="n">raw_output</span> <span class="o">=</span> <span class="n">pipe</span><span class="o">.</span><span class="n">gets</span><span class="p">(</span><span class="kp">nil</span><span class="p">)</span>
<span class="o">+</span>    <span class="k">end</span>
<span class="o">+</span>    <span class="n">raw_output</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&#34;</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">)</span>
<span class="o">+</span>  <span class="k">end</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="n">it</span> <span class="s1">&#39;inserts and retrieves a row&#39;</span> <span class="k">do</span>
<span class="o">+</span>    <span class="n">result</span> <span class="o">=</span> <span class="n">run_script</span><span class="p">(</span><span class="o">[</span>
<span class="o">+</span>      <span class="s2">&#34;insert 1 user1 person1@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s2">&#34;select&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s2">&#34;.exit&#34;</span><span class="p">,</span>
<span class="o">+</span>    <span class="o">]</span><span class="p">)</span>
<span class="o">+</span>    <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">match_array</span><span class="p">(</span><span class="o">[</span>
<span class="o">+</span>      <span class="s2">&#34;db &gt; Executed.&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s2">&#34;db &gt; (1, user1, person1@example.com)&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s2">&#34;Executed.&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s2">&#34;db &gt; &#34;</span><span class="p">,</span>
<span class="o">+</span>    <span class="o">]</span><span class="p">)</span>
<span class="o">+</span>  <span class="k">end</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="n">it</span> <span class="s1">&#39;prints error message when table is full&#39;</span> <span class="k">do</span>
<span class="o">+</span>    <span class="n">script</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">1401</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
<span class="o">+</span>      <span class="s2">&#34;insert </span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2"> user</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2"> person</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">@example.com&#34;</span>
<span class="o">+</span>    <span class="k">end</span>
<span class="o">+</span>    <span class="n">script</span> <span class="o">&lt;&lt;</span> <span class="s2">&#34;.exit&#34;</span>
<span class="o">+</span>    <span class="n">result</span> <span class="o">=</span> <span class="n">run_script</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
<span class="o">+</span>    <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="o">[-</span><span class="mi">2</span><span class="o">]</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">eq</span><span class="p">(</span><span class="s1">&#39;db &gt; Error: Table full.&#39;</span><span class="p">)</span>
<span class="o">+</span>  <span class="k">end</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="n">it</span> <span class="s1">&#39;allows inserting strings that are the maximum length&#39;</span> <span class="k">do</span>
<span class="o">+</span>    <span class="n">long_username</span> <span class="o">=</span> <span class="s2">&#34;a&#34;</span><span class="o">*</span><span class="mi">32</span>
<span class="o">+</span>    <span class="n">long_email</span> <span class="o">=</span> <span class="s2">&#34;a&#34;</span><span class="o">*</span><span class="mi">255</span>
<span class="o">+</span>    <span class="n">script</span> <span class="o">=</span> <span class="o">[</span>
<span class="o">+</span>      <span class="s2">&#34;insert 1 </span><span class="si">#{</span><span class="n">long_username</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">long_email</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s2">&#34;select&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s2">&#34;.exit&#34;</span><span class="p">,</span>
<span class="o">+</span>    <span class="o">]</span>
<span class="o">+</span>    <span class="n">result</span> <span class="o">=</span> <span class="n">run_script</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
<span class="o">+</span>    <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">match_array</span><span class="p">(</span><span class="o">[</span>
<span class="o">+</span>      <span class="s2">&#34;db &gt; Executed.&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s2">&#34;db &gt; (1, </span><span class="si">#{</span><span class="n">long_username</span><span class="si">}</span><span class="s2">, </span><span class="si">#{</span><span class="n">long_email</span><span class="si">}</span><span class="s2">)&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s2">&#34;Executed.&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s2">&#34;db &gt; &#34;</span><span class="p">,</span>
<span class="o">+</span>    <span class="o">]</span><span class="p">)</span>
<span class="o">+</span>  <span class="k">end</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="n">it</span> <span class="s1">&#39;prints error message if strings are too long&#39;</span> <span class="k">do</span>
<span class="o">+</span>    <span class="n">long_username</span> <span class="o">=</span> <span class="s2">&#34;a&#34;</span><span class="o">*</span><span class="mi">33</span>
<span class="o">+</span>    <span class="n">long_email</span> <span class="o">=</span> <span class="s2">&#34;a&#34;</span><span class="o">*</span><span class="mi">256</span>
<span class="o">+</span>    <span class="n">script</span> <span class="o">=</span> <span class="o">[</span>
<span class="o">+</span>      <span class="s2">&#34;insert 1 </span><span class="si">#{</span><span class="n">long_username</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">long_email</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s2">&#34;select&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s2">&#34;.exit&#34;</span><span class="p">,</span>
<span class="o">+</span>    <span class="o">]</span>
<span class="o">+</span>    <span class="n">result</span> <span class="o">=</span> <span class="n">run_script</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
<span class="o">+</span>    <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">match_array</span><span class="p">(</span><span class="o">[</span>
<span class="o">+</span>      <span class="s2">&#34;db &gt; String is too long.&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s2">&#34;db &gt; Executed.&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s2">&#34;db &gt; &#34;</span><span class="p">,</span>
<span class="o">+</span>    <span class="o">]</span><span class="p">)</span>
<span class="o">+</span>  <span class="k">end</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="n">it</span> <span class="s1">&#39;prints an error message if id is negative&#39;</span> <span class="k">do</span>
<span class="o">+</span>    <span class="n">script</span> <span class="o">=</span> <span class="o">[</span>
<span class="o">+</span>      <span class="s2">&#34;insert -1 cstack foo@bar.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s2">&#34;select&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s2">&#34;.exit&#34;</span><span class="p">,</span>
<span class="o">+</span>    <span class="o">]</span>
<span class="o">+</span>    <span class="n">result</span> <span class="o">=</span> <span class="n">run_script</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
<span class="o">+</span>    <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">match_array</span><span class="p">(</span><span class="o">[</span>
<span class="o">+</span>      <span class="s2">&#34;db &gt; ID must be positive.&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s2">&#34;db &gt; Executed.&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s2">&#34;db &gt; &#34;</span><span class="p">,</span>
<span class="o">+</span>    <span class="o">]</span><span class="p">)</span>
<span class="o">+</span>  <span class="k">end</span>
<span class="o">+</span><span class="k">end</span>

</code></pre></div><h2 id="第五部分---持久化到磁盘">第五部分 - 持久化到磁盘</h2>
<blockquote>
<p>“世界上没有什么可以取代坚持。Nothing in the world can take the place of persistence.” - <a href="https://en.wikiquote.org/wiki/Calvin_Coolidge">卡尔文·柯立芝</a></p>
</blockquote>
<p>我们的数据库允许你插入记录并将其读取回来，但前提是只要你保持程序运行。如果你关闭程序然后重新启动，所有记录都会消失。下面是我们想要的行为规范：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ruby" data-lang="ruby"><span class="n">it</span> <span class="s1">&#39;keeps data after closing connection&#39;</span> <span class="k">do</span>
  <span class="n">result1</span> <span class="o">=</span> <span class="n">run_script</span><span class="p">(</span><span class="o">[</span>
    <span class="s2">&#34;insert 1 user1 person1@example.com&#34;</span><span class="p">,</span>
    <span class="s2">&#34;.exit&#34;</span><span class="p">,</span>
  <span class="o">]</span><span class="p">)</span>
  <span class="n">expect</span><span class="p">(</span><span class="n">result1</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">match_array</span><span class="p">(</span><span class="o">[</span>
    <span class="s2">&#34;db &gt; Executed.&#34;</span><span class="p">,</span>
    <span class="s2">&#34;db &gt; &#34;</span><span class="p">,</span>
  <span class="o">]</span><span class="p">)</span>
  <span class="n">result2</span> <span class="o">=</span> <span class="n">run_script</span><span class="p">(</span><span class="o">[</span>
    <span class="s2">&#34;select&#34;</span><span class="p">,</span>
    <span class="s2">&#34;.exit&#34;</span><span class="p">,</span>
  <span class="o">]</span><span class="p">)</span>
  <span class="n">expect</span><span class="p">(</span><span class="n">result2</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">match_array</span><span class="p">(</span><span class="o">[</span>
    <span class="s2">&#34;db &gt; (1, user1, person1@example.com)&#34;</span><span class="p">,</span>
    <span class="s2">&#34;Executed.&#34;</span><span class="p">,</span>
    <span class="s2">&#34;db &gt; &#34;</span><span class="p">,</span>
  <span class="o">]</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div><p>和 SQLite 一样，我们将通过将整个数据库保存到文件来保留记录。</p>
<p>我们已经通过将行序列化为页面大小的内存块来为此做好了准备。要添加持久性，我们可以简单地将这些内存块写入文件，并在下次启动程序时将其读入内存。</p>
<p>为了简化操作，我们将创建一个名为“Pager”的抽象层。我们向Pager请求第<code>x</code>页，Pager会返回一个内存块。它首先查看其缓存。如果缓存未命中，它将从磁盘中复制数据到内存中（通过读取数据库文件）。</p>
<p><img src="https://cstack.github.io/db_tutorial/assets/images/arch-part5.gif" alt="我们的程序如何与SQLite架构匹配"></p>
<p>Pager访问页缓存和文件。Table对象通过Pager发送页面请求：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gi">+typedef struct {
</span><span class="gi">+  int file_descriptor;
</span><span class="gi">+  uint32_t file_length;
</span><span class="gi">+  void* pages[TABLE_MAX_PAGES];gfvccddddddd 
</span><span class="gi">+} Pager;
</span><span class="gi">+
</span><span class="gi"></span> typedef struct {
<span class="gd">-  void* pages[TABLE_MAX_PAGES];
</span><span class="gd"></span><span class="gi">+  Pager* pager;
</span><span class="gi"></span>   uint32_t num_rows;
 } Table;
</code></pre></div><p>我将<code>new_table()</code>重命名为<code>db_open()</code>，因为它现在具有打开数据库连接的效果。通过打开连接，我指的是：</p>
<ul>
<li>打开数据库文件</li>
<li>初始化页管理器数据结构</li>
<li>初始化表数据结构</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gd">-Table* new_table() {
</span><span class="gd"></span><span class="gi">+Table* db_open(const char* filename) {
</span><span class="gi">+  Pager* pager = pager_open(filename);
</span><span class="gi">+  uint32_t num_rows = pager-&gt;file_length / ROW_SIZE;
</span><span class="gi">+
</span><span class="gi"></span>   Table* table = malloc(sizeof(Table));
<span class="gd">-  table-&gt;num_rows = 0;
</span><span class="gd"></span><span class="gi">+  table-&gt;pager = pager;
</span><span class="gi">+  table-&gt;num_rows = num_rows;
</span><span class="gi"></span>
   return table;
 }
</code></pre></div><p><code>db_open()</code> 调用了 <code>pager_open()</code> 方法，该方法打开数据库文件并跟踪其大小。它还将页面缓存初始化为全部为 <code>NULL</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gi">+Pager* pager_open(const char* filename) {
</span><span class="gi">+  int fd = open(filename,
</span><span class="gi">+                O_RDWR |      // Read/Write mode
</span><span class="gi">+                    O_CREAT,  // Create file if it does not exist
</span><span class="gi">+                S_IWUSR |     // User write permission
</span><span class="gi">+                    S_IRUSR   // User read permission
</span><span class="gi">+                );
</span><span class="gi">+
</span><span class="gi">+  if (fd == -1) {
</span><span class="gi">+    printf(&#34;Unable to open file\n&#34;);
</span><span class="gi">+    exit(EXIT_FAILURE);
</span><span class="gi">+  }
</span><span class="gi">+
</span><span class="gi">+  off_t file_length = lseek(fd, 0, SEEK_END);
</span><span class="gi">+
</span><span class="gi">+  Pager* pager = malloc(sizeof(Pager));
</span><span class="gi">+  pager-&gt;file_descriptor = fd;
</span><span class="gi">+  pager-&gt;file_length = file_length;
</span><span class="gi">+
</span><span class="gi">+  for (uint32_t i = 0; i &lt; TABLE_MAX_PAGES; i++) {
</span><span class="gi">+    pager-&gt;pages[i] = NULL;
</span><span class="gi">+  }
</span><span class="gi">+
</span><span class="gi">+  return pager;
</span><span class="gi">+}
</span></code></pre></div><p>根据新的抽象，我们将获取页面的逻辑移到单独的方法中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"> void* row_slot(Table* table, uint32_t row_num) {
   uint32_t page_num = row_num / ROWS_PER_PAGE;
<span class="gd">-  void* page = table-&gt;pages[page_num];
</span><span class="gd">-  if (page == NULL) {
</span><span class="gd">-    // Allocate memory only when we try to access page
</span><span class="gd">-    page = table-&gt;pages[page_num] = malloc(PAGE_SIZE);
</span><span class="gd">-  }
</span><span class="gd"></span><span class="gi">+  void* page = get_page(table-&gt;pager, page_num);
</span><span class="gi"></span>   uint32_t row_offset = row_num % ROWS_PER_PAGE;
   uint32_t byte_offset = row_offset * ROW_SIZE;
   return page + byte_offset;
 }
</code></pre></div><p><code>get_page()</code> 方法包含处理缓存未命中的逻辑。我们假设页面按顺序保存在数据库文件中：第0页位于偏移量0处，第1页位于偏移量4096处，第2页位于偏移量8192处，依此类推。如果请求的页面超出文件范围，我们知道它应该是空白的，因此我们只需分配一些内存并返回它。稍后将缓存刷新到磁盘时，页面将被添加到文件中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gi">+void* get_page(Pager* pager, uint32_t page_num) {
</span><span class="gi">+  if (page_num &gt; TABLE_MAX_PAGES) {
</span><span class="gi">+    printf(&#34;Tried to fetch page number out of bounds. %d &gt; %d\n&#34;, page_num,
</span><span class="gi">+           TABLE_MAX_PAGES);
</span><span class="gi">+    exit(EXIT_FAILURE);
</span><span class="gi">+  }
</span><span class="gi">+
</span><span class="gi">+  if (pager-&gt;pages[page_num] == NULL) {
</span><span class="gi">+    // Cache miss. Allocate memory and load from file.
</span><span class="gi">+    void* page = malloc(PAGE_SIZE);
</span><span class="gi">+    uint32_t num_pages = pager-&gt;file_length / PAGE_SIZE;
</span><span class="gi">+
</span><span class="gi">+    // We might save a partial page at the end of the file
</span><span class="gi">+    if (pager-&gt;file_length % PAGE_SIZE) {
</span><span class="gi">+      num_pages += 1;
</span><span class="gi">+    }
</span><span class="gi">+
</span><span class="gi">+    if (page_num &lt;= num_pages) {
</span><span class="gi">+      lseek(pager-&gt;file_descriptor, page_num * PAGE_SIZE, SEEK_SET);
</span><span class="gi">+      ssize_t bytes_read = read(pager-&gt;file_descriptor, page, PAGE_SIZE);
</span><span class="gi">+      if (bytes_read == -1) {
</span><span class="gi">+        printf(&#34;Error reading file: %d\n&#34;, errno);
</span><span class="gi">+        exit(EXIT_FAILURE);
</span><span class="gi">+      }
</span><span class="gi">+    }
</span><span class="gi">+
</span><span class="gi">+    pager-&gt;pages[page_num] = page;
</span><span class="gi">+  }
</span><span class="gi">+
</span><span class="gi">+  return pager-&gt;pages[page_num];
</span><span class="gi">+}
</span></code></pre></div><p>暂时，我们会等到用户关闭数据库连接之后再将缓存刷新到磁盘上。当用户退出时，我们将调用一个名为 <code>db_close()</code> 的新方法，其中：</p>
<ul>
<li>将页缓存刷新到磁盘上</li>
<li>关闭数据库文件</li>
<li>释放 Pager 和 Table 数据结构的内存</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">db_close</span><span class="p">(</span><span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">num_full_pages</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">/</span> <span class="n">ROWS_PER_PAGE</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_full_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">pager_flush</span><span class="p">(</span><span class="n">pager</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// There may be a partial page to write to the end of the file
</span><span class="c1"></span>  <span class="c1">// This should not be needed after we switch to a B-tree
</span><span class="c1"></span>  <span class="kt">uint32_t</span> <span class="n">num_additional_rows</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">%</span> <span class="n">ROWS_PER_PAGE</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">num_additional_rows</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">page_num</span> <span class="o">=</span> <span class="n">num_full_pages</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">pager_flush</span><span class="p">(</span><span class="n">pager</span><span class="p">,</span> <span class="n">page_num</span><span class="p">,</span> <span class="n">num_additional_rows</span> <span class="o">*</span> <span class="n">ROW_SIZE</span><span class="p">);</span>
      <span class="n">free</span><span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">]);</span>
      <span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">close</span><span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">file_descriptor</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error closing db file.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TABLE_MAX_PAGES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">page</span> <span class="o">=</span> <span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">free</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
      <span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">free</span><span class="p">(</span><span class="n">pager</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
<span class="p">}</span>

<span class="o">-</span><span class="n">MetaCommandResult</span> <span class="n">do_meta_command</span><span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span><span class="n">MetaCommandResult</span> <span class="n">do_meta_command</span><span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span><span class="p">,</span> <span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;.exit&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="n">db_close</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
     <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
     <span class="k">return</span> <span class="n">META_COMMAND_UNRECOGNIZED_COMMAND</span><span class="p">;</span>
</code></pre></div><p>在我们当前的设计中，文件的长度编码了数据库中的行数，因此我们需要在文件末尾写入一个部分页面。这就是为什么 <code>pager_flush()</code> 需要接收页面编号和大小两个参数。这并不是最佳的设计，但在我们开始实现 B 树时，这个设计会很快消失。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">pager_flush</span><span class="p">(</span><span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">page_num</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Tried to flush null page</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">off_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">lseek</span><span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">file_descriptor</span><span class="p">,</span> <span class="n">page_num</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error seeking: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">errno</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">ssize_t</span> <span class="n">bytes_written</span> <span class="o">=</span>
      <span class="n">write</span><span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">file_descriptor</span><span class="p">,</span> <span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">],</span> <span class="n">size</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">bytes_written</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error writing: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">errno</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>最后，我们需要将文件名作为命令行参数传递。不要忘记还要将额外的参数添加到 <code>do_meta_command</code> 中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"> <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
<span class="o">-</span>  <span class="n">Table</span><span class="o">*</span> <span class="n">table</span> <span class="o">=</span> <span class="n">new_table</span><span class="p">();</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Must supply a database filename.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="o">+</span>  <span class="n">Table</span><span class="o">*</span> <span class="n">table</span> <span class="o">=</span> <span class="n">db_open</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
<span class="o">+</span>
   <span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span> <span class="o">=</span> <span class="n">new_input_buffer</span><span class="p">();</span>
   <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">print_prompt</span><span class="p">();</span>
     <span class="n">read_input</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">);</span>

     <span class="k">if</span> <span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span><span class="p">)</span> <span class="p">{</span>
<span class="o">-</span>      <span class="k">switch</span> <span class="p">(</span><span class="n">do_meta_command</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">))</span> <span class="p">{</span>
<span class="o">+</span>      <span class="k">switch</span> <span class="p">(</span><span class="n">do_meta_command</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">,</span> <span class="n">table</span><span class="p">))</span> <span class="p">{</span>
</code></pre></div><p>有了这些更改，我们可以关闭然后重新打开数据库，我们的记录依然存在！</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">~ ./db mydb.db
db &gt; insert 1 cstack foo@bar.com
Executed.
db &gt; insert 2 voltorb volty@example.com
Executed.
db &gt; .exit
~
~ ./db mydb.db
db &gt; select
(1, cstack, foo@bar.com)
(2, voltorb, volty@example.com)
Executed.
db &gt; .exit
~
</code></pre></div><p>为了更有趣，让我们查看一下 <code>mydb.db</code>，看看我们的数据是如何存储的。我会使用 vim 作为十六进制编辑器来查看文件的内存布局：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">vim mydb.db
:%!xxd
</code></pre></div><p><img src="https://cstack.github.io/db_tutorial/assets/images/file-format.png" alt="当前文件格式"></p>
<p>前四个字节是第一行的 ID（4 个字节因为我们存储了一个 <code>uint32_t</code>）。它以小端字节序存储，因此最低有效字节排在前面（01），后面是高位字节（00 00 00）。我们使用 <code>memcpy()</code> 将字节从 <code>Row</code> 结构体复制到页面缓存，这意味着结构体在内存中按照小端字节序排列。这是我编译程序时所用机器的特性。如果我们想在我的机器上写一个数据库文件，然后在大端序的机器上读取它，我们就需要更改我们的 <code>serialize_row()</code> 和 <code>deserialize_row()</code> 方法，始终以相同的顺序存储和读取字节。</p>
<p>接下来的 33 个字节以空字符结尾存储了用户名。显然，“cstack” 的 ASCII 十六进制是 <code>63 73 74 61 63 6b</code>，后跟一个空字符（<code>00</code>）。其余的 33 个字节未被使用。</p>
<p>接下来的 256 个字节以同样的方式存储了邮箱。在终止空字符后面，我们可以看到一些随机的垃圾值。这很可能是由于我们 <code>Row</code> 结构体中未初始化的内存。我们将整个 256 字节的邮箱缓冲区复制到文件中，包括字符串结束后的任何字节。当我们分配该结构体时，内存中存在的任何值都会保留下来。但由于我们使用了终止空字符，它对行为没有影响。</p>
<p><strong>注意</strong>：如果我们想确保所有字节都被初始化，可以在 <code>serialize_row</code> 中将 <code>username</code> 和 <code>email</code> 字段的复制改为 <code>strncpy</code>，如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">serialize_row</span><span class="p">(</span><span class="n">Row</span><span class="o">*</span> <span class="n">source</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">destination</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">memcpy</span><span class="p">(</span><span class="n">destination</span> <span class="o">+</span> <span class="n">ID_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">source</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">),</span> <span class="n">ID_SIZE</span><span class="p">);</span>
<span class="o">-</span>    <span class="n">memcpy</span><span class="p">(</span><span class="n">destination</span> <span class="o">+</span> <span class="n">USERNAME_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">source</span><span class="o">-&gt;</span><span class="n">username</span><span class="p">),</span> <span class="n">USERNAME_SIZE</span><span class="p">);</span>
<span class="o">-</span>    <span class="n">memcpy</span><span class="p">(</span><span class="n">destination</span> <span class="o">+</span> <span class="n">EMAIL_OFFSET</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">source</span><span class="o">-&gt;</span><span class="n">email</span><span class="p">),</span> <span class="n">EMAIL_SIZE</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">strncpy</span><span class="p">(</span><span class="n">destination</span> <span class="o">+</span> <span class="n">USERNAME_OFFSET</span><span class="p">,</span> <span class="n">source</span><span class="o">-&gt;</span><span class="n">username</span><span class="p">,</span> <span class="n">USERNAME_SIZE</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">strncpy</span><span class="p">(</span><span class="n">destination</span> <span class="o">+</span> <span class="n">EMAIL_OFFSET</span><span class="p">,</span> <span class="n">source</span><span class="o">-&gt;</span><span class="n">email</span><span class="p">,</span> <span class="n">EMAIL_SIZE</span><span class="p">);</span>
 <span class="p">}</span>
</code></pre></div><h3 id="结论">结论</h3>
<p>好了！我们实现了持久性。这不是最理想的。例如，如果你在没有输入 <code>.exit</code> 的情况下终止程序，你会丢失更改。此外，我们将所有页面写回磁盘，即使这些页面自从从磁盘读取以来没有发生变化。这些是我们可以稍后解决的问题。</p>
<p>下次我们将介绍游标，这应该会更容易地实现 B 树。</p>
<p>在那之前！</p>
<h3 id="完整的变更">完整的变更</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span><span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">errno</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
<span class="o">+</span><span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">fcntl</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
 <span class="cp">#include</span> <span class="cpf">&lt;stdbool.h&gt;</span><span class="cp">
</span><span class="cp"></span> <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span> <span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp"></span> <span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp"></span> <span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="o">+</span><span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">unistd</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>

 <span class="k">struct</span> <span class="n">InputBuffer_t</span> <span class="p">{</span>
   <span class="kt">char</span><span class="o">*</span> <span class="n">buffer</span><span class="p">;</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">62</span><span class="p">,</span><span class="mi">9</span> <span class="o">+</span><span class="mi">65</span><span class="p">,</span><span class="mi">16</span> <span class="err">@@</span> <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">PAGE_SIZE</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
 <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">ROWS_PER_PAGE</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="n">ROW_SIZE</span><span class="p">;</span>
 <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">TABLE_MAX_ROWS</span> <span class="o">=</span> <span class="n">ROWS_PER_PAGE</span> <span class="o">*</span> <span class="n">TABLE_MAX_PAGES</span><span class="p">;</span>

<span class="o">+</span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
<span class="o">+</span>  <span class="kt">int</span> <span class="n">file_descriptor</span><span class="p">;</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">file_length</span><span class="p">;</span>
<span class="o">+</span>  <span class="kt">void</span><span class="o">*</span> <span class="n">pages</span><span class="p">[</span><span class="n">TABLE_MAX_PAGES</span><span class="p">];</span>
<span class="o">+</span><span class="p">}</span> <span class="n">Pager</span><span class="p">;</span>
<span class="o">+</span>
 <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
   <span class="kt">uint32_t</span> <span class="n">num_rows</span><span class="p">;</span>
<span class="o">-</span>  <span class="kt">void</span><span class="o">*</span> <span class="n">pages</span><span class="p">[</span><span class="n">TABLE_MAX_PAGES</span><span class="p">];</span>
<span class="o">+</span>  <span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span><span class="p">;</span>
 <span class="p">}</span> <span class="n">Table</span><span class="p">;</span>

<span class="err">@@</span> <span class="o">-</span><span class="mi">84</span><span class="p">,</span><span class="mi">32</span> <span class="o">+</span><span class="mi">94</span><span class="p">,</span><span class="mi">81</span> <span class="err">@@</span> <span class="kt">void</span> <span class="n">deserialize_row</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">source</span><span class="p">,</span> <span class="n">Row</span><span class="o">*</span> <span class="n">destination</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">destination</span><span class="o">-&gt;</span><span class="n">email</span><span class="p">),</span> <span class="n">source</span> <span class="o">+</span> <span class="n">EMAIL_OFFSET</span><span class="p">,</span> <span class="n">EMAIL_SIZE</span><span class="p">);</span>
 <span class="p">}</span>

<span class="o">+</span><span class="kt">void</span><span class="o">*</span> <span class="n">get_page</span><span class="p">(</span><span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">page_num</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">page_num</span> <span class="o">&gt;</span> <span class="n">TABLE_MAX_PAGES</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>     <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Tried to fetch page number out of bounds. %d &gt; %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">page_num</span><span class="p">,</span>
<span class="o">+</span>     	<span class="n">TABLE_MAX_PAGES</span><span class="p">);</span>
<span class="o">+</span>     <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>     <span class="c1">// Cache miss. Allocate memory and load from file.
</span><span class="c1"></span><span class="o">+</span>     <span class="kt">void</span><span class="o">*</span> <span class="n">page</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">);</span>
<span class="o">+</span>     <span class="kt">uint32_t</span> <span class="n">num_pages</span> <span class="o">=</span> <span class="n">pager</span><span class="o">-&gt;</span><span class="n">file_length</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span>     <span class="c1">// We might save a partial page at the end of the file
</span><span class="c1"></span><span class="o">+</span>     <span class="k">if</span> <span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">file_length</span> <span class="o">%</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>         <span class="n">num_pages</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="o">+</span>     <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>     <span class="k">if</span> <span class="p">(</span><span class="n">page_num</span> <span class="o">&lt;=</span> <span class="n">num_pages</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>         <span class="n">lseek</span><span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">file_descriptor</span><span class="p">,</span> <span class="n">page_num</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>
<span class="o">+</span>         <span class="n">ssize_t</span> <span class="n">bytes_read</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">file_descriptor</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
<span class="o">+</span>         <span class="k">if</span> <span class="p">(</span><span class="n">bytes_read</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>     	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error reading file: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">errno</span><span class="p">);</span>
<span class="o">+</span>     	<span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="o">+</span>         <span class="p">}</span>
<span class="o">+</span>     <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>     <span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="k">return</span> <span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">];</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
 <span class="kt">void</span><span class="o">*</span> <span class="n">row_slot</span><span class="p">(</span><span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">row_num</span><span class="p">)</span> <span class="p">{</span>
   <span class="kt">uint32_t</span> <span class="n">page_num</span> <span class="o">=</span> <span class="n">row_num</span> <span class="o">/</span> <span class="n">ROWS_PER_PAGE</span><span class="p">;</span>
<span class="o">-</span>  <span class="kt">void</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">];</span>
<span class="o">-</span>  <span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
<span class="o">-</span>     <span class="c1">// Allocate memory only when we try to access page
</span><span class="c1"></span><span class="o">-</span>     <span class="n">page</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">);</span>
<span class="o">-</span>  <span class="p">}</span>
<span class="o">+</span>  <span class="kt">void</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">page_num</span><span class="p">);</span>
   <span class="kt">uint32_t</span> <span class="n">row_offset</span> <span class="o">=</span> <span class="n">row_num</span> <span class="o">%</span> <span class="n">ROWS_PER_PAGE</span><span class="p">;</span>
   <span class="kt">uint32_t</span> <span class="n">byte_offset</span> <span class="o">=</span> <span class="n">row_offset</span> <span class="o">*</span> <span class="n">ROW_SIZE</span><span class="p">;</span>
   <span class="k">return</span> <span class="n">page</span> <span class="o">+</span> <span class="n">byte_offset</span><span class="p">;</span>
 <span class="p">}</span>

<span class="o">-</span><span class="n">Table</span><span class="o">*</span> <span class="n">new_table</span><span class="p">()</span> <span class="p">{</span>
<span class="o">-</span>  <span class="n">Table</span><span class="o">*</span> <span class="n">table</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Table</span><span class="p">));</span>
<span class="o">-</span>  <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">+</span><span class="n">Pager</span><span class="o">*</span> <span class="n">pager_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span>
<span class="o">+</span>     	  <span class="n">O_RDWR</span> <span class="o">|</span> 	<span class="c1">// Read/Write mode
</span><span class="c1"></span><span class="o">+</span>     	      <span class="n">O_CREAT</span><span class="p">,</span>	<span class="c1">// Create file if it does not exist
</span><span class="c1"></span><span class="o">+</span>     	  <span class="n">S_IWUSR</span> <span class="o">|</span>	<span class="c1">// User write permission
</span><span class="c1"></span><span class="o">+</span>     	      <span class="n">S_IRUSR</span>	<span class="c1">// User read permission
</span><span class="c1"></span><span class="o">+</span>     	  <span class="p">);</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>     <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Unable to open file</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="o">+</span>     <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="n">off_t</span> <span class="n">file_length</span> <span class="o">=</span> <span class="n">lseek</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_END</span><span class="p">);</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Pager</span><span class="p">));</span>
<span class="o">+</span>  <span class="n">pager</span><span class="o">-&gt;</span><span class="n">file_descriptor</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
<span class="o">+</span>  <span class="n">pager</span><span class="o">-&gt;</span><span class="n">file_length</span> <span class="o">=</span> <span class="n">file_length</span><span class="p">;</span>
<span class="o">+</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TABLE_MAX_PAGES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">-</span>     <span class="n">table</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="o">+</span>     <span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
   <span class="p">}</span>
<span class="o">-</span>  <span class="k">return</span> <span class="n">table</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="k">return</span> <span class="n">pager</span><span class="p">;</span>
 <span class="p">}</span>

<span class="o">-</span><span class="kt">void</span> <span class="n">free_table</span><span class="p">(</span><span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
<span class="o">-</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">-</span>     <span class="n">free</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="o">-</span>  <span class="p">}</span>
<span class="o">-</span>  <span class="n">free</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
<span class="o">+</span><span class="n">Table</span><span class="o">*</span> <span class="n">db_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span> <span class="o">=</span> <span class="n">pager_open</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">num_rows</span> <span class="o">=</span> <span class="n">pager</span><span class="o">-&gt;</span><span class="n">file_length</span> <span class="o">/</span> <span class="n">ROW_SIZE</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="n">Table</span><span class="o">*</span> <span class="n">table</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Table</span><span class="p">));</span>
<span class="o">+</span>  <span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span> <span class="o">=</span> <span class="n">pager</span><span class="p">;</span>
<span class="o">+</span>  <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">=</span> <span class="n">num_rows</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="k">return</span> <span class="n">table</span><span class="p">;</span>
 <span class="p">}</span>

 <span class="n">InputBuffer</span><span class="o">*</span> <span class="n">new_input_buffer</span><span class="p">()</span> <span class="p">{</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">142</span><span class="p">,</span><span class="mi">10</span> <span class="o">+</span><span class="mi">201</span><span class="p">,</span><span class="mi">76</span> <span class="err">@@</span> <span class="kt">void</span> <span class="n">close_input_buffer</span><span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">free</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">);</span>
 <span class="p">}</span>

<span class="o">+</span><span class="kt">void</span> <span class="n">pager_flush</span><span class="p">(</span><span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">page_num</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>     <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Tried to flush null page</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="o">+</span>     <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="n">off_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">lseek</span><span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">file_descriptor</span><span class="p">,</span> <span class="n">page_num</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
<span class="o">+</span>     		 <span class="n">SEEK_SET</span><span class="p">);</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>     <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error seeking: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">errno</span><span class="p">);</span>
<span class="o">+</span>     <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="n">ssize_t</span> <span class="n">bytes_written</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span>
<span class="o">+</span>     <span class="n">pager</span><span class="o">-&gt;</span><span class="n">file_descriptor</span><span class="p">,</span> <span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">],</span> <span class="n">size</span>
<span class="o">+</span>     <span class="p">);</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">bytes_written</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>     <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error writing: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">errno</span><span class="p">);</span>
<span class="o">+</span>     <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span><span class="kt">void</span> <span class="n">db_close</span><span class="p">(</span><span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">;</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">num_full_pages</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">/</span> <span class="n">ROWS_PER_PAGE</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_full_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>     <span class="k">if</span> <span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>         <span class="k">continue</span><span class="p">;</span>
<span class="o">+</span>     <span class="p">}</span>
<span class="o">+</span>     <span class="n">pager_flush</span><span class="p">(</span><span class="n">pager</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
<span class="o">+</span>     <span class="n">free</span><span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="o">+</span>     <span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="c1">// There may be a partial page to write to the end of the file
</span><span class="c1"></span><span class="o">+</span>  <span class="c1">// This should not be needed after we switch to a B-tree
</span><span class="c1"></span><span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">num_additional_rows</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">%</span> <span class="n">ROWS_PER_PAGE</span><span class="p">;</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">num_additional_rows</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>     <span class="kt">uint32_t</span> <span class="n">page_num</span> <span class="o">=</span> <span class="n">num_full_pages</span><span class="p">;</span>
<span class="o">+</span>     <span class="k">if</span> <span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>         <span class="n">pager_flush</span><span class="p">(</span><span class="n">pager</span><span class="p">,</span> <span class="n">page_num</span><span class="p">,</span> <span class="n">num_additional_rows</span> <span class="o">*</span> <span class="n">ROW_SIZE</span><span class="p">);</span>
<span class="o">+</span>         <span class="n">free</span><span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">]);</span>
<span class="o">+</span>         <span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="o">+</span>     <span class="p">}</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">close</span><span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">file_descriptor</span><span class="p">);</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>     <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error closing db file.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="o">+</span>     <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TABLE_MAX_PAGES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>     <span class="kt">void</span><span class="o">*</span> <span class="n">page</span> <span class="o">=</span> <span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="o">+</span>     <span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>         <span class="n">free</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="o">+</span>         <span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="o">+</span>     <span class="p">}</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="n">free</span><span class="p">(</span><span class="n">pager</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">free</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
 <span class="n">MetaCommandResult</span> <span class="n">do_meta_command</span><span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span><span class="p">,</span> <span class="n">Table</span> <span class="o">*</span><span class="n">table</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;.exit&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">close_input_buffer</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">);</span>
<span class="o">-</span>    <span class="n">free_table</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">db_close</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
     <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
     <span class="k">return</span> <span class="n">META_COMMAND_UNRECOGNIZED_COMMAND</span><span class="p">;</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">182</span><span class="p">,</span><span class="mi">6</span> <span class="o">+</span><span class="mi">308</span><span class="p">,</span><span class="mi">7</span> <span class="err">@@</span> <span class="n">PrepareResult</span> <span class="n">prepare_insert</span><span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span><span class="p">,</span> <span class="n">Statement</span><span class="o">*</span> <span class="n">statement</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">return</span> <span class="n">PREPARE_SUCCESS</span><span class="p">;</span>

 <span class="p">}</span>
<span class="o">+</span>
 <span class="n">PrepareResult</span> <span class="n">prepare_statement</span><span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span><span class="p">,</span>
                                 <span class="n">Statement</span><span class="o">*</span> <span class="n">statement</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;insert&#34;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">227</span><span class="p">,</span><span class="mi">7</span> <span class="o">+</span><span class="mi">354</span><span class="p">,</span><span class="mi">14</span> <span class="err">@@</span> <span class="n">ExecuteResult</span> <span class="n">execute_statement</span><span class="p">(</span><span class="n">Statement</span><span class="o">*</span> <span class="n">statement</span><span class="p">,</span> <span class="n">Table</span> <span class="o">*</span><span class="n">table</span><span class="p">)</span> <span class="p">{</span>
 <span class="p">}</span>

 <span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
<span class="o">-</span>  <span class="n">Table</span><span class="o">*</span> <span class="n">table</span> <span class="o">=</span> <span class="n">new_table</span><span class="p">();</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Must supply a database filename.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="o">+</span>      <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="o">+</span>  <span class="n">Table</span><span class="o">*</span> <span class="n">table</span> <span class="o">=</span> <span class="n">db_open</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
<span class="o">+</span>
   <span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span> <span class="o">=</span> <span class="n">new_input_buffer</span><span class="p">();</span>
   <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">print_prompt</span><span class="p">();</span>
</code></pre></div><p>以及我们测试的变更：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ruby" data-lang="ruby"> <span class="n">describe</span> <span class="s1">&#39;database&#39;</span> <span class="k">do</span>
<span class="o">+</span>  <span class="n">before</span> <span class="k">do</span>
<span class="o">+</span>    <span class="sb">`rm -rf test.db`</span>
<span class="o">+</span>  <span class="k">end</span>
<span class="o">+</span>
   <span class="k">def</span> <span class="nf">run_script</span><span class="p">(</span><span class="n">commands</span><span class="p">)</span>
     <span class="n">raw_output</span> <span class="o">=</span> <span class="kp">nil</span>
<span class="o">-</span>    <span class="no">IO</span><span class="o">.</span><span class="n">popen</span><span class="p">(</span><span class="s2">&#34;./db&#34;</span><span class="p">,</span> <span class="s2">&#34;r+&#34;</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">pipe</span><span class="o">|</span>
<span class="o">+</span>    <span class="no">IO</span><span class="o">.</span><span class="n">popen</span><span class="p">(</span><span class="s2">&#34;./db test.db&#34;</span><span class="p">,</span> <span class="s2">&#34;r+&#34;</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">pipe</span><span class="o">|</span>
       <span class="n">commands</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">command</span><span class="o">|</span>
         <span class="n">pipe</span><span class="o">.</span><span class="n">puts</span> <span class="n">command</span>
       <span class="k">end</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">28</span><span class="p">,</span><span class="mi">6</span> <span class="o">+</span><span class="mi">32</span><span class="p">,</span><span class="mi">27</span> <span class="err">@@</span> <span class="n">describe</span> <span class="s1">&#39;database&#39;</span> <span class="k">do</span>
     <span class="o">]</span><span class="p">)</span>
   <span class="k">end</span>

<span class="o">+</span>  <span class="n">it</span> <span class="s1">&#39;keeps data after closing connection&#39;</span> <span class="k">do</span>
<span class="o">+</span>    <span class="n">result1</span> <span class="o">=</span> <span class="n">run_script</span><span class="p">(</span><span class="o">[</span>
<span class="o">+</span>      <span class="s2">&#34;insert 1 user1 person1@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s2">&#34;.exit&#34;</span><span class="p">,</span>
<span class="o">+</span>    <span class="o">]</span><span class="p">)</span>
<span class="o">+</span>    <span class="n">expect</span><span class="p">(</span><span class="n">result1</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">match_array</span><span class="p">(</span><span class="o">[</span>
<span class="o">+</span>      <span class="s2">&#34;db &gt; Executed.&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s2">&#34;db &gt; &#34;</span><span class="p">,</span>
<span class="o">+</span>    <span class="o">]</span><span class="p">)</span>
<span class="o">+</span>
<span class="o">+</span>    <span class="n">result2</span> <span class="o">=</span> <span class="n">run_script</span><span class="p">(</span><span class="o">[</span>
<span class="o">+</span>      <span class="s2">&#34;select&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s2">&#34;.exit&#34;</span><span class="p">,</span>
<span class="o">+</span>    <span class="o">]</span><span class="p">)</span>
<span class="o">+</span>    <span class="n">expect</span><span class="p">(</span><span class="n">result2</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">match_array</span><span class="p">(</span><span class="o">[</span>
<span class="o">+</span>      <span class="s2">&#34;db &gt; (1, user1, person1@example.com)&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s2">&#34;Executed.&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s2">&#34;db &gt; &#34;</span><span class="p">,</span>
<span class="o">+</span>    <span class="o">]</span><span class="p">)</span>
<span class="o">+</span>  <span class="k">end</span>
<span class="o">+</span>
   <span class="n">it</span> <span class="s1">&#39;prints error message when table is full&#39;</span> <span class="k">do</span>
     <span class="n">script</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">1401</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
       <span class="s2">&#34;insert </span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2"> user</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2"> person</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">@example.com&#34;</span>
</code></pre></div><h2 id="第六部分---游标抽象">第六部分 - 游标抽象</h2>
<p>这部分应该比上一部分要短。我们只是进行一些重构，以便更容易开始B-Tree的实现。</p>
<p>我们将添加一个<code>Cursor</code>对象，代表表中的位置。您可能想要使用游标进行的操作包括：</p>
<ul>
<li>在表的开头创建游标</li>
<li>在表的末尾创建游标</li>
<li>访问游标指向的行</li>
<li>将游标推进到下一行</li>
</ul>
<p>这些是我们现在要实现的行为。稍后，我们还想：</p>
<ul>
<li>删除游标指向的行</li>
<li>修改游标指向的行</li>
<li>在表中搜索给定ID，并创建指向该ID行的游标</li>
</ul>
<p>话不多说，这是<code>Cursor</code>类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">row_num</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">end_of_table</span><span class="p">;</span>  <span class="c1">// 表示最后一个元素之后的位置
</span><span class="c1"></span><span class="p">}</span> <span class="n">Cursor</span><span class="p">;</span>
</code></pre></div><p>在我们当前的表数据结构中，唯一需要用于在表中标识位置的是行号。</p>
<p>游标还具有对其所属表的引用（因此我们的游标函数可以只将游标作为参数）。</p>
<p>最后，它有一个名为<code>end_of_table</code>的布尔值。这样我们就可以表示表末尾的位置（这是我们可能要插入行的位置）。</p>
<p><code>table_start()</code>和<code>table_end()</code>创建新的游标：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">Cursor</span><span class="o">*</span> <span class="nf">table_start</span><span class="p">(</span><span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Cursor</span><span class="p">));</span>
  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">=</span> <span class="n">table</span><span class="p">;</span>
  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">row_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">end_of_table</span> <span class="o">=</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">cursor</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Cursor</span><span class="o">*</span> <span class="nf">table_end</span><span class="p">(</span><span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Cursor</span><span class="p">));</span>
  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">=</span> <span class="n">table</span><span class="p">;</span>
  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">row_num</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span><span class="p">;</span>
  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">end_of_table</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">cursor</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>我们的<code>row_slot()</code>函数将变为<code>cursor_value()</code>，它返回指向游标描述位置的指针：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span><span class="o">*</span> <span class="nf">cursor_value</span><span class="p">(</span><span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="n">row_num</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">row_num</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">page_num</span> <span class="o">=</span> <span class="n">row_num</span> <span class="o">/</span> <span class="n">ROWS_PER_PAGE</span><span class="p">;</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">page</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">page_num</span><span class="p">);</span>
  <span class="kt">uint32_t</span> <span class="n">row_offset</span> <span class="o">=</span> <span class="n">row_num</span> <span class="o">%</span> <span class="n">ROWS_PER_PAGE</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">byte_offset</span> <span class="o">=</span> <span class="n">row_offset</span> <span class="o">*</span> <span class="n">ROW_SIZE</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">page</span> <span class="o">+</span> <span class="n">byte_offset</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>在我们当前的表结构中推进游标就是简单地递增行号。在B-Tree中会更复杂一些。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">cursor_advance</span><span class="p">(</span><span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">row_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">row_num</span> <span class="o">&gt;=</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">end_of_table</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>最后，我们可以更改我们的“虚拟机”方法，以使用游标抽象。在插入行时，我们在表的末尾打开一个游标，写入该游标位置，然后关闭游标。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">Row</span><span class="o">*</span> <span class="n">row_to_insert</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">statement</span><span class="o">-&gt;</span><span class="n">row_to_insert</span><span class="p">);</span>
<span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span> <span class="o">=</span> <span class="n">table_end</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>

<span class="n">serialize_row</span><span class="p">(</span><span class="n">row_to_insert</span><span class="p">,</span> <span class="n">cursor_value</span><span class="p">(</span><span class="n">cursor</span><span class="p">));</span>
<span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

<span class="n">free</span><span class="p">(</span><span class="n">cursor</span><span class="p">);</span>

<span class="k">return</span> <span class="n">EXECUTE_SUCCESS</span><span class="p">;</span>
</code></pre></div><p>在选择表中的所有行时，我们在表的开头打开一个游标，打印行，然后将游标推进到下一行。重复直到达到表的末尾。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">ExecuteResult</span> <span class="nf">execute_select</span><span class="p">(</span><span class="n">Statement</span><span class="o">*</span> <span class="n">statement</span><span class="p">,</span> <span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span> <span class="o">=</span> <span class="n">table_start</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>

  <span class="n">Row</span> <span class="n">row</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">end_of_table</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">deserialize_row</span><span class="p">(</span><span class="n">cursor_value</span><span class="p">(</span><span class="n">cursor</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">row</span><span class="p">);</span>
    <span class="n">print_row</span><span class="p">(</span><span class="o">&amp;</span><span class="n">row</span><span class="p">);</span>
    <span class="n">cursor_advance</span><span class="p">(</span><span class="n">cursor</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">free</span><span class="p">(</span><span class="n">cursor</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">EXECUTE_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>好了，就是这样！就像我说的，这是一个更短的重构，应该有助于我们将表数据结构重写为B-Tree。<code>execute_select()</code>和<code>execute_insert()</code>可以完全通过游标与表进行交互，而不假设表的存储方式。</p>
<p>以下是本部分的完整差异：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gu">@@ -78,6 +78,13 @@ struct {
</span><span class="gu"></span> } Table;

<span class="gi">+typedef struct {
</span><span class="gi">+  Table* table;
</span><span class="gi">+  uint32_t row_num;
</span><span class="gi">+  bool end_of_table; // Indicates a position one past the last element
</span><span class="gi">+} Cursor;
</span><span class="gi">+
</span><span class="gi"></span> void print_row(Row* row) {
     printf(&#34;(%d, %s, %s)\n&#34;, row-&gt;id, row-&gt;username, row-&gt;email);
 }
<span class="gu">@@ -126,12 +133,38 @@ void* get_page(Pager* pager, uint32_t page_num) {
</span><span class="gu"></span>     return pager-&gt;pages[page_num];
 }

<span class="gd">-void* row_slot(Table* table, uint32_t row_num) {
</span><span class="gd">-  uint32_t page_num = row_num / ROWS_PER_PAGE;
</span><span class="gd">-  void *page = get_page(table-&gt;pager, page_num);
</span><span class="gd">-  uint32_t row_offset = row_num % ROWS_PER_PAGE;
</span><span class="gd">-  uint32_t byte_offset = row_offset * ROW_SIZE;
</span><span class="gd">-  return page + byte_offset;
</span><span class="gd"></span><span class="gi">+Cursor* table_start(Table* table) {
</span><span class="gi">+  Cursor* cursor = malloc(sizeof(Cursor));
</span><span class="gi">+  cursor-&gt;table = table;
</span><span class="gi">+  cursor-&gt;row_num = 0;
</span><span class="gi">+  cursor-&gt;end_of_table = (table-&gt;num_rows == 0);
</span><span class="gi">+
</span><span class="gi">+  return cursor;
</span><span class="gi">+}
</span><span class="gi">+
</span><span class="gi">+Cursor* table_end(Table* table) {
</span><span class="gi">+  Cursor* cursor = malloc(sizeof(Cursor));
</span><span class="gi">+  cursor-&gt;table = table;
</span><span class="gi">+  cursor-&gt;row_num = table-&gt;num_rows;
</span><span class="gi">+  cursor-&gt;end_of_table = true;
</span><span class="gi">+
</span><span class="gi">+  return cursor;
</span><span class="gi">+}
</span><span class="gi">+
</span><span class="gi">+void* cursor_value(Cursor* cursor) {
</span><span class="gi">+  uint32_t row_num = cursor-&gt;row_num;
</span><span class="gi">+  uint32_t page_num = row_num / ROWS_PER_PAGE;
</span><span class="gi">+  void *page = get_page(cursor-&gt;table-&gt;pager, page_num);
</span><span class="gi">+  uint32_t row_offset = row_num % ROWS_PER_PAGE;
</span><span class="gi">+  uint32_t byte_offset = row_offset * ROW_SIZE;
</span><span class="gi">+  return page + byte_offset;
</span><span class="gi">+}
</span><span class="gi">+
</span><span class="gi">+void cursor_advance(Cursor* cursor) {
</span><span class="gi">+  cursor-&gt;row_num += 1;
</span><span class="gi">+  if (cursor-&gt;row_num &gt;= cursor-&gt;table-&gt;num_rows) {
</span><span class="gi">+    cursor-&gt;end_of_table = true;
</span><span class="gi">+  }
</span><span class="gi"></span> }

 Pager* pager_open(const char* filename) {
<span class="gu">@@ -327,19 +360,28 @@ ExecuteResult execute_insert(Statement* statement, Table* table) {
</span><span class="gu"></span>     }

   Row* row_to_insert = &amp;(statement-&gt;row_to_insert);
<span class="gi">+  Cursor* cursor = table_end(table);
</span><span class="gi"></span>
<span class="gd">-  serialize_row(row_to_insert, row_slot(table, table-&gt;num_rows));
</span><span class="gd"></span><span class="gi">+  serialize_row(row_to_insert, cursor_value(cursor));
</span><span class="gi"></span>   table-&gt;num_rows += 1;

<span class="gi">+  free(cursor);
</span><span class="gi">+
</span><span class="gi"></span>   return EXECUTE_SUCCESS;
 }

 ExecuteResult execute_select(Statement* statement, Table* table) {
<span class="gi">+  Cursor* cursor = table_start(table);
</span><span class="gi">+
</span><span class="gi"></span>   Row row;
<span class="gd">-  for (uint32_t i = 0; i &lt; table-&gt;num_rows; i++) {
</span><span class="gd">-     deserialize_row(row_slot(table, i), &amp;row);
</span><span class="gd"></span><span class="gi">+  while (!(cursor-&gt;end_of_table)) {
</span><span class="gi">+     deserialize_row(cursor_value(cursor), &amp;row);
</span><span class="gi"></span>      print_row(&amp;row);
<span class="gi">+     cursor_advance(cursor);
</span><span class="gi"></span>   }
<span class="gi">+
</span><span class="gi">+  free(cursor);
</span><span class="gi">+
</span><span class="gi"></span>   return EXECUTE_SUCCESS;
 }
</code></pre></div><h2 id="第七部分---b-tree简介">第七部分 - B-Tree简介</h2>
<p>B-Tree是SQLite用于表示表和索引的数据结构，因此它是一个非常核心的概念。本文仅介绍数据结构，所以不包含任何代码。</p>
<p>为什么树是数据库中的好数据结构呢？</p>
<ul>
<li>搜索特定值快速（对数时间）</li>
<li>插入/删除已找到的值很快（重新平衡的大致常数时间）</li>
<li>遍历一系列值很快（不像哈希映射）</li>
</ul>
<p>B-Tree与二叉树不同（“B”可能代表发明者的名字，但也可能代表“平衡”）。这是一个示例B-Tree：</p>
<p><img src="https://cstack.github.io/db_tutorial/assets/images/B-tree.png" alt="示例B-Tree"></p>
<p>与二叉树不同，B-Tree中的每个节点可以有超过2个孩子。每个节点最多可以有m个孩子，其中m称为树的“阶”。为了保持树基本平衡，我们还说节点必须至少有m/2个孩子（向上取整）。</p>
<p>例外情况：</p>
<ul>
<li>叶节点没有孩子</li>
<li>根节点可以少于m个孩子，但必须至少有2个</li>
<li>如果根节点是叶节点（唯一的节点），则仍然没有孩子</li>
</ul>
<p>上面的图片展示了SQLite用于存储索引的B-Tree。为了存储表，SQLite使用了一种称为B+树的变体。</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">B-Tree</th>
<th style="text-align:left">B+ Tree</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">发音</td>
<td style="text-align:left">“Bee Tree”</td>
<td style="text-align:left">“Bee Plus Tree”</td>
</tr>
<tr>
<td style="text-align:left">用于存储</td>
<td style="text-align:left">索引</td>
<td style="text-align:left">表</td>
</tr>
<tr>
<td style="text-align:left">内部节点存储键</td>
<td style="text-align:left">是</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">内部节点存储值</td>
<td style="text-align:left">是</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">每个节点的孩子数</td>
<td style="text-align:left">较少</td>
<td style="text-align:left">较多</td>
</tr>
<tr>
<td style="text-align:left">内部节点与叶节点</td>
<td style="text-align:left">相同结构</td>
<td style="text-align:left">不同结构</td>
</tr>
</tbody>
</table>
<p>在我们开始实现索引之前，我将专门讨论B+树，但我会简称为B-Tree或btree。</p>
<p>具有孩子的节点称为“内部”节点。内部节点和叶节点的结构不同：</p>
<table>
<thead>
<tr>
<th style="text-align:left">对于一个阶为m的树…</th>
<th style="text-align:left">内部节点</th>
<th style="text-align:left">叶节点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">存储</td>
<td style="text-align:left">键和指向子节点的指针</td>
<td style="text-align:left">键和值</td>
</tr>
<tr>
<td style="text-align:left">键的数量</td>
<td style="text-align:left">最多m-1</td>
<td style="text-align:left">尽可能多的键</td>
</tr>
<tr>
<td style="text-align:left">指针的数量</td>
<td style="text-align:left">键的数量 + 1</td>
<td style="text-align:left">没有</td>
</tr>
<tr>
<td style="text-align:left">值的数量</td>
<td style="text-align:left">没有</td>
<td style="text-align:left">键的数量</td>
</tr>
<tr>
<td style="text-align:left">键的作用</td>
<td style="text-align:left">用于路由</td>
<td style="text-align:left">与值配对</td>
</tr>
<tr>
<td style="text-align:left">存储值？</td>
<td style="text-align:left">否</td>
<td style="text-align:left">是</td>
</tr>
</tbody>
</table>
<p>让我们通过示例来看看当向B-Tree插入元素时，B-Tree是如何增长的。为了保持简单，树将是阶为3的。这意味着：</p>
<ul>
<li>每个内部节点最多有3个孩子</li>
<li>每个内部节点最多有2个键</li>
<li>每个内部节点至少有2个孩子</li>
<li>每个内部节点至少有1个键</li>
</ul>
<p>空的B-Tree只有一个节点：根节点。根节点开始作为一个带有零个键/值对的叶节点：</p>
<p><img src="https://cstack.github.io/db_tutorial/assets/images/btree1.png" alt="空的btree"></p>
<p>如果我们插入一对键/值，它们将按排序顺序存储在叶节点中。</p>
<p><img src="https://cstack.github.io/db_tutorial/assets/images/btree2.png" alt="单节点btree"></p>
<p>假设叶节点的容量为两个键/值对。当我们插入另一个时，我们必须分裂叶节点并将一半的键/值对放入每个节点。这两个节点都成为新的内部节点的子节点，这个内部节点现在将成为根节点。</p>
<p><img src="https://cstack.github.io/db_tutorial/assets/images/btree3.png" alt="两级btree"></p>
<p>内部节点有1个键和2个指向子节点的指针。如果我们要查找小于或等于5的键，我们查找左侧子节点。如果我们要查找大于5的键，我们查找右侧子节点。</p>
<p>现在让我们插入键“2”。首先，我们查找如果它存在时它会在哪个叶节点，然后我们到达左侧叶节点。节点已满，所以我们分裂叶节点并在父节点中创建新条目。</p>
<p><img src="https://cstack.github.io/db_tutorial/assets/images/btree4.png" alt="四节点btree"></p>
<p>让我们继续添加键。18和21。我们到达必须再次分裂的点，但在父节点中没有足够的空间来放置另一个键/指针对。</p>
<p><img src="https://cstack.github.io/db_tutorial/assets/images/btree5.png" alt="内部节点没有空间"></p>
<p>解决方案是将根节点分裂为两个内部节点，</p>
<p>然后创建新的根节点作为它们的父节点。</p>
<p><img src="https://cstack.github.io/db_tutorial/assets/images/btree6.png" alt="三级btree"></p>
<p>树的深度仅在我们分裂根节点时增加。每个叶节点具有相同的深度和接近相同数量的键/值对，因此树保持平衡并快速搜索。</p>
<p>在我们实现这种数据结构之前，每个节点将对应一个页面。根节点将存在于页面0中。子指针将简单地是包含子节点的页面号。</p>
<p>下次，我们开始实现btree！</p>
<h2 id="第八部分---b-tree叶节点格式">第八部分 - B-Tree叶节点格式</h2>
<p>我们将表的格式从未排序的行数组更改为B-Tree。这是一个相当大的变化，需要多篇文章来实现。在本文结束时，我们将定义叶节点的布局，并支持将键/值对插入单个节点树中。但首先，让我们回顾一下切换到树结构的原因。</p>
<h3 id="替代表格式">替代表格式</h3>
<p>在当前格式中，每个页面仅存储行（没有元数据），因此它非常节省空间。插入也很快，因为我们只是追加到末尾。但是，只能通过扫描整个表来查找特定的行。如果我们想要删除一行，就必须通过移动其后的每一行来填充空洞。</p>
<p>如果我们将表存储为数组，但保持按id排序的行，则可以使用二分搜索来查找特定的id。然而，插入会很慢，因为我们必须移动很多行来腾出空间。</p>
<p>相反，我们选择使用树结构。树中的每个节点可以包含可变数量的行，因此我们必须在每个节点中存储一些信息来跟踪它包含的行数。此外，所有不存储任何行的内部节点的存储开销。换取一个更大的数据库文件，我们获得了快速插入、删除和查找。</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">未排序的行数组</th>
<th style="text-align:left">排序的行数组</th>
<th style="text-align:left">节点树</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">页面包含</td>
<td style="text-align:left">仅数据</td>
<td style="text-align:left">仅数据</td>
<td style="text-align:left">元数据、主键和数据</td>
</tr>
<tr>
<td style="text-align:left">每页行数</td>
<td style="text-align:left">更多</td>
<td style="text-align:left">更多</td>
<td style="text-align:left">更少</td>
</tr>
<tr>
<td style="text-align:left">插入</td>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">O(n)</td>
<td style="text-align:left">O(log(n))</td>
</tr>
<tr>
<td style="text-align:left">删除</td>
<td style="text-align:left">O(n)</td>
<td style="text-align:left">O(n)</td>
<td style="text-align:left">O(log(n))</td>
</tr>
<tr>
<td style="text-align:left">按id查找</td>
<td style="text-align:left">O(n)</td>
<td style="text-align:left">O(log(n))</td>
<td style="text-align:left">O(log(n))</td>
</tr>
</tbody>
</table>
<h3 id="节点头格式">节点头格式</h3>
<p>叶节点和内部节点具有不同的布局。让我们创建一个枚举来跟踪节点类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">NODE_INTERNAL</span><span class="p">,</span> <span class="n">NODE_LEAF</span> <span class="p">}</span> <span class="n">NodeType</span><span class="p">;</span>
</code></pre></div><p>每个节点将对应一个页面。内部节点将通过存储存储子节点的页面号来指向它们的子节点。btree会请求pager提供特定页面号，并从页面缓存中得到一个指针。页面按照页面号的顺序依次存储在数据库文件中。</p>
<p>节点需要在页面开头存储一些元数据。每个节点将存储其节点类型、是否为根节点以及其父节点的指针（以允许查找节点的兄弟节点）。我为每个头字段的大小和偏移定义了常量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span><span class="cm">/*
</span><span class="cm">+ * 公共节点头布局
</span><span class="cm">+ */</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">NODE_TYPE_SIZE</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint8_t</span><span class="p">);</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">NODE_TYPE_OFFSET</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">IS_ROOT_SIZE</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint8_t</span><span class="p">);</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">IS_ROOT_OFFSET</span> <span class="o">=</span> <span class="n">NODE_TYPE_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">PARENT_POINTER_SIZE</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">PARENT_POINTER_OFFSET</span> <span class="o">=</span> <span class="n">IS_ROOT_OFFSET</span> <span class="o">+</span> <span class="n">IS_ROOT_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">COMMON_NODE_HEADER_SIZE</span> <span class="o">=</span>
<span class="o">+</span>    <span class="n">NODE_TYPE_SIZE</span> <span class="o">+</span> <span class="n">IS_ROOT_SIZE</span> <span class="o">+</span> <span class="n">PARENT_POINTER_SIZE</span><span class="p">;</span>
</code></pre></div><h3 id="叶节点格式">叶节点格式</h3>
<p>除了这些常见的头字段之外，叶节点需要存储它们包含多少个“单元”。单元是一个键/值对。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span><span class="cm">/*
</span><span class="cm">+ * 叶节点头布局
</span><span class="cm">+ */</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LEAF_NODE_NUM_CELLS_SIZE</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LEAF_NODE_NUM_CELLS_OFFSET</span> <span class="o">=</span> <span class="n">COMMON_NODE_HEADER_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LEAF_NODE_HEADER_SIZE</span> <span class="o">=</span>
<span class="o">+</span>    <span class="n">COMMON_NODE_HEADER_SIZE</span> <span class="o">+</span> <span class="n">LEAF_NODE_NUM_CELLS_SIZE</span><span class="p">;</span>
</code></pre></div><p>叶节点的主体是一个单元数组。每个单元都是一个键，后跟一个值（一个序列化的行）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span><span class="cm">/*
</span><span class="cm">+ * 叶节点主体布局
</span><span class="cm">+ */</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LEAF_NODE_KEY_SIZE</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LEAF_NODE_KEY_OFFSET</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LEAF_NODE_VALUE_SIZE</span> <span class="o">=</span> <span class="n">ROW_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LEAF_NODE_VALUE_OFFSET</span> <span class="o">=</span>
<span class="o">+</span>    <span class="n">LEAF_NODE_KEY_OFFSET</span> <span class="o">+</span> <span class="n">LEAF_NODE_KEY_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LEAF_NODE_CELL_SIZE</span> <span class="o">=</span> <span class="n">LEAF_NODE_KEY_SIZE</span> <span class="o">+</span> <span class="n">LEAF_NODE_VALUE_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LEAF_NODE_SPACE_FOR_CELLS</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">LEAF_NODE_HEADER_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LEAF_NODE_MAX_CELLS</span> <span class="o">=</span>
<span class="o">+</span>    <span class="n">LEAF_NODE_SPACE_FOR_CELLS</span> <span class="o">/</span> <span class="n">LEAF_NODE_CELL_SIZE</span><span class="p">;</span>
</code></pre></div><p>根据这些常量，当前叶节点的布局如下：</p>
<p><img src="https://cstack.github.io/db_tutorial/assets/images/leaf-node-format.png" alt="我们的叶节点格式"></p>
<p>在头部每个布尔值使用一个完整的字节有些浪费空间，但这样可以更轻松地编写访问这些值的代码。</p>
<p>还要注意，末尾有一些空白空间。我们在头部之后存储尽可能多的单元，但剩余的空间无法容纳整个单元。我们将其留空以避免在节点之间分割单元。</p>
<h3 id="访问叶节点字段">访问叶节点字段</h3>
<p>访问叶节点字段的代码都涉及使用我们刚刚定义的常量进行指针算术。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="k">return</span> <span class="n">node</span> <span class="o">+</span> <span class="n">LEAF_NODE_NUM_CELLS_OFFSET</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span><span class="kt">void</span><span class="o">*</span> <span class="n">leaf_node_cell</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">cell_num</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="k">return</span> <span class="n">node</span> <span class="o">+</span> <span class="n">LEAF_NODE_HEADER_SIZE</span> <span class="o">+</span> <span class="n">cell_num</span> <span class="o">*</span> <span class="n">LEAF_NODE_CELL_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="n">leaf_node_key</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">cell_num</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="k">return</span> <span class="n">leaf_node_cell</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cell_num</span><span class="p">);</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span><span class="kt">void</span><span class="o">*</span> <span class="n">leaf_node_value</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">cell_num</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="k">return</span> <span class="n">leaf_node_cell</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cell_num</span><span class="p">)</span> <span class="o">+</span> <span class="n">LEAF_NODE_KEY_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span><span class="kt">void</span> <span class="n">initialize_leaf_node</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span> <span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div><p>这些方法返回所需值的指针，因此可以用作getter和setter。</p>
<h3 id="pager和table对象的更改">Pager和Table对象的更改</h3>
<p>每个节点将占用一个完整的页面，即使它并未填满该页面。这意味着我们的pager不再需要支持读取/写入部分页面。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">-</span><span class="kt">void</span> <span class="n">pager_flush</span><span class="p">(</span><span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">page_num</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span><span class="kt">void</span> <span class="n">pager_flush</span><span class="p">(</span><span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">page_num</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Tried to flush null page</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
     <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">242</span><span class="p">,</span><span class="mi">7</span> <span class="o">+</span><span class="mi">337</span><span class="p">,</span><span class="mi">7</span> <span class="err">@@</span> <span class="kt">void</span> <span class="n">pager_flush</span><span class="p">(</span><span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">page_num</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
   <span class="p">}</span>
 
   <span class="n">ssize_t</span> <span class="n">bytes_written</span> <span class="o">=</span>
<span class="o">-</span>      <span class="n">write</span><span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">file_descriptor</span><span class="p">,</span> <span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">],</span> <span class="n">size</span><span class="p">);</span>
<span class="o">+</span>      <span class="n">write</span><span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">file_descriptor</span><span class="p">,</span> <span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">],</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
 
   <span class="k">if</span> <span class="p">(</span><span class="n">bytes_written</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error writing: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">errno</span><span class="p">);</span>
 <span class="kt">void</span> <span class="nf">db_close</span><span class="p">(</span><span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">;</span>
<span class="o">-</span>  <span class="kt">uint32_t</span> <span class="n">num_full_pages</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">/</span> <span class="n">ROWS_PER_PAGE</span><span class="p">;</span>
 
<span class="o">-</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_full_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pager</span><span class="o">-&gt;</span><span class="n">num_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
       <span class="k">continue</span><span class="p">;</span>
     <span class="p">}</span>
<span class="o">-</span>    <span class="n">pager_flush</span><span class="p">(</span><span class="n">pager</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">pager_flush</span><span class="p">(</span><span class="n">pager</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
     <span class="n">free</span><span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
     <span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
   <span class="p">}</span>
 
<span class="o">-</span>  <span class="c1">// There may be a partial page to write to the end of the file
</span><span class="c1"></span><span class="o">-</span>  <span class="c1">// This should not be needed after we switch to a B-tree
</span><span class="c1"></span><span class="o">-</span>  <span class="kt">uint32_t</span> <span class="n">num_additional_rows</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">%</span> <span class="n">ROWS_PER_PAGE</span><span class="p">;</span>
<span class="o">-</span>  <span class="k">if</span> <span class="p">(</span><span class="n">num_additional_rows</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="o">-</span>    <span class="kt">uint32_t</span> <span class="n">page_num</span> <span class="o">=</span> <span class="n">num_full_pages</span><span class="p">;</span>
<span class="o">-</span>    <span class="k">if</span> <span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
<span class="o">-</span>      <span class="n">pager_flush</span><span class="p">(</span><span class="n">pager</span><span class="p">,</span> <span class="n">page_num</span><span class="p">,</span> <span class="n">num_additional_rows</span> <span class="o">*</span> <span class="n">ROW_SIZE</span><span class="p">);</span>
<span class="o">-</span>      <span class="n">free</span><span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">]);</span>
<span class="o">-</span>      <span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="o">-</span>    <span class="p">}</span>
<span class="o">-</span>  <span class="p">}</span>
<span class="o">-</span>
   <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">close</span><span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">file_descriptor</span><span class="p">);</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error closing db file.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</code></pre></div><p>现在，在数据库中存储页面的数量比存储行数更有意义。页面的数量应该与pager对象相关联，而不是与表相关联，因为它是数据库使用的页面数量，而不是特定表的数量。B树由其根节点页面号标识，因此表对象需要跟踪它。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"> <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">PAGE_SIZE</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
 <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">TABLE_MAX_PAGES</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="o">-</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">ROWS_PER_PAGE</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="n">ROW_SIZE</span><span class="p">;</span>
<span class="o">-</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">TABLE_MAX_ROWS</span> <span class="o">=</span> <span class="n">ROWS_PER_PAGE</span> <span class="o">*</span> <span class="n">TABLE_MAX_PAGES</span><span class="p">;</span>
 
 <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">file_descriptor</span><span class="p">;</span>
   <span class="kt">uint32_t</span> <span class="n">file_length</span><span class="p">;</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">num_pages</span><span class="p">;</span>
   <span class="kt">void</span><span class="o">*</span> <span class="n">pages</span><span class="p">[</span><span class="n">TABLE_MAX_PAGES</span><span class="p">];</span>
 <span class="p">}</span> <span class="n">Pager</span><span class="p">;</span>
 
 <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
   <span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span><span class="p">;</span>
<span class="o">-</span>  <span class="kt">uint32_t</span> <span class="n">num_rows</span><span class="p">;</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">root_page_num</span><span class="p">;</span>
 <span class="p">}</span> <span class="n">Table</span><span class="p">;</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">127</span><span class="p">,</span><span class="mi">6</span> <span class="o">+</span><span class="mi">200</span><span class="p">,</span><span class="mi">10</span> <span class="err">@@</span> <span class="kt">void</span><span class="o">*</span> <span class="n">get_page</span><span class="p">(</span><span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">page_num</span><span class="p">)</span> <span class="p">{</span>
     <span class="p">}</span>
 
     <span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span>    <span class="k">if</span> <span class="p">(</span><span class="n">page_num</span> <span class="o">&gt;=</span> <span class="n">pager</span><span class="o">-&gt;</span><span class="n">num_pages</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>      <span class="n">pager</span><span class="o">-&gt;</span><span class="n">num_pages</span> <span class="o">=</span> <span class="n">page_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="o">+</span>    <span class="p">}</span>
   <span class="p">}</span>
 
   <span class="k">return</span> <span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">];</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">184</span><span class="p">,</span><span class="mi">6</span> <span class="o">+</span><span class="mi">269</span><span class="p">,</span><span class="mi">12</span> <span class="err">@@</span> <span class="n">Pager</span><span class="o">*</span> <span class="n">pager_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Pager</span><span class="p">));</span>
   <span class="n">pager</span><span class="o">-&gt;</span><span class="n">file_descriptor</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
   <span class="n">pager</span><span class="o">-&gt;</span><span class="n">file_length</span> <span class="o">=</span> <span class="n">file_length</span><span class="p">;</span>
<span class="o">+</span>  <span class="n">pager</span><span class="o">-&gt;</span><span class="n">num_pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">file_length</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">file_length</span> <span class="o">%</span> <span class="n">PAGE_SIZE</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Db file is not a whole number of pages. Corrupt file.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span>
 
   <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TABLE_MAX_PAGES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</code></pre></div><h3 id="cursor对象的更改">Cursor对象的更改</h3>
<p>游标表示表中的位置。当我们的表是一个简单的行数组时，我们可以根据行号访问行。现在它是一个树结构，我们通过节点的页面号和该节点中的单元号来标识一个位置。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"> <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
   <span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">;</span>
<span class="o">-</span>  <span class="kt">uint32_t</span> <span class="n">row_num</span><span class="p">;</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">page_num</span><span class="p">;</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">cell_num</span><span class="p">;</span>
   <span class="kt">bool</span> <span class="n">end_of_table</span><span class="p">;</span>  <span class="c1">// Indicates a position one past the last element
</span><span class="c1"></span> <span class="p">}</span> <span class="n">Cursor</span><span class="p">;</span>
 <span class="n">Cursor</span><span class="o">*</span> <span class="nf">table_start</span><span class="p">(</span><span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Cursor</span><span class="p">));</span>
   <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">=</span> <span class="n">table</span><span class="p">;</span>
<span class="o">-</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">row_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">-</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">end_of_table</span> <span class="o">=</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">page_num</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">root_page_num</span><span class="p">;</span>
<span class="o">+</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">cell_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="kt">void</span><span class="o">*</span> <span class="n">root_node</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">root_page_num</span><span class="p">);</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">num_cells</span> <span class="o">=</span> <span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">root_node</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">end_of_table</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_cells</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
 
   <span class="k">return</span> <span class="n">cursor</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="n">Cursor</span><span class="o">*</span> <span class="nf">table_end</span><span class="p">(</span><span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Cursor</span><span class="p">));</span>
   <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">=</span> <span class="n">table</span><span class="p">;</span>
<span class="o">-</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">row_num</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span><span class="p">;</span>
<span class="o">+</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">page_num</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">root_page_num</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="kt">void</span><span class="o">*</span> <span class="n">root_node</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">root_page_num</span><span class="p">);</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">num_cells</span> <span class="o">=</span> <span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">root_node</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">cell_num</span> <span class="o">=</span> <span class="n">num_cells</span><span class="p">;</span>
   <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">end_of_table</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
 
   <span class="k">return</span> <span class="n">cursor</span><span class="p">;</span>
 <span class="p">}</span>
 <span class="kt">void</span><span class="o">*</span> <span class="nf">cursor_value</span><span class="p">(</span><span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span>

<span class="p">)</span> <span class="p">{</span>
<span class="o">-</span>  <span class="kt">uint32_t</span> <span class="n">row_num</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">row_num</span><span class="p">;</span>
<span class="o">-</span>  <span class="kt">uint32_t</span> <span class="n">page_num</span> <span class="o">=</span> <span class="n">row_num</span> <span class="o">/</span> <span class="n">ROWS_PER_PAGE</span><span class="p">;</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">page_num</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">page_num</span><span class="p">;</span>
   <span class="kt">void</span><span class="o">*</span> <span class="n">page</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">page_num</span><span class="p">);</span>
<span class="o">-</span>  <span class="kt">uint32_t</span> <span class="n">row_offset</span> <span class="o">=</span> <span class="n">row_num</span> <span class="o">%</span> <span class="n">ROWS_PER_PAGE</span><span class="p">;</span>
<span class="o">-</span>  <span class="kt">uint32_t</span> <span class="n">byte_offset</span> <span class="o">=</span> <span class="n">row_offset</span> <span class="o">*</span> <span class="n">ROW_SIZE</span><span class="p">;</span>
<span class="o">-</span>  <span class="k">return</span> <span class="n">page</span> <span class="o">+</span> <span class="n">byte_offset</span><span class="p">;</span>
<span class="o">+</span>  <span class="k">return</span> <span class="n">leaf_node_value</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">cell_num</span><span class="p">);</span>
 <span class="p">}</span>
 <span class="kt">void</span> <span class="nf">cursor_advance</span><span class="p">(</span><span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span><span class="p">)</span> <span class="p">{</span>
<span class="o">-</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">row_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="o">-</span>  <span class="k">if</span> <span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">row_num</span> <span class="o">&gt;=</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">page_num</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">page_num</span><span class="p">;</span>
<span class="o">+</span>  <span class="kt">void</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">page_num</span><span class="p">);</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">cell_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">cell_num</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">node</span><span class="p">)))</span> <span class="p">{</span>
     <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">end_of_table</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
   <span class="p">}</span>
 <span class="p">}</span>
</code></pre></div><p>希望这些更改能够帮助你理解和更新代码以支持B-Tree格式的数据库。</p>
<h3 id="向叶节点插入数据">向叶节点插入数据</h3>
<p>在本文中，我们只实现了足够实现单节点树的内容。回顾上一篇文章，树从一个空的叶节点开始：</p>
<p><img src="https://cstack.github.io/db_tutorial/assets/images/btree1.png" alt="empty btree"></p>
<p>可以添加键/值对，直到叶节点已满：</p>
<p><img src="https://cstack.github.io/db_tutorial/assets/images/btree2.png" alt="one-node btree"></p>
<p>当我们首次打开数据库时，数据库文件将为空，因此我们将页面 0 初始化为空的叶节点（根节点）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"> <span class="n">Table</span><span class="o">*</span> <span class="nf">db_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span> <span class="o">=</span> <span class="n">pager_open</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
<span class="o">-</span>  <span class="kt">uint32_t</span> <span class="n">num_rows</span> <span class="o">=</span> <span class="n">pager</span><span class="o">-&gt;</span><span class="n">file_length</span> <span class="o">/</span> <span class="n">ROW_SIZE</span><span class="p">;</span>
 
   <span class="n">Table</span><span class="o">*</span> <span class="n">table</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Table</span><span class="p">));</span>
   <span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span> <span class="o">=</span> <span class="n">pager</span><span class="p">;</span>
<span class="o">-</span>  <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">=</span> <span class="n">num_rows</span><span class="p">;</span>
<span class="o">+</span>  <span class="n">table</span><span class="o">-&gt;</span><span class="n">root_page_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">num_pages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="c1">// 新的数据库文件。将页面 0 初始化为叶节点。
</span><span class="c1"></span><span class="o">+</span>    <span class="kt">void</span><span class="o">*</span> <span class="n">root_node</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">pager</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">initialize_leaf_node</span><span class="p">(</span><span class="n">root_node</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span>
 
   <span class="k">return</span> <span class="n">table</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div><p>接下来，我们将创建一个函数，用于将键/值对插入到叶节点。它将接受一个光标作为输入，表示应将该对插入的位置。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span><span class="kt">void</span> <span class="n">leaf_node_insert</span><span class="p">(</span><span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">key</span><span class="p">,</span> <span class="n">Row</span><span class="o">*</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="kt">void</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">page_num</span><span class="p">);</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">num_cells</span> <span class="o">=</span> <span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">num_cells</span> <span class="o">&gt;=</span> <span class="n">LEAF_NODE_MAX_CELLS</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="c1">// 节点已满
</span><span class="c1"></span><span class="o">+</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Need to implement splitting a leaf node.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">cell_num</span> <span class="o">&lt;</span> <span class="n">num_cells</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="c1">// 为新单元格腾出空间
</span><span class="c1"></span><span class="o">+</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">num_cells</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">cell_num</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>      <span class="n">memcpy</span><span class="p">(</span><span class="n">leaf_node_cell</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">leaf_node_cell</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
<span class="o">+</span>             <span class="n">LEAF_NODE_CELL_SIZE</span><span class="p">);</span>
<span class="o">+</span>    <span class="p">}</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="o">*</span><span class="p">(</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="o">+</span>  <span class="o">*</span><span class="p">(</span><span class="n">leaf_node_key</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">cell_num</span><span class="p">))</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
<span class="o">+</span>  <span class="n">serialize_row</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">leaf_node_value</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">cell_num</span><span class="p">));</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
</code></pre></div><p>我们还没有实现分裂，所以如果节点已满，我们会报错。接下来，我们将单元格右移一个位置，以腾出新单元格的空间。然后，我们将新的键/值对写入到空白的位置。</p>
<p>由于我们假设树只有一个节点，因此 <code>execute_insert()</code> 函数只需要调用这个辅助方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"> <span class="n">ExecuteResult</span> <span class="nf">execute_insert</span><span class="p">(</span><span class="n">Statement</span><span class="o">*</span> <span class="n">statement</span><span class="p">,</span> <span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
<span class="o">-</span>  <span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">&gt;=</span> <span class="n">TABLE_MAX_ROWS</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="kt">void</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">root_page_num</span><span class="p">);</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">LEAF_NODE_MAX_CELLS</span><span class="p">))</span> <span class="p">{</span>
     <span class="k">return</span> <span class="n">EXECUTE_TABLE_FULL</span><span class="p">;</span>
   <span class="p">}</span>
 
   <span class="n">Row</span><span class="o">*</span> <span class="n">row_to_insert</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">statement</span><span class="o">-&gt;</span><span class="n">row_to_insert</span><span class="p">);</span>
   <span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span> <span class="o">=</span> <span class="n">table_end</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
 
<span class="o">-</span>  <span class="n">serialize_row</span><span class="p">(</span><span class="n">row_to_insert</span><span class="p">,</span> <span class="n">cursor_value</span><span class="p">(</span><span class="n">cursor</span><span class="p">));</span>
<span class="o">-</span>  <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="o">+</span>  <span class="n">leaf_node_insert</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">row_to_insert</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">row_to_insert</span><span class="p">);</span>
 
   <span class="n">free</span><span class="p">(</span><span class="n">cursor</span><span class="p">);</span>
</code></pre></div><p>通过这些更改，我们的数据库应该像以前一样工作！但是现在会更早地返回“表已满”错误，因为我们尚不能分裂根节点。</p>
<p>叶节点能够容纳多少行？</p>
<h3 id="打印常量的命令">打印常量的命令</h3>
<p>我添加了一个新的元命令，以打印一些感兴趣的常量。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span><span class="kt">void</span> <span class="n">print_constants</span><span class="p">()</span> <span class="p">{</span>
<span class="o">+</span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;ROW_SIZE: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ROW_SIZE</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;COMMON_NODE_HEADER_SIZE: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">COMMON_NODE_HEADER_SIZE</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;LEAF_NODE_HEADER_SIZE: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">LEAF_NODE_HEADER_SIZE</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;LEAF_NODE_CELL_SIZE: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">LEAF_NODE_CELL_SIZE</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;LEAF_NODE_SPACE_FOR_CELLS: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">LEAF_NODE_SPACE_FOR_CELLS</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;LEAF_NODE_MAX_CELLS: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">LEAF_NODE_MAX_CELLS</span><span class="p">);</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">294</span><span class="p">,</span><span class="mi">6</span> <span class="o">+</span><span class="mi">376</span><span class="p">,</span><span class="mi">14</span> <span class="err">@@</span> <span class="n">MetaCommandResult</span> <span class="n">do_meta_command</span><span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span><span class="p">,</span> <span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;.exit&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">db_close</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
     <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;.constants&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Constants:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">print_constants</span><span class="p">();</span>
<span class="o">+</span>    <span class="k">return</span> <span class="n">META_COMMAND_SUCCESS</span><span class="p">;</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
     <span class="k">return</span> <span class="n">META_COMMAND_UNRECOGNIZED_COMMAND</span><span class="p">;</span>
   <span class="p">}</span>
</code></pre></div><p>我还添加了一个测试，以便在这些常量发生变化时通知我们：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span>  <span class="n">it</span> <span class="err">&#39;</span><span class="n">prints</span> <span class="n">constants</span><span class="err">&#39;</span> <span class="k">do</span>
<span class="o">+</span>    <span class="n">script</span> <span class="o">=</span> <span class="p">[</span>
<span class="o">+</span>      <span class="s">&#34;.constants&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;.exit&#34;</span><span class="p">,</span>
<span class="o">+</span>    <span class="p">]</span>
<span class="o">+</span>    <span class="n">result</span> <span class="o">=</span> <span class="n">run_script</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
<span class="o">+</span>
<span class="o">+</span>    <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">).</span><span class="n">to</span> <span class="n">match_array</span><span class="p">([</span>
<span class="o">+</span>      <span class="s">&#34;db &gt; Constants:&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;ROW_SIZE: 293&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;COMMON_NODE_HEADER_SIZE: 6&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;LEAF_NODE_HEADER_SIZE: 10&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;LEAF_NODE_CELL_SIZE: 297&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;LEAF_NODE_SPACE_FOR_CELLS: 4086&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;LEAF_NODE_MAX_CELLS: 13&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;db &gt; &#34;</span><span class="p">,</span>
<span class="o">+</span>    <span class="p">])</span>
<span class="o">+</span>  <span class="n">end</span>
</code></pre></div><p>所以我们的表目前可以容纳 13 行！</p>
<h2 id="树的可视化">树的可视化</h2>
<p>为了帮助调试和可视化，我还添加了一个元命令来打印 b 树的表示。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span><span class="kt">void</span> <span class="n">print_leaf_node</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">num_cells</span> <span class="o">=</span> <span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;leaf (size %d)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">num_cells</span><span class="p">);</span>
<span class="o">+</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_cells</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="kt">uint32_t</span> <span class="n">key</span> <span class="o">=</span> <span class="o">*</span><span class="n">leaf_node_key</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;  - %d : %d</span><span class="se">\n</span>

<span class="s">&#34;, i, key);</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">294</span><span class="p">,</span><span class="mi">6</span> <span class="o">+</span><span class="mi">376</span><span class="p">,</span><span class="mi">14</span> <span class="err">@@</span> <span class="n">MetaCommandResult</span> <span class="n">do_meta_command</span><span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span><span class="p">,</span> <span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;.exit&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">db_close</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
     <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;.btree&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Tree:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">print_leaf_node</span><span class="p">(</span><span class="n">get_page</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="o">+</span>    <span class="k">return</span> <span class="n">META_COMMAND_SUCCESS</span><span class="p">;</span>
   <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;.constants&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Constants:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
     <span class="n">print_constants</span><span class="p">();</span>
     <span class="k">return</span> <span class="n">META_COMMAND_SUCCESS</span><span class="p">;</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
     <span class="k">return</span> <span class="n">META_COMMAND_UNRECOGNIZED_COMMAND</span><span class="p">;</span>
   <span class="p">}</span>
</code></pre></div><p>还有一个测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span>  <span class="n">it</span> <span class="err">&#39;</span><span class="n">allows</span> <span class="n">printing</span> <span class="n">out</span> <span class="n">the</span> <span class="n">structure</span> <span class="n">of</span> <span class="n">a</span> <span class="n">one</span><span class="o">-</span><span class="n">node</span> <span class="n">btree</span><span class="err">&#39;</span> <span class="k">do</span>
<span class="o">+</span>    <span class="n">script</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">].</span><span class="n">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
<span class="o">+</span>      <span class="s">&#34;insert #{i} user#{i} person#{i}@example.com&#34;</span>
<span class="o">+</span>    <span class="n">end</span>
<span class="o">+</span>    <span class="n">script</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;.btree&#34;</span>
<span class="o">+</span>    <span class="n">script</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;.exit&#34;</span>
<span class="o">+</span>    <span class="n">result</span> <span class="o">=</span> <span class="n">run_script</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
<span class="o">+</span>
<span class="o">+</span>    <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">).</span><span class="n">to</span> <span class="n">match_array</span><span class="p">([</span>
<span class="o">+</span>      <span class="s">&#34;db &gt; Executed.&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;db &gt; Executed.&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;db &gt; Executed.&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;db &gt; Tree:&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;leaf (size 3)&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;  - 0 : 3&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;  - 1 : 1&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;  - 2 : 2&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;db &gt; &#34;</span>
<span class="o">+</span>    <span class="p">])</span>
<span class="o">+</span>  <span class="n">end</span>
</code></pre></div><p>哦，糟糕，我们仍然没有按顺序存储行。你会注意到 <code>execute_insert()</code> 在叶节点中插入的位置是由 <code>table_end()</code> 返回的位置。因此，行是按照插入的顺序存储的，就像以前一样。</p>
<h3 id="下一步计划">下一步计划</h3>
<p>这可能看起来像是一种倒退。我们的数据库现在存储的行数比以前少了，而且我们仍然按照无序的方式存储行。但就像我在开始时所说的，这是一个重大的改变，重要的是将其分解成可管理的步骤。</p>
<p>接下来，我们将实现按主键查找记录，并开始按顺序存储行。</p>
<h3 id="完整的代码变更">完整的代码变更</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="err">@@</span> <span class="o">-</span><span class="mi">62</span><span class="p">,</span><span class="mi">29</span> <span class="o">+</span><span class="mi">62</span><span class="p">,</span><span class="mi">101</span> <span class="err">@@</span> <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">ROW_SIZE</span> <span class="o">=</span> <span class="n">ID_SIZE</span> <span class="o">+</span> <span class="n">USERNAME_SIZE</span> <span class="o">+</span> <span class="n">EMAIL_SIZE</span><span class="p">;</span>

 <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">PAGE_SIZE</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
 <span class="cp">#define TABLE_MAX_PAGES 100
</span><span class="cp"></span><span class="o">-</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">ROWS_PER_PAGE</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="n">ROW_SIZE</span><span class="p">;</span>
<span class="o">-</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">TABLE_MAX_ROWS</span> <span class="o">=</span> <span class="n">ROWS_PER_PAGE</span> <span class="o">*</span> <span class="n">TABLE_MAX_PAGES</span><span class="p">;</span>
 
 <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">file_descriptor</span><span class="p">;</span>
   <span class="kt">uint32_t</span> <span class="n">file_length</span><span class="p">;</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">num_pages</span><span class="p">;</span>
   <span class="kt">void</span><span class="o">*</span> <span class="n">pages</span><span class="p">[</span><span class="n">TABLE_MAX_PAGES</span><span class="p">];</span>
 <span class="p">}</span> <span class="n">Pager</span><span class="p">;</span>
 
 <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
   <span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span><span class="p">;</span>
<span class="o">-</span>  <span class="kt">uint32_t</span> <span class="n">num_rows</span><span class="p">;</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">root_page_num</span><span class="p">;</span>
 <span class="p">}</span> <span class="n">Table</span><span class="p">;</span>
 
 <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
   <span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">;</span>
<span class="o">-</span>  <span class="kt">uint32_t</span> <span class="n">row_num</span><span class="p">;</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">page_num</span><span class="p">;</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">cell_num</span><span class="p">;</span>
   <span class="kt">bool</span> <span class="n">end_of_table</span><span class="p">;</span>  <span class="c1">// Indicates a position one past the last element
</span><span class="c1"></span> <span class="p">}</span> <span class="n">Cursor</span><span class="p">;</span>

<span class="o">+</span><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">NODE_INTERNAL</span><span class="p">,</span> <span class="n">NODE_LEAF</span> <span class="p">}</span> <span class="n">NodeType</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span><span class="cm">/*
</span><span class="cm">+ * Common Node Header Layout
</span><span class="cm">+ */</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">NODE_TYPE_SIZE</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint8_t</span><span class="p">);</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">NODE_TYPE_OFFSET</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">IS_ROOT_SIZE</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint8_t</span><span class="p">);</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">IS_ROOT_OFFSET</span> <span class="o">=</span> <span class="n">NODE_TYPE_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">PARENT_POINTER_SIZE</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">PARENT_POINTER_OFFSET</span> <span class="o">=</span> <span class="n">IS_ROOT_OFFSET</span> <span class="o">+</span> <span class="n">IS_ROOT_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">COMMON_NODE_HEADER_SIZE</span> <span class="o">=</span>
<span class="o">+</span>    <span class="n">NODE_TYPE_SIZE</span> <span class="o">+</span> <span class="n">IS_ROOT_SIZE</span> <span class="o">+</span> <span class="n">PARENT_POINTER_SIZE</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span><span class="cm">/*
</span><span class="cm">+ * Leaf Node Header Layout
</span><span class="cm">+ */</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LEAF_NODE_NUM_CELLS_SIZE</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LEAF_NODE_NUM_CELLS_OFFSET</span> <span class="o">=</span> <span class="n">COMMON_NODE_HEADER_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LEAF_NODE_HEADER_SIZE</span> <span class="o">=</span>
<span class="o">+</span>    <span class="n">COMMON_NODE_HEADER_SIZE</span> <span class="o">+</span> <span class="n">LEAF_NODE_NUM_CELLS_SIZE</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span><span class="cm">/*
</span><span class="cm">+ * Leaf Node Body Layout
</span><span class="cm">+ */</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LEAF_NODE_KEY_SIZE</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LEAF_NODE_KEY_OFFSET</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LEAF_NODE_VALUE_SIZE</span> <span class="o">=</span> <span class="n">ROW_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LEAF_NODE_VALUE_OFFSET</span> <span class="o">=</span>
<span class="o">+</span>    <span class="n">LEAF_NODE_KEY_OFFSET</span> <span class="o">+</span> <span class="n">LEAF_NODE_KEY_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LEAF_NODE_CELL_SIZE</span> <span class="o">=</span> <span class="n">LEAF_NODE_KEY_SIZE</span> <span class="o">+</span> <span class="n">LEAF_NODE_VALUE_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LEAF_NODE_SPACE_FOR_CELLS</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">LEAF_NODE_HEADER_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LEAF_NODE_MAX_CELLS</span> <span class="o">=</span>
<span class="o">+</span>    <span class="n">LEAF_NODE_SPACE_FOR_CELLS</span> <span class="o">/</span> <span class="n">LEAF_NODE_CELL_SIZE</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="k">return</span> <span class="n">node</span> <span class="o">+</span> <span class="n">LEAF_NODE_NUM_CELLS_OFFSET</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span><span class="kt">void</span><span class="o">*</span> <span class="n">leaf_node_cell</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">cell_num</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="k">return</span> <span class="n">node</span> <span class="o">+</span> <span class="n">LEAF_NODE_HEADER_SIZE</span> <span class="o">+</span> <span class="n">cell_num</span> <span class="o">*</span> <span class="n">LEAF_NODE_CELL_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="n">leaf_node_key</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">cell_num</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="k">return</span> <span class="n">leaf_node_cell</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cell_num</span><span class="p">);</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span><span class="kt">void</span><span class="o">*</span> <span class="n">leaf_node_value</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">cell_num</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="k">return</span> <span class="n">leaf_node_cell</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cell_num</span><span class="p">)</span> <span class="o">+</span> <span class="n">LEAF_NODE_KEY_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span><span class="kt">void</span> <span class="n">print_constants</span><span class="p">()</span> <span class="p">{</span>
<span class="o">+</span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;ROW_SIZE: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ROW_SIZE</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;COMMON_NODE_HEADER_SIZE: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">COMMON_NODE_HEADER_SIZE</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;LEAF_NODE_HEADER_SIZE: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">LEAF_NODE_HEADER_SIZE</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;LEAF_NODE_CELL_SIZE: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">LEAF_NODE_CELL_SIZE</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;LEAF_NODE_SPACE_FOR_CELLS: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">LEAF_NODE_SPACE_FOR_CELLS</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;LEAF_NODE_MAX_CELLS: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">LEAF_NODE_MAX_CELLS</span><span class="p">);</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span><span class="kt">void</span> <span class="n">print_leaf_node</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">num_cells</span> <span class="o">=</span> <span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;leaf (size %d)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">num_cells</span><span class="p">);</span>
<span class="o">+</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_cells</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="kt">uint32_t</span> <span class="n">key</span> <span class="o">=</span> <span class="o">*</span><span class="n">leaf_node_key</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;  - %d : %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
 <span class="kt">void</span> <span class="n">print_row</span><span class="p">(</span><span class="n">Row</span><span class="o">*</span> <span class="n">row</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">&#34;(%d, %s, %s)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">row</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">row</span><span class="o">-&gt;</span><span class="n">username</span><span class="p">,</span> <span class="n">row</span><span class="o">-&gt;</span><span class="n">email</span><span class="p">);</span>
 <span class="p">}</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">101</span><span class="p">,</span><span class="mi">6</span> <span class="o">+</span><span class="mi">173</span><span class="p">,</span><span class="mi">8</span> <span class="err">@@</span> <span class="kt">void</span> <span class="n">deserialize_row</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">source</span><span class="p">,</span> <span class="n">Row</span><span class="o">*</span> <span class="n">destination</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">destination</span><span class="o">-&gt;</span><span class="n">email</span><span class="p">),</span> <span class="n">source</span> <span class="o">+</span> <span class="n">EMAIL_OFFSET</span><span class="p">,</span> <span class="n">EMAIL_SIZE</span><span class="p">);</span>
 <span class="p">}</span>
 
<span class="o">+</span><span class="kt">void</span> <span class="n">initialize_leaf_node</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span> <span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="o">+</span>
 <span class="kt">void</span><span class="o">*</span> <span class="n">get_page</span><span class="p">(</span><span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">page_num</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">page_num</span> <span class="o">&gt;</span> <span class="n">TABLE_MAX_PAGES</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Tried to fetch page number out of bounds. %d &gt; %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">page_num</span><span class="p">,</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">128</span><span class="p">,</span><span class="mi">6</span> <span class="o">+</span><span class="mi">202</span><span class="p">,</span><span class="mi">10</span> <span class="err">@@</span> <span class="kt">void</span><span class="o">*</span> <span class="n">get_page</span><span class="p">(</span><span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">page_num</span><span class="p">)</span> <span class="p">{</span>
     <span class="p">}</span>
 
     <span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span>    <span class="k">if</span> <span class="p">(</span><span class="n">page_num</span> <span class="o">&gt;=</span> <span class="n">pager</span><span class="o">-&gt;</span><span class="n">num_pages</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>      <span class="n">pager</span><span class="o">-&gt;</span><span class="n">num_pages</span> <span class="o">=</span> <span class="n">page_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="o">+</span>    <span class="p">}</span>
   <span class="p">}</span>
 
   <span class="k">return</span> <span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">];</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">136</span><span class="p">,</span><span class="mi">8</span> <span class="o">+</span><span class="mi">214</span><span class="p">,</span><span class="mi">12</span> <span class="err">@@</span> <span class="kt">void</span><span class="o">*</span> <span class="n">get_page</span><span class="p">(</span><span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">page_num</span><span class="p">)</span> <span class="p">{</span>
 <span class="n">Cursor</span><span class="o">*</span> <span class="n">table_start</span><span class="p">(</span><span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Cursor</span><span class="p">));</span>
   <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">=</span> <span class="n">table</span><span class="p">;</span>
<span class="o">-</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">row_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">-</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">end_of_table</span> <span class="o">=</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">page_num</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">root_page_num</span><span class="p">;</span>
<span class="o">+</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">cell_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="kt">void</span><span class="o">*</span> <span class="n">root_node</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">root_page_num</span><span class="p">);</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">num_cells</span> <span class="o">=</span> <span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">root_node</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">end_of_table</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_cells</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
 
   <span class="k">return</span> <span class="n">cursor</span><span class="p">;</span>
 <span class="p">}</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">145</span><span class="p">,</span><span class="mi">24</span> <span class="o">+</span><span class="mi">227</span><span class="p">,</span><span class="mi">28</span> <span class="err">@@</span> <span class="n">Cursor</span><span class="o">*</span> <span class="n">table_start</span><span class="p">(</span><span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
 <span class="n">Cursor</span><span class="o">*</span> <span class="n">table_end</span><span class="p">(</span><span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Cursor</span><span class="p">));</span>
   <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">=</span> <span class="n">table</span><span class="p">;</span>
<span class="o">-</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">row_num</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span><span class="p">;</span>
<span class="o">+</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">page_num</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">root_page_num</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="kt">void</span><span class="o">*</span> <span class="n">root_node</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">root_page_num</span><span class="p">);</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">num_cells</span> <span class="o">=</span> <span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">root_node</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">cell_num</span> <span class="o">=</span> <span class="n">num_cells</span><span class="p">;</span>
   <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">end_of_table</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
 
   <span class="k">return</span> <span class="n">cursor</span><span class="p">;</span>
 <span class="p">}</span>
 
 <span class="kt">void</span><span class="o">*</span> <span class="n">cursor_value</span><span class="p">(</span><span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span><span class="p">)</span> <span class="p">{</span>
<span class="o">-</span>  <span class="kt">uint32_t</span> <span class="n">row_num</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">row_num</span><span class="p">;</span>
<span class="o">-</span>  <span class="kt">uint32_t</span> <span class="n">page_num</span> <span class="o">=</span> <span class="n">row_num</span> <span class="o">/</span> <span class="n">ROWS_PER_PAGE</span><span class="p">;</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">page_num</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">page_num</span><span class="p">;</span>
   <span class="kt">void</span><span class="o">*</span> <span class="n">page</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">page_num</span><span class="p">);</span>
<span class="o">-</span>  <span class="kt">uint32_t</span> <span class="n">row_offset</span> <span class="o">=</span> <span class="n">row_num</span> <span class="o">%</span> <span class="n">ROWS_PER_PAGE</span><span class="p">;</span>
<span class="o">-</span>  <span class="kt">uint32_t</span> <span class="n">byte_offset</span> <span class="o">=</span> <span class="n">row_offset</span> <span class="o">*</span> <span class="n">ROW_SIZE</span><span class="p">;</span>
<span class="o">-</span>  <span class="k">return</span> <span class="n">page</span> <span class="o">+</span> <span class="n">byte_offset</span><span class="p">;</span>
<span class="o">+</span>  <span class="k">return</span> <span class="n">leaf_node_value</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">cell_num</span><span class="p">);</span>
 <span class="p">}</span>
 
 <span class="kt">void</span> <span class="n">cursor_advance</span><span class="p">(</span><span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span><span class="p">)</span> <span class="p">{</span>
<span class="o">-</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">row_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="o">-</span>  <span class="k">if</span> <span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">row_num</span> <span class="o">&gt;=</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">page_num</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">page_num</span><span class="p">;</span>
<span class="o">+</span>  <span class="kt">void</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">page_num</span><span class="p">);</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">cell_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">cell_num</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">node</span><span class="p">)))</span> <span class="p">{</span>
     <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">end_of_table</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
   <span class="p">}</span>
 <span class="p">}</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">185</span><span class="p">,</span><span class="mi">6</span> <span class="o">+</span><span class="mi">271</span><span class="p">,</span><span class="mi">12</span> <span class="err">@@</span> <span class="n">Pager</span><span class="o">*</span> <span class="n">pager_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Pager</span><span class="p">));</span>
   <span class="n">pager</span><span class="o">-&gt;</span><span class="n">file_descriptor</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
   <span class="n">pager</span><span class="o">-&gt;</span><span class="n">file_length</span> <span class="o">=</span> <span class="n">file_length</span><span class="p">;</span>
<span class="o">+</span>  <span class="n">pager</span><span class="o">-&gt;</span><span class="n">num_pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">file_length</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">file_length</span> <span class="o">%</span> <span class="n">PAGE_SIZE</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Db file is not a whole number of pages. Corrupt file.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span>
 
   <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TABLE_MAX_PAGES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">194</span><span class="p">,</span><span class="mi">11</span> <span class="o">+</span><span class="mi">285</span><span class="p">,</span><span class="mi">15</span> <span class="err">@@</span> <span class="n">Pager</span><span class="o">*</span> <span class="n">pager_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">)</span> <span class="p">{</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">195</span><span class="p">,</span><span class="mi">11</span> <span class="o">+</span><span class="mi">287</span><span class="p">,</span><span class="mi">16</span> <span class="err">@@</span> <span class="n">Pager</span><span class="o">*</span> <span class="n">pager_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">)</span> <span class="p">{</span>
 
 <span class="n">Table</span><span class="o">*</span> <span class="n">db_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span> <span class="o">=</span> <span class="n">pager_open</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
<span class="o">-</span>  <span class="kt">uint32_t</span> <span class="n">num_rows</span> <span class="o">=</span> <span class="n">pager</span><span class="o">-&gt;</span><span class="n">file_length</span> <span class="o">/</span> <span class="n">ROW_SIZE</span><span class="p">;</span>
 
   <span class="n">Table</span><span class="o">*</span> <span class="n">table</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Table</span><span class="p">));</span>
   <span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span> <span class="o">=</span> <span class="n">pager</span><span class="p">;</span>
<span class="o">-</span>  <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">=</span> <span class="n">num_rows</span><span class="p">;</span>
<span class="o">+</span>  <span class="n">table</span><span class="o">-&gt;</span><span class="n">root_page_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">num_pages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="c1">// New database file. Initialize page 0 as leaf node.
</span><span class="c1"></span><span class="o">+</span>    <span class="kt">void</span><span class="o">*</span> <span class="n">root_node</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">pager</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">initialize_leaf_node</span><span class="p">(</span><span class="n">root_node</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span>
 
   <span class="k">return</span> <span class="n">table</span><span class="p">;</span>
 <span class="p">}</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">234</span><span class="p">,</span><span class="mi">7</span> <span class="o">+</span><span class="mi">331</span><span class="p">,</span><span class="mi">7</span> <span class="err">@@</span> <span class="kt">void</span> <span class="n">close_input_buffer</span><span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">free</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">);</span>
 <span class="p">}</span>
 
<span class="o">-</span><span class="kt">void</span> <span class="n">pager_flush</span><span class="p">(</span><span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">page_num</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span><span class="kt">void</span> <span class="n">pager_flush</span><span class="p">(</span><span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">page_num</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Tried to flush null page</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
     <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">242</span><span class="p">,</span><span class="mi">7</span> <span class="o">+</span><span class="mi">337</span><span class="p">,</span><span class="mi">7</span> <span class="err">@@</span> <span class="kt">void</span> <span class="n">pager_flush</span><span class="p">(</span><span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">page_num</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">249</span><span class="p">,</span><span class="mi">7</span> <span class="o">+</span><span class="mi">346</span><span class="p">,</span><span class="mi">7</span> <span class="err">@@</span> <span class="kt">void</span> <span class="n">pager_flush</span><span class="p">(</span><span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">page_num</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
   <span class="p">}</span>
 
   <span class="n">ssize_t</span> <span class="n">bytes_written</span> <span class="o">=</span>
<span class="o">-</span>      <span class="n">write</span><span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">file_descriptor</span><span class="p">,</span> <span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">],</span> <span class="n">size</span><span class="p">);</span>
<span class="o">+</span>      <span class="n">write</span><span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">file_descriptor</span><span class="p">,</span> <span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">],</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
 
   <span class="k">if</span> <span class="p">(</span><span class="n">bytes_written</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error writing: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">errno</span><span class="p">);</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">252</span><span class="p">,</span><span class="mi">29</span> <span class="o">+</span><span class="mi">347</span><span class="p">,</span><span class="mi">16</span> <span class="err">@@</span> <span class="kt">void</span> <span class="n">pager_flush</span><span class="p">(</span><span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">page_num</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">260</span><span class="p">,</span><span class="mi">29</span> <span class="o">+</span><span class="mi">357</span><span class="p">,</span><span class="mi">16</span> <span class="err">@@</span> <span class="kt">void</span> <span class="n">pager_flush</span><span class="p">(</span><span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">page_num</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
 
 <span class="kt">void</span> <span class="n">db_close</span><span class="p">(</span><span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">;</span>
<span class="o">-</span>  <span class="kt">uint32_t</span> <span class="n">num_full_pages</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">/</span> <span class="n">ROWS_PER_PAGE</span><span class="p">;</span>
 
<span class="o">-</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_full_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pager</span><span class="o">-&gt;</span><span class="n">num_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
       <span class="k">continue</span><span class="p">;</span>
     <span class="p">}</span>
<span class="o">-</span>    <span class="n">pager_flush</span><span class="p">(</span><span class="n">pager</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">pager_flush</span><span class="p">(</span><span class="n">pager</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
     <span class="n">free</span><span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
     <span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
   <span class="p">}</span>
 
<span class="o">-</span>  <span class="c1">// There may be a partial page to write to the end of the file
</span><span class="c1"></span><span class="o">-</span>  <span class="c1">// This should not be needed after we switch to a B-tree
</span><span class="c1"></span><span class="o">-</span>  <span class="kt">uint32_t</span> <span class="n">num_additional_rows</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">%</span> <span class="n">ROWS_PER_PAGE</span><span class="p">;</span>
<span class="o">-</span>  <span class="k">if</span> <span class="p">(</span><span class="n">num_additional_rows</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="o">-</span>    <span class="kt">uint32_t</span> <span class="n">page_num</span> <span class="o">=</span> <span class="n">num_full_pages</span><span class="p">;</span>
<span class="o">-</span>    <span class="k">if</span> <span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
<span class="o">-</span>      <span class="n">pager_flush</span><span class="p">(</span><span class="n">pager</span><span class="p">,</span> <span class="n">page_num</span><span class="p">,</span> <span class="n">num_additional_rows</span> <span class="o">*</span> <span class="n">ROW_SIZE</span><span class="p">);</span>
<span class="o">-</span>      <span class="n">free</span><span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">]);</span>
<span class="o">-</span>      <span class="n">pager</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">page_num</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="o">-</span>    <span class="p">}</span>
<span class="o">-</span>  <span class="p">}</span>
<span class="o">-</span>
   <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">close</span><span class="p">(</span><span class="n">pager</span><span class="o">-&gt;</span><span class="n">file_descriptor</span><span class="p">);</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error closing db file.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">305</span><span class="p">,</span><span class="mi">6</span> <span class="o">+</span><span class="mi">389</span><span class="p">,</span><span class="mi">14</span> <span class="err">@@</span> <span class="n">MetaCommandResult</span> <span class="n">do_meta_command</span><span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span><span class="p">,</span> <span class="n">Table</span> <span class="o">*</span><span class="n">table</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;.exit&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">db_close</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
     <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;.btree&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Tree:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">print_leaf_node</span><span class="p">(</span><span class="n">get_page</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="o">+</span>    <span class="k">return</span> <span class="n">META_COMMAND_SUCCESS</span><span class="p">;</span>
<span class="o">+</span>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;.constants&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Constants:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">print_constants</span><span class="p">();</span>
<span class="o">+</span>    <span class="k">return</span> <span class="n">META_COMMAND_SUCCESS</span><span class="p">;</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
     <span class="k">return</span> <span class="n">META_COMMAND_UNRECOGNIZED_COMMAND</span><span class="p">;</span>
   <span class="p">}</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">354</span><span class="p">,</span><span class="mi">16</span> <span class="o">+</span><span class="mi">446</span><span class="p">,</span><span class="mi">39</span> <span class="err">@@</span> <span class="n">PrepareResult</span> <span class="n">prepare_statement</span><span class="p">(</span><span class="n">InputBuffer</span><span class="o">*</span> <span class="n">input_buffer</span><span class="p">,</span>
   <span class="k">return</span> <span class="n">PREPARE_UNRECOGNIZED_STATEMENT</span><span class="p">;</span>
 <span class="p">}</span>
 
<span class="o">+</span><span class="kt">void</span> <span class="n">leaf_node_insert</span><span class="p">(</span><span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">key</span><span class="p">,</span> <span class="n">Row</span><span class="o">*</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="kt">void</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">page_num</span><span class="p">);</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">num_cells</span> <span class="o">=</span> <span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">num_cells</span> <span class="o">&gt;=</span> <span class="n">LEAF_NODE_MAX_CELLS</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="c1">// Node full
</span><span class="c1"></span><span class="o">+</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Need to implement splitting a leaf node.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">cell_num</span> <span class="o">&lt;</span> <span class="n">num_cells</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="c1">// Make room for new cell
</span><span class="c1"></span><span class="o">+</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">num_cells</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">cell_num</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>      <span class="n">memcpy</span><span class="p">(</span><span class="n">leaf_node_cell</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">leaf_node_cell</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
<span class="o">+</span>             <span class="n">LEAF_NODE_CELL_SIZE</span><span class="p">);</span>
<span class="o">+</span>    <span class="p">}</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="o">*</span><span class="p">(</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="o">+</span>  <span class="o">*</span><span class="p">(</span><span class="n">leaf_node_key</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">cell_num</span><span class="p">))</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
<span class="o">+</span>  <span class="n">serialize_row</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">leaf_node_value</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">cell_num</span><span class="p">));</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
 <span class="n">ExecuteResult</span> <span class="n">execute_insert</span><span class="p">(</span><span class="n">Statement</span><span class="o">*</span> <span class="n">statement</span><span class="p">,</span> <span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
<span class="o">-</span>  <span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">&gt;=</span> <span class="n">TABLE_MAX_ROWS</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="kt">void</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">root_page_num</span><span class="p">);</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">LEAF_NODE_MAX_CELLS</span><span class="p">))</span> <span class="p">{</span>
     <span class="k">return</span> <span class="n">EXECUTE_TABLE_FULL</span><span class="p">;</span>
   <span class="p">}</span>
 
   <span class="n">Row</span><span class="o">*</span> <span class="n">row_to_insert</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">statement</span><span class="o">-&gt;</span><span class="n">row_to_insert</span><span class="p">);</span>
   <span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span> <span class="o">=</span> <span class="n">table_end</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
 
<span class="o">-</span>  <span class="n">serialize_row</span><span class="p">(</span><span class="n">row_to_insert</span><span class="p">,</span> <span class="n">cursor_value</span><span class="p">(</span><span class="n">cursor</span><span class="p">));</span>
<span class="o">-</span>  <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_rows</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="o">+</span>  <span class="n">leaf_node_insert</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">row_to_insert</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">row_to_insert</span><span class="p">);</span>
 
   <span class="n">free</span><span class="p">(</span><span class="n">cursor</span><span class="p">);</span>
</code></pre></div><p>测试如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span>  <span class="n">it</span> <span class="err">&#39;</span><span class="n">allows</span> <span class="n">printing</span> <span class="n">out</span> <span class="n">the</span> <span class="n">structure</span> <span class="n">of</span> <span class="n">a</span> <span class="n">one</span><span class="o">-</span><span class="n">node</span> <span class="n">btree</span><span class="err">&#39;</span> <span class="k">do</span>
<span class="o">+</span>    <span class="n">script</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">].</span><span class="n">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
<span class="o">+</span>      <span class="s">&#34;insert #{i} user#{i} person#{i}@example.com&#34;</span>
<span class="o">+</span>    <span class="n">end</span>
<span class="o">+</span>    <span class="n">script</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;.btree&#34;</span>
<span class="o">+</span>    <span class="n">script</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;.exit&#34;</span>
<span class="o">+</span>    <span class="n">result</span> <span class="o">=</span> <span class="n">run_script</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
<span class="o">+</span>
<span class="o">+</span>    <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">).</span><span class="n">to</span> <span class="n">match_array</span><span class="p">([</span>
<span class="o">+</span>      <span class="s">&#34;db &gt; Executed.&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;db &gt; Executed.&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;db &gt; Executed.&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;db &gt; Tree:&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;leaf (size 3)&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;  - 0 : 3&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;  - 1 : 1&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;  - 2 : 2&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;db &gt; &#34;</span>
<span class="o">+</span>    <span class="p">])</span>
<span class="o">+</span>  <span class="n">end</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="n">it</span> <span class="err">&#39;</span><span class="n">prints</span> <span class="n">constants</span><span class="err">&#39;</span> <span class="k">do</span>
<span class="o">+</span>    <span class="n">script</span> <span class="o">=</span> <span class="p">[</span>
<span class="o">+</span>      <span class="s">&#34;.constants&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;.exit&#34;</span><span class="p">,</span>
<span class="o">+</span>    <span class="p">]</span>
<span class="o">+</span>    <span class="n">result</span> <span class="o">=</span> <span class="n">run_script</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
<span class="o">+</span>
<span class="o">+</span>    <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">).</span><span class="n">to</span> <span class="n">match_array</span><span class="p">([</span>
<span class="o">+</span>      <span class="s">&#34;db &gt; Constants:&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;ROW_SIZE: 293&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;COMMON_NODE_HEADER_SIZE: 6&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;LEAF_NODE_HEADER_SIZE: 10&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;LEAF_NODE_CELL_SIZE: 297&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;LEAF_NODE_SPACE_FOR_CELLS: 4086&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;LEAF_NODE_MAX_CELLS: 13&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;db &gt; &#34;</span><span class="p">,</span>
<span class="o">+</span>    <span class="p">])</span>
<span class="o">+</span>  <span class="n">end</span>
 <span class="n">end</span>
</code></pre></div><h2 id="第九部分---二分搜索和重复键">第九部分 - 二分搜索和重复键</h2>
<p>上次我们指出，我们仍在以无序方式存储键。我们将修复这个问题，并检测并拒绝重复键。</p>
<p>现在，我们的 <code>execute_insert()</code> 函数总是选择在表的末尾插入。相反，我们应该在表中搜索正确的位置，然后在那里插入。如果键已经存在于该位置，则返回错误。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">ExecuteResult</span> <span class="nf">execute_insert</span><span class="p">(</span><span class="n">Statement</span><span class="o">*</span> <span class="n">statement</span><span class="p">,</span> <span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
   <span class="kt">void</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">root_page_num</span><span class="p">);</span>
<span class="o">-</span>  <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">LEAF_NODE_MAX_CELLS</span><span class="p">))</span> <span class="p">{</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">num_cells</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">num_cells</span> <span class="o">&gt;=</span> <span class="n">LEAF_NODE_MAX_CELLS</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">return</span> <span class="n">EXECUTE_TABLE_FULL</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="n">Row</span><span class="o">*</span> <span class="n">row_to_insert</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">statement</span><span class="o">-&gt;</span><span class="n">row_to_insert</span><span class="p">);</span>
<span class="o">-</span>  <span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span> <span class="o">=</span> <span class="n">table_end</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">key_to_insert</span> <span class="o">=</span> <span class="n">row_to_insert</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
<span class="o">+</span>  <span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span> <span class="o">=</span> <span class="n">table_find</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">key_to_insert</span><span class="p">);</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">cell_num</span> <span class="o">&lt;</span> <span class="n">num_cells</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="kt">uint32_t</span> <span class="n">key_at_index</span> <span class="o">=</span> <span class="o">*</span><span class="n">leaf_node_key</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">cell_num</span><span class="p">);</span>
<span class="o">+</span>    <span class="k">if</span> <span class="p">(</span><span class="n">key_at_index</span> <span class="o">==</span> <span class="n">key_to_insert</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>      <span class="k">return</span> <span class="n">EXECUTE_DUPLICATE_KEY</span><span class="p">;</span>
<span class="o">+</span>    <span class="p">}</span>
<span class="o">+</span>  <span class="p">}</span>

   <span class="n">leaf_node_insert</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">row_to_insert</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">row_to_insert</span><span class="p">);</span>
</code></pre></div><p>我们不再需要 <code>table_end()</code> 函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">-</span><span class="n">Cursor</span><span class="o">*</span> <span class="n">table_end</span><span class="p">(</span><span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
<span class="o">-</span>  <span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Cursor</span><span class="p">));</span>
<span class="o">-</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">=</span> <span class="n">table</span><span class="p">;</span>
<span class="o">-</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">page_num</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">root_page_num</span><span class="p">;</span>
<span class="o">-</span>
<span class="o">-</span>  <span class="kt">void</span><span class="o">*</span> <span class="n">root_node</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">root_page_num</span><span class="p">);</span>
<span class="o">-</span>  <span class="kt">uint32_t</span> <span class="n">num_cells</span> <span class="o">=</span> <span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">root_node</span><span class="p">);</span>
<span class="o">-</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">cell_num</span> <span class="o">=</span> <span class="n">num_cells</span><span class="p">;</span>
<span class="o">-</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">end_of_table</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="o">-</span>
<span class="o">-</span>  <span class="k">return</span> <span class="n">cursor</span><span class="p">;</span>
<span class="o">-</span><span class="p">}</span>
</code></pre></div><p>我们将其替换为一个方法，该方法在树中搜索给定键的位置。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span><span class="cm">/*
</span><span class="cm">+返回给定键的位置。
</span><span class="cm">+如果键不存在，则返回应插入的位置。
</span><span class="cm">+*/</span>
<span class="o">+</span><span class="n">Cursor</span><span class="o">*</span> <span class="n">table_find</span><span class="p">(</span><span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">root_page_num</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">root_page_num</span><span class="p">;</span>
<span class="o">+</span>  <span class="kt">void</span><span class="o">*</span> <span class="n">root_node</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">root_page_num</span><span class="p">);</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">get_node_type</span><span class="p">(</span><span class="n">root_node</span><span class="p">)</span> <span class="o">==</span> <span class="n">NODE_LEAF</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="k">return</span> <span class="n">leaf_node_find</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">root_page_num</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="o">+</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Need to implement searching an internal node</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span><span class="p">}</span>
</code></pre></div><p>我正在为内部节点的分支提供桩代码，因为我们尚未实现内部节点。我们可以使用二分搜索来搜索叶子节点。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span><span class="n">Cursor</span><span class="o">*</span> <span class="n">leaf_node_find</span><span class="p">(</span><span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">page_num</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="kt">void</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">page_num</span><span class="p">);</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">num_cells</span> <span class="o">=</span> <span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Cursor</span><span class="p">));</span>
<span class="o">+</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">=</span> <span class="n">table</span><span class="p">;</span>
<span class="o">+</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">page_num</span> <span class="o">=</span> <span class="n">page_num</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="c1">// 二分搜索
</span><span class="c1"></span><span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">min_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">one_past_max_index</span> <span class="o">=</span> <span class="n">num_cells</span><span class="p">;</span>
<span class="o">+</span>  <span class="k">while</span> <span class="p">(</span><span class="n">one_past_max_index</span> <span class="o">!=</span> <span class="n">min_index</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="kt">uint32_t</span> <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_index</span> <span class="o">+</span> <span class="n">one_past_max_index</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="o">+</span>    <span class="kt">uint32_t</span> <span class="n">key_at_index</span> <span class="o">=</span> <span class="o">*</span><span class="n">leaf_node_key</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
<span class="o">+</span>    <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="n">key_at_index</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>      <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">cell_num</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
<span class="o">+</span>      <span class="k">return</span> <span class="n">cursor</span><span class="p">;</span>
<span class="o">+</span>    <span class="p">}</span>
<span class="o">+</span>    <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">key_at_index</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>      <span class="n">one_past_max_index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
<span class="o">+</span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="o">+</span>      <span class="n">min_index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="o">+</span>    <span class="p">}</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">cell_num</span> <span class="o">=</span> <span class="n">min_index</span><span class="p">;</span>
<span class="o">+</span>  <span class="k">return</span> <span class="n">cursor</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span>
</code></pre></div><p>这将返回：</p>
<ul>
<li>键的位置，</li>
<li>另一个键的位置，如果要插入新键，则需要移动该位置的键，或者</li>
<li>最后一个键之后的位置</li>
</ul>
<p>由于我们现在正在检查节点类型，因此我们需要函数来获取并设置节点中的值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span><span class="n">NodeType</span> <span class="n">get_node_type</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="kt">uint8_t</span> <span class="n">value</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)(</span><span class="n">node</span> <span class="o">+</span> <span class="n">NODE_TYPE_OFFSET</span><span class="p">));</span>
<span class="o">+</span>  <span class="k">return</span> <span class="p">(</span><span class="n">NodeType</span><span class="p">)</span><span class="n">value</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span><span class="kt">void</span> <span class="n">set_node_type</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="n">NodeType</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="kt">uint8_t</span> <span class="n">value</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
<span class="o">+</span>  <span class="o">*</span><span class="p">((</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)(</span><span class="n">node</span> <span class="o">+</span> <span class="n">NODE_TYPE_OFFSET</span><span class="p">))</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span>
</code></pre></div><p>我们首先要进行 <code>uint8_t</code> 强制转换，以确保将其序列化为单个字节。</p>
<p>我们还需要初始化节点类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">-</span><span class="kt">void</span> <span class="n">initialize_leaf_node</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span> <span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="o">+</span><span class="kt">void</span> <span class="n">initialize_leaf_node</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="n">set_node_type</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">NODE_LEAF</span><span class="p">);</span>
<span class="o">+</span>  <span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span>
</code></pre></div><p>最后，我们需要创建并处理一个新的错误代码。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">-</span><span class="k">enum</span> <span class="n">ExecuteResult_t</span> <span class="p">{</span> <span class="n">EXECUTE_SUCCESS</span><span class="p">,</span> <span class="n">EXECUTE_TABLE_FULL</span> <span class="p">};</span>
<span class="o">+</span><span class="k">enum</span> <span class="n">ExecuteResult_t</span> <span class="p">{</span>
<span class="o">+</span>  <span class="n">EXECUTE_SUCCESS</span><span class="p">,</span>
<span class="o">+</span>  <span class="n">EXECUTE_DUPLICATE_KEY</span><span class="p">,</span>
<span class="o">+</span>  <span class="n">EXECUTE_TABLE_FULL</span>
<span class="o">+</span><span class="p">};</span>
       <span class="k">case</span> <span class="p">(</span><span class="n">EXECUTE_SUCCESS</span><span class="p">)</span><span class="o">:</span>
         <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Executed.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
         <span class="k">break</span><span class="p">;</span>
<span class="o">+</span>      <span class="k">case</span> <span class="p">(</span><span class="n">EXECUTE_DUPLICATE_KEY</span><span class="p">)</span><span class="o">:</span>
<span class="o">+</span>        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error: Duplicate key.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="o">+</span>        <span class="k">break</span><span class="p">;</span>
       <span class="k">case</span> <span class="p">(</span><span class="n">EXECUTE_TABLE_FULL</span><span class="p">)</span><span class="o">:</span>
         <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error: Table full.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
         <span class="k">break</span><span class="p">;</span>
</code></pre></div><p>通过这些更改，我们的测试可以更改为检查是否按排序顺序排列：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">       <span class="s">&#34;db &gt; Executed.&#34;</span><span class="p">,</span>
       <span class="s">&#34;db &gt; Tree:&#34;</span><span class="p">,</span>
       <span class="s">&#34;leaf (size 3)&#34;</span><span class="p">,</span>
<span class="o">-</span>      <span class="s">&#34;  - 0 : 3&#34;</span><span class="p">,</span>
<span class="o">-</span>      <span class="s">&#34;  - 1 : 1&#34;</span><span class="p">,</span>
<span class="o">-</span>      <span class="s">&#34;  - 2 : 2&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;  - 0 : 1&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;  - 1 : 2&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;  - 2 : 3&#34;</span><span class="p">,</span>
       <span class="s">&#34;db &gt; &#34;</span>
     <span class="p">])</span>
   <span class="n">end</span>
</code></pre></div><p>我们还可以添加一个新的测试以检查重复键：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span>  <span class="n">it</span> <span class="err">&#39;</span><span class="n">prints</span> <span class="n">an</span> <span class="n">error</span> <span class="n">message</span> <span class="k">if</span> <span class="n">there</span> <span class="n">is</span> <span class="n">a</span> <span class="n">duplicate</span> <span class="n">id</span><span class="err">&#39;</span> <span class="k">do</span>
<span class="o">+</span>    <span class="n">script</span> <span class="o">=</span> <span class="p">[</span>
<span class="o">+</span>      <span class="s">&#34;insert 1 user1 person1@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 1 user1 person1@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;select&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;.exit&#34;</span><span class="p">,</span>
<span class="o">+</span>    <span class="p">]</span>
<span class="o">+</span>    <span class="n">result</span> <span class="o">=</span> <span class="n">run_script</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
<span class="o">+</span>    <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">).</span><span class="n">to</span> <span class="n">match_array</span><span class="p">([</span>
<span class="o">+</span>      <span class="s">&#34;db &gt; Executed.&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;db &gt; Error: Duplicate key.&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;db &gt; (1, user1, person1@example.com)&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;Executed.&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;db &gt; &#34;</span><span class="p">,</span>
<span class="o">+</span>    <span class="p">])</span>
<span class="o">+</span>  <span class="n">end</span>
</code></pre></div><p>就是这样！接下来：实现分裂叶子节点和创建内部节点。</p>
<h2 id="第十部分---分裂叶子节点">第十部分 - 分裂叶子节点</h2>
<p>我们的 B-Tree 只有一个节点，看起来并不像一棵树。为了解决这个问题，我们需要一些代码来将叶子节点拆分，并创建一个内部节点作为两个叶子节点的父节点。</p>
<p>基本上，本文的目标是从这个状态：</p>
<p><img src="https://cstack.github.io/db_tutorial/assets/images/btree2.png" alt="one-node btree"></p>
<p>变成这个状态：</p>
<p><img src="https://cstack.github.io/db_tutorial/assets/images/btree3.png" alt="two-level btree"></p>
<p>首先，让我们删除对满叶子节点的错误处理：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"> <span class="kt">void</span> <span class="nf">leaf_node_insert</span><span class="p">(</span><span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">key</span><span class="p">,</span> <span class="n">Row</span><span class="o">*</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
   <span class="kt">void</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">page_num</span><span class="p">);</span>
 
   <span class="kt">uint32_t</span> <span class="n">num_cells</span> <span class="o">=</span> <span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">num_cells</span> <span class="o">&gt;=</span> <span class="n">LEAF_NODE_MAX_CELLS</span><span class="p">)</span> <span class="p">{</span>
     <span class="c1">// Node full
</span><span class="c1"></span><span class="o">-</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Need to implement splitting a leaf node.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="o">-</span>    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">leaf_node_split_and_insert</span><span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="o">+</span>    <span class="k">return</span><span class="p">;</span>
   <span class="p">}</span>
<span class="n">ExecuteResult</span> <span class="n">execute_insert</span><span class="p">(</span><span class="n">Statement</span><span class="o">*</span> <span class="n">statement</span><span class="p">,</span> <span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
   <span class="kt">void</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">root_page_num</span><span class="p">);</span>
   <span class="kt">uint32_t</span> <span class="n">num_cells</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
<span class="o">-</span>  <span class="k">if</span> <span class="p">(</span><span class="n">num_cells</span> <span class="o">&gt;=</span> <span class="n">LEAF_NODE_MAX_CELLS</span><span class="p">)</span> <span class="p">{</span>
<span class="o">-</span>    <span class="k">return</span> <span class="n">EXECUTE_TABLE_FULL</span><span class="p">;</span>
<span class="o">-</span>  <span class="p">}</span>
 
   <span class="n">Row</span><span class="o">*</span> <span class="n">row_to_insert</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">statement</span><span class="o">-&gt;</span><span class="n">row_to_insert</span><span class="p">);</span>
   <span class="kt">uint32_t</span> <span class="n">key_to_insert</span> <span class="o">=</span> <span class="n">row_to_insert</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
</code></pre></div><h2 id="分裂算法">分裂算法</h2>
<p>容易的部分已经完成。以下是来自<a href="https://play.google.com/store/books/details/Sibsankar_Haldar_SQLite_Database_System_Design_and?id=9Z6IQQnX1JEC&amp;hl=en">SQLite 数据库系统：设计与实现</a>的描述：</p>
<blockquote>
<p>如果叶子节点没有空间了，我们会将驻留在那里的现有条目和要插入的新条目（正在插入的）拆分为两个相等的部分：较低和较高的部分。（上半部分的键严格大于下半部分的键。）我们分配一个新的叶子节点，并将上半部分移动到新节点。</p>
</blockquote>
<p>让我们先获取旧节点，并创建新节点：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span><span class="kt">void</span> <span class="n">leaf_node_split_and_insert</span><span class="p">(</span><span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">key</span><span class="p">,</span> <span class="n">Row</span><span class="o">*</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="cm">/*
</span><span class="cm">+  创建一个新节点并将一半单元格移动过去。
</span><span class="cm">+  在两个节点中的一个中插入新值。
</span><span class="cm">+  更新父节点或创建一个新的父节点。
</span><span class="cm">+  */</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="kt">void</span><span class="o">*</span> <span class="n">old_node</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">page_num</span><span class="p">);</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">new_page_num</span> <span class="o">=</span> <span class="n">get_unused_page_num</span><span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">);</span>
<span class="o">+</span>  <span class="kt">void</span><span class="o">*</span> <span class="n">new_node</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">new_page_num</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">initialize_leaf_node</span><span class="p">(</span><span class="n">new_node</span><span class="p">);</span>
</code></pre></div><p>接下来，将每个单元格复制到它的新位置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span>  <span class="cm">/*
</span><span class="cm">+  所有现有键以及新键应该均匀分布
</span><span class="cm">+  在旧（左）和新（右）节点之间。
</span><span class="cm">+  从右侧开始，将每个键移动到正确的位置。
</span><span class="cm">+  */</span>
<span class="o">+</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">int32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">LEAF_NODE_MAX_CELLS</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="kt">void</span><span class="o">*</span> <span class="n">destination_node</span><span class="p">;</span>
<span class="o">+</span>    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">LEAF_NODE_LEFT_SPLIT_COUNT</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>      <span class="n">destination_node</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
<span class="o">+</span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="o">+</span>      <span class="n">destination_node</span> <span class="o">=</span> <span class="n">old_node</span><span class="p">;</span>
<span class="o">+</span>    <span class="p">}</span>
<span class="o">+</span>    <span class="kt">uint32_t</span> <span class="n">index_within_node</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="n">LEAF_NODE_LEFT_SPLIT_COUNT</span><span class="p">;</span>
<span class="o">+</span>    <span class="kt">void</span><span class="o">*</span> <span class="n">destination</span> <span class="o">=</span> <span class="n">leaf_node_cell</span><span class="p">(</span><span class="n">destination_node</span><span class="p">,</span> <span class="n">index_within_node</span><span class="p">);</span>
<span class="o">+</span>
<span class="o">+</span>    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">cell_num</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>      <span class="n">serialize_row</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">destination</span><span class="p">);</span>
<span class="o">+</span>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">cell_num</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>      <span class="n">memcpy</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="n">leaf_node_cell</span><span class="p">(</span><span class="n">old_node</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">LEAF_NODE_CELL_SIZE</span><span class="p">);</span>
<span class="o">+</span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="o">+</span>      <span class="n">memcpy</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="n">leaf_node_cell</span><span class="p">(</span><span class="n">old_node</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">LEAF_NODE_CELL_SIZE</span><span class="p">);</span>
<span class="o">+</span>    <span class="p">}</span>
<span class="o">+</span>  <span class="p">}</span>
</code></pre></div><p>在每个节点的头部更新单元格计数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span>  <span class="cm">/* 在两个叶子节点上更新单元格计数 */</span>
<span class="o">+</span>  <span class="o">*</span><span class="p">(</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">old_node</span><span class="p">))</span> <span class="o">=</span> <span class="n">LEAF_NODE_LEFT_SPLIT_COUNT</span><span class="p">;</span>
<span class="o">+</span>  <span class="o">*</span><span class="p">(</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">new_node</span><span class="p">))</span> <span class="o">=</span> <span class="n">LEAF_NODE_RIGHT_SPLIT_COUNT</span><span class="p">;</span>
</code></pre></div><p>接下来，我们需要更新节点的父节点。如果原始节点是根节点，则它没有父节点。在这种情况下，创建一个新的根节点作为父节点。我会暂时创建另一支的桩代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">is_node_root</span><span class="p">(</span><span class="n">old_node</span><span class="p">))</span> <span class="p">{</span>
<span class="o">+</span>    <span class="k">return</span> <span class="n">create_new_root</span><span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">,</span> <span class="n">new_page_num</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="o">+</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Need to implement updating parent after split</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span><span class="p">}</span>
</code></pre></div><h2 id="分配新页面">分配新页面</h2>
<p>让我们回到并定义一些新函数和常量。当我们创建一个新的叶子节点时，我们将其放在由 <code>get_unused_page_num()</code> 决定的页面中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span><span class="cm">/*
</span><span class="cm">+在我们开始回收空闲页面之前，新页面将始终
</span><span class="cm">+添加到数据库文件的末尾
</span><span class="cm">+*/</span>
<span class="o">+</span><span class="kt">uint32_t</span> <span class="n">get_unused_page_num</span><span class="p">(</span><span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">pager</span><span class="o">-&gt;</span><span class="n">num_pages</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div><p>现在，我们假设在具有 N 个页面的数据库中，页面号为 0 到 N-1 被分配。因此，我们可以总是为新页面分配页面号 N。最终，在实现删除后，某些页面可能会变为空闲，它们的页面号未被使用。为了更高效，我们可以重新分配这些空闲页面。</p>
<h3 id="叶子节点大小">叶子节点大小</h3>
<p>为了保持树的平衡，我们要在两个新节点之间均匀分配单元格。如果叶子节点可以容纳 N 个单元格，那么在拆分时，我们需要在两个节点之间分配 N+1 个单元格（N 个原始单元格加一个新的单元格）。我随意地选择左节点在 N+1 为奇数时获取一个额外的单元格。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LEAF_NODE_RIGHT_SPLIT_COUNT</span> <span class="o">=</span> <span class="p">(</span><span class="n">LEAF_NODE_MAX_CELLS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LEAF_NODE_LEFT_SPLIT_COUNT</span> <span class="o">=</span>
<span class="o">+</span>    <span class="p">(</span><span class="n">LEAF_NODE_MAX_CELLS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">LEAF_NODE_RIGHT_SPLIT_COUNT</span><span class="p">;</span>
</code></pre></div><h3 id="创建一个新的根节点">创建一个新的根节点</h3>
<p>这是<a href="https://play.google.com/store/books/details/Sibsankar_Haldar_SQLite_Database_System_Design_and?id=9Z6IQQnX1JEC&amp;hl=en">SQLite 数据库系统</a>解释创建新根节点的过程：</p>
<blockquote>
<p>设 N 为根节点。首先分配两个节点，称为 L 和 R。将 N 的下半部分移动到 L 中，将上半部分移动到 R 中。现在 N 是空的。在 N 中添加 〈L, K,R〉，其中 K 是 L 中的最大键。页面 N 仍然是根节点。请注意，树的深度增加了一层，但新树仍然保持平衡，不违反任何 B+树属性。</p>
</blockquote>
<p>在这一点上，我们已经分配了右子节点并将上半部分移动到它。我们的函数接受右子节点作为输入，并分配一个新页面来存储左子节点。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span><span class="kt">void</span> <span class="n">create_new_root</span><span class="p">(</span><span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">right_child_page_num</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="cm">/*
</span><span class="cm">+  处理根节点的拆分。
</span><span class="cm">+  将旧根复制到新页面，成为左子节点。
</span><span class="cm">+  重新初始化根页以包含新根节点。
</span><span class="cm">+  新根节点指向两个子节点。
</span><span class="cm">+  */</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="kt">void</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">root_page_num</span><span class="p">);</span>
<span class="o">+</span>  <span class="kt">void</span><span class="o">*</span> <span class="n">right_child</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">right_child_page_num</span><span class="p">);</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">left_child_page_num</span> <span class="o">=</span> <span class="n">get_unused_page_num</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">);</span>
<span class="o">+</span>  <span class="kt">void</span><span class="o">*</span> <span class="n">left_child</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">left_child_page_num</span><span class="p">);</span>
</code></pre></div><p>将旧根复制到左子节点，以便我们可以重用根页：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span>  <span class="cm">/* 左子节点有从旧根复制的数据 */</span>
<span class="o">+</span>  <span class="n">memcpy</span><span class="p">(</span><span class="n">left_child</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">set_node_root</span><span class="p">(</span><span class="n">left_child</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</code></pre></div><p>最后，将根页初始化为一个具有两个子节点的新内部节点。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span>  <span class="cm">/* 根节点是一个新的内部节点，有一个键和两个子节点 */</span>
<span class="o">+</span>  <span class="n">initialize_internal_node</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">set_node_root</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="o">+</span>  <span class="o">*</span><span class="n">internal_node_num_keys</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="o">+</span>  <span class="o">*</span><span class="n">internal_node_child</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">left_child_page_num</span><span class="p">;</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">left_child_max_key</span> <span class="o">=</span> <span class="n">get_node_max_key</span><span class="p">(</span><span class="n">left_child</span><span class="p">);</span>
<span class="o">+</span>  <span class="o">*</span><span class="n">internal_node_key</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">left_child_max_key</span><span class="p">;</span>
<span class="o">+</span>  <span class="o">*</span><span class="n">internal_node_right_child</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">=</span> <span class="n">right_child_page_num</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span>
</code></pre></div><h3 id="内部节点格式">内部节点格式</h3>
<p>现在我们终于要创建一个内部节点了，我们必须定义其布局。它以通用头部开始，然后是它包含的键的数量，然后是其最右侧子节点的页号。内部节点始终比键多一个子节点指针。这个额外的子节点指针存储在头部中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span><span class="cm">/*
</span><span class="cm">+ * 内部节点头部布局
</span><span class="cm">+ */</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">INTERNAL_NODE_NUM_KEYS_SIZE</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">INTERNAL_NODE_NUM_KEYS_OFFSET</span> <span class="o">=</span> <span class="n">COMMON_NODE_HEADER_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">INTERNAL_NODE_RIGHT_CHILD_SIZE</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">INTERNAL_NODE_RIGHT_CHILD_OFFSET</span> <span class="o">=</span>
<span class="o">+</span>    <span class="n">INTERNAL_NODE_NUM_KEYS_OFFSET</span> <span class="o">+</span> <span class="n">INTERNAL_NODE_NUM_KEYS_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">INTERNAL_NODE_HEADER_SIZE</span> <span class="o">=</span> <span class="n">COMMON_NODE_HEADER_SIZE</span> <span class="o">+</span>
<span class="o">+</span>                                           <span class="n">INTERNAL_NODE_NUM_KEYS_SIZE</span> <span class="o">+</span>
<span class="o">+</span>                                           <span class="n">INTERNAL_NODE_RIGHT_CHILD_SIZE</span><span class="p">;</span>
</code></pre></div><p>其主体是一个包含子节点和键的单元格数组。每个键应该是其左侧子节点中包含的最大键。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span><span class="cm">/*
</span><span class="cm">+ * 内部节点主体布局
</span><span class="cm">+ */</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">INTERNAL_NODE_KEY_SIZE</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">INTERNAL_NODE_CHILD_SIZE</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">INTERNAL_NODE_CELL_SIZE</span> <span class="o">=</span>
<span class="o">+</span>    <span class="n">INTERNAL_NODE_CHILD_SIZE</span> <span class="o">+</span> <span class="n">INTERNAL_NODE_KEY_SIZE</span><span class="p">;</span>
</code></pre></div><p>基于这些常量，这里是内部节点布局的样子：</p>
<p><img src="https://cstack.github.io/db_tutorial/assets/images/internal-node-format.png" alt="Our internal node format"></p>
<p>请注意我们的巨大分支因子。因为每个子节点/键对都非常小，所以每个内部节点可以容纳 510 个键和 511 个子节点指针。这意味着我们永远不必遍历许多层树来查找给定的键！</p>
<table>
<thead>
<tr>
<th style="text-align:left"># 内部节点层数</th>
<th style="text-align:left">最大 # 叶子节点</th>
<th style="text-align:left">所有叶子节点的大小</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">511^0 = 1</td>
<td style="text-align:left">4 KB</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">511^1 = 512</td>
<td style="text-align:left">~2 MB</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">511^2 = 261,121</td>
<td style="text-align:left">~1 GB</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">511^3 = 133,432,831</td>
<td style="text-align:left">~550 GB</td>
</tr>
</tbody>
</table>
<p>实际上，由于头部、键和浪费空间的开销，我们不能在每个叶子节点中存储完整的 4 KB 数据。但我们可以通过仅加载磁盘上的 4 页来搜索大约 500 GB 的数据。这就是为什么 B-Tree 对于数据库是一个有用的数据结构。</p>
<p>这里是读取和写入内部节点的方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="n">internal_node_num_keys</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="k">return</span> <span class="n">node</span> <span class="o">+</span> <span class="n">INTERNAL_NODE_NUM_KEYS_OFFSET</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="n">internal_node_right_child</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="k">return</span> <span class="n">node</span> <span class="o">+</span> <span class="n">INTERNAL_NODE_RIGHT_CHILD_OFFSET</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="n">internal_node_cell</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">cell_num</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="k">return</span> <span class="n">node</span> <span class="o">+</span> <span class="n">INTERNAL_NODE_HEADER_SIZE</span> <span class="o">+</span> <span class="n">cell_num</span> <span class="o">*</span> <span class="n">INTERNAL_NODE_CELL_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="n">internal_node_child</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">child_num</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">num_keys</span> <span class="o">=</span> <span class="o">*</span><span class="n">internal_node_num_keys</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">child_num</span> <span class="o">&gt;</span> <span class="n">num_keys</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Tried to access child_num %d &gt; num_keys %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">child_num</span><span class="p">,</span> <span class="n">num_keys</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">child_num</span> <span class="o">==</span> <span class="n">num_keys</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="k">return</span> <span class="n">internal_node_right_child</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="o">+</span>    <span class="k">return</span> <span class="n">internal_node_cell</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">child_num</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="n">internal_node_key</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">key_num</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="k">return</span> <span class="n">internal_node_cell</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">key_num</span><span class="p">)</span> <span class="o">+</span> <span class="n">INTERNAL_NODE_CHILD_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span>
</code></pre></div><p>对于内部节点，最大键值始终是它的右键。而对于叶节点，则是最大索引处的键值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span><span class="kt">uint32_t</span> <span class="n">get_node_max_key</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="k">switch</span> <span class="p">(</span><span class="n">get_node_type</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
<span class="o">+</span>    <span class="k">case</span> <span class="nl">NODE_INTERNAL</span><span class="p">:</span>
<span class="o">+</span>      <span class="k">return</span> <span class="o">*</span><span class="n">internal_node_key</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">internal_node_num_keys</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="o">+</span>    <span class="k">case</span> <span class="nl">NODE_LEAF</span><span class="p">:</span>
<span class="o">+</span>      <span class="k">return</span> <span class="o">*</span><span class="n">leaf_node_key</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span><span class="p">}</span>

</code></pre></div><h3 id="跟踪根节点状态">跟踪根节点状态</h3>
<p>我们终于在通用节点头部使用了 <code>is_root</code> 字段。回想一下，我们用它来决定如何拆分叶节点：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">  <span class="k">if</span> <span class="p">(</span><span class="n">is_node_root</span><span class="p">(</span><span class="n">old_node</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">create_new_root</span><span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">,</span> <span class="n">new_page_num</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Need to implement updating parent after split</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

</code></pre></div><p>以下是获取器和设置器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span><span class="kt">bool</span> <span class="n">is_node_root</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="kt">uint8_t</span> <span class="n">value</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)(</span><span class="n">node</span> <span class="o">+</span> <span class="n">IS_ROOT_OFFSET</span><span class="p">));</span>
<span class="o">+</span>  <span class="k">return</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span><span class="n">value</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span><span class="kt">void</span> <span class="n">set_node_root</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">is_root</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="kt">uint8_t</span> <span class="n">value</span> <span class="o">=</span> <span class="n">is_root</span><span class="p">;</span>
<span class="o">+</span>  <span class="o">*</span><span class="p">((</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)(</span><span class="n">node</span> <span class="o">+</span> <span class="n">IS_ROOT_OFFSET</span><span class="p">))</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span>

</code></pre></div><p>初始化两种类型的节点应默认将 <code>is_root</code> 设置为 false：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"> <span class="kt">void</span> <span class="nf">initialize_leaf_node</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">set_node_type</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">NODE_LEAF</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">set_node_root</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
   <span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="p">}</span>

<span class="o">+</span><span class="kt">void</span> <span class="n">initialize_internal_node</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="n">set_node_type</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">NODE_INTERNAL</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">set_node_root</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="o">+</span>  <span class="o">*</span><span class="n">internal_node_num_keys</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span>

</code></pre></div><p>在创建表的第一个节点时，我们应将 <code>is_root</code> 设置为 true：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">     <span class="c1">// New database file. Initialize page 0 as leaf node.
</span><span class="c1"></span>     <span class="kt">void</span><span class="o">*</span> <span class="n">root_node</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">pager</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
     <span class="n">initialize_leaf_node</span><span class="p">(</span><span class="n">root_node</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">set_node_root</span><span class="p">(</span><span class="n">root_node</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
   <span class="p">}</span>
 
   <span class="k">return</span> <span class="n">table</span><span class="p">;</span>

</code></pre></div><h3 id="打印树结构">打印树结构</h3>
<p>为了帮助可视化数据库的状态，我们应该更新 <code>.btree</code> 元命令以打印多级树结构。</p>
<p>我将替换当前的 <code>print_leaf_node()</code> 函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">-</span><span class="kt">void</span> <span class="n">print_leaf_node</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
<span class="o">-</span>  <span class="kt">uint32_t</span> <span class="n">num_cells</span> <span class="o">=</span> <span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="o">-</span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;leaf (size %d)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">num_cells</span><span class="p">);</span>
<span class="o">-</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_cells</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">-</span>    <span class="kt">uint32_t</span> <span class="n">key</span> <span class="o">=</span> <span class="o">*</span><span class="n">leaf_node_key</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="o">-</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;  - %d : %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
<span class="o">-</span>  <span class="p">}</span>
<span class="o">-</span><span class="p">}</span>

</code></pre></div><p>使用一个新的递归函数，它接收任何节点，然后打印节点及其子节点。该函数接受一个缩进级别作为参数，并随着每次递归调用而增加。我还添加了一个小的缩进辅助函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span><span class="kt">void</span> <span class="n">indent</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">level</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">level</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;  &#34;</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span><span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span><span class="kt">void</span> <span class="n">print_tree</span><span class="p">(</span><span class="n">Pager</span><span class="o">*</span> <span class="n">pager</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">page_num</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">indentation_level</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="kt">void</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">pager</span><span class="p">,</span> <span class="n">page_num</span><span class="p">);</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">num_keys</span><span class="p">,</span> <span class="n">child</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="k">switch</span> <span class="p">(</span><span class="n">get_node_type</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
<span class="o">+</span>    <span class="k">case</span> <span class="p">(</span><span class="n">NODE_LEAF</span><span class="p">)</span><span class="o">:</span>
<span class="o">+</span>      <span class="n">num_keys</span> <span class="o">=</span> <span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="o">+</span>      <span class="n">indent</span><span class="p">(</span><span class="n">indentation_level</span><span class="p">);</span>
<span class="o">+</span>      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;- leaf (size %d)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">num_keys</span><span class="p">);</span>
<span class="o">+</span>      <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_keys</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>        <span class="n">indent</span><span class="p">(</span><span class="n">indentation_level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="o">+</span>        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;- %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">*</span><span class="n">leaf_node_key</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
<span class="o">+</span>      <span class="p">}</span>
<span class="o">+</span>      <span class="k">break</span><span class="p">;</span>
<span class="o">+</span>    <span class="k">case</span> <span class="p">(</span><span class="n">NODE_INTERNAL</span><span class="p">)</span><span class="o">:</span>
<span class="o">+</span>      <span class="n">num_keys</span> <span class="o">=</span> <span class="o">*</span><span class="n">internal_node_num_keys</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="o">+</span>      <span class="n">indent</span><span class="p">(</span><span class="n">indentation_level</span><span class="p">);</span>
<span class="o">+</span>      <span class="n">printf</span><span class="p">(</span><span class="s">&#34;- internal (size %d)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">num_keys</span><span class="p">);</span>
<span class="o">+</span>      <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_keys</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>        <span class="n">child</span> <span class="o">=</span> <span class="o">*</span><span class="n">internal_node_child</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="o">+</span>        <span class="n">print_tree</span><span class="p">(</span><span class="n">pager</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">indentation_level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="o">+</span>
<span class="o">+</span>        <span class="n">indent</span><span class="p">(</span><span class="n">indentation_level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="o">+</span>        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;- key %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">*</span><span class="n">internal_node_key</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
<span class="o">+</span>      <span class="p">}</span>
<span class="o">+</span>      <span class="n">child</span> <span class="o">=</span> <span class="o">*</span><span class="n">internal_node_right_child</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="o">+</span>      <span class="n">print_tree</span><span class="p">(</span><span class="n">pager</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">indentation_level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="o">+</span>      <span class="k">break</span><span class="p">;</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span><span class="p">}</span>

</code></pre></div><p>并且更新对打印函数的调用，传入缩进级别为零。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">   <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">input_buffer</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&#34;.btree&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Tree:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="o">-</span>    <span class="n">print_leaf_node</span><span class="p">(</span><span class="n">get_page</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="o">+</span>    <span class="n">print_tree</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
     <span class="k">return</span> <span class="n">META_COMMAND_SUCCESS</span><span class="p">;</span>

</code></pre></div><p>这是新打印功能的测试用例！</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span>  <span class="n">it</span> <span class="err">&#39;</span><span class="n">allows</span> <span class="n">printing</span> <span class="n">out</span> <span class="n">the</span> <span class="n">structure</span> <span class="n">of</span> <span class="n">a</span> <span class="mi">3</span><span class="o">-</span><span class="n">leaf</span><span class="o">-</span><span class="n">node</span> <span class="n">btree</span><span class="err">&#39;</span> <span class="k">do</span>
<span class="o">+</span>    <span class="n">script</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1..14</span><span class="p">).</span><span class="n">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
<span class="o">+</span>      <span class="s">&#34;insert #{i} user#{i} person#{i}@example.com&#34;</span>
<span class="o">+</span>    <span class="n">end</span>
<span class="o">+</span>    <span class="n">script</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;.btree&#34;</span>
<span class="o">+</span>    <span class="n">script</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;insert 15 user15 person15@example.com&#34;</span>
<span class="o">+</span>    <span class="n">script</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;.exit&#34;</span>
<span class="o">+</span>    <span class="n">result</span> <span class="o">=</span> <span class="n">run_script</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
<span class="o">+</span>
<span class="o">+</span>    <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mf">14.</span><span class="p">..(</span><span class="n">result</span><span class="p">.</span><span class="n">length</span><span class="p">)]).</span><span class="n">to</span> <span class="n">match_array</span><span class="p">([</span>
<span class="o">+</span>      <span class="s">&#34;db &gt; Tree:&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;- internal (size 1)&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;  - leaf (size 7)&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;    - 1&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;    - 2&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;    - 3&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;    - 4&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;    - 5&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;    - 6&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;    - 7&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;  - key 7&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;  - leaf (size 7)&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;    - 8&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;    - 9&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;    - 10&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;    - 11&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;    - 12&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;    - 13&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;    - 14&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;db &gt; Need to implement searching an internal node&#34;</span><span class="p">,</span>
<span class="o">+</span>    <span class="p">])</span>
<span class="o">+</span>  <span class="n">end</span>

</code></pre></div><p>新格式有些简化，因此我们需要更新现有的 <code>.btree</code> 测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">       <span class="s">&#34;db &gt; Executed.&#34;</span><span class="p">,</span>
       <span class="s">&#34;db &gt; Executed.&#34;</span><span class="p">,</span>
       <span class="s">&#34;db &gt; Tree:&#34;</span><span class="p">,</span>
<span class="o">-</span>      <span class="s">&#34;leaf (size 3)&#34;</span><span class="p">,</span>
<span class="o">-</span>      <span class="s">&#34;  - 0 : 1&#34;</span><span class="p">,</span>
<span class="o">-</span>      <span class="s">&#34;  - 1 : 2&#34;</span><span class="p">,</span>
<span class="o">-</span>      <span class="s">&#34;  - 2 : 3&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;- leaf (size 3)&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;  - 1&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;  - 2&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;  - 3&#34;</span><span class="p">,</span>
       <span class="s">&#34;db &gt; &#34;</span>
     <span class="p">])</span>
   <span class="n">end</span>

</code></pre></div><p>这是新测试的 <code>.btree</code> 输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="nl">Tree</span><span class="p">:</span>
<span class="o">-</span> <span class="n">internal</span> <span class="p">(</span><span class="n">size</span> <span class="mi">1</span><span class="p">)</span>
  <span class="o">-</span> <span class="n">leaf</span> <span class="p">(</span><span class="n">size</span> <span class="mi">7</span><span class="p">)</span>
    <span class="o">-</span> <span class="mi">1</span>
    <span class="o">-</span> <span class="mi">2</span>
    <span class="o">-</span> <span class="mi">3</span>
    <span class="o">-</span> <span class="mi">4</span>
    <span class="o">-</span> <span class="mi">5</span>
    <span class="o">-</span> <span class="mi">6</span>
    <span class="o">-</span> <span class="mi">7</span>
  <span class="o">-</span> <span class="n">key</span> <span class="mi">7</span>
  <span class="o">-</span> <span class="n">leaf</span> <span class="p">(</span><span class="n">size</span> <span class="mi">7</span><span class="p">)</span>
    <span class="o">-</span> <span class="mi">8</span>
    <span class="o">-</span> <span class="mi">9</span>
    <span class="o">-</span> <span class="mi">10</span>
    <span class="o">-</span> <span class="mi">11</span>
    <span class="o">-</span> <span class="mi">12</span>
    <span class="o">-</span> <span class="mi">13</span>
    <span class="o">-</span> <span class="mi">14</span>
</code></pre></div><p>在最少缩进的级别上，我们看到了根节点（内部节点）。它说 <code>size 1</code>，因为它有一个键。缩进一级，我们看到了一个叶节点、一个键，和另一个叶节点。根节点中的键值（7）是第一个叶节点中的最大键值。大于 7 的每个键都在第二个叶节点中。</p>
<h3 id="一个大问题">一个大问题</h3>
<p>如果你一直密切关注，你可能会注意到我们漏掉了一个很大的问题。看看如果我们尝试插入一行额外的数据会发生什么：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="n">db</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="k">insert</span><span class="w"> </span><span class="mi">15</span><span class="w"> </span><span class="n">user15</span><span class="w"> </span><span class="n">person15</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="w">
</span><span class="w"></span><span class="n">Need</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">implement</span><span class="w"> </span><span class="n">searching</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">internal</span><span class="w"> </span><span class="n">node</span><span class="w">
</span></code></pre></div><p>哎呀！谁写了这个 TODO 提示？ :P</p>
<p>下次我们将继续 B 树的史诗故事，实现在多级树上的搜索。</p>
<h2 id="第十一部分---递归搜索-b-树">第十一部分 - 递归搜索 B 树</h2>
<p>上次我们在插入第 15 行时出现了错误：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="n">db</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="k">insert</span><span class="w"> </span><span class="mi">15</span><span class="w"> </span><span class="n">user15</span><span class="w"> </span><span class="n">person15</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="w">
</span><span class="w"></span><span class="n">Need</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">implement</span><span class="w"> </span><span class="n">searching</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">internal</span><span class="w"> </span><span class="n">node</span><span class="w">
</span></code></pre></div><p>首先，用一个新的函数调用替换代码存根。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">get_node_type</span><span class="p">(</span><span class="n">root_node</span><span class="p">)</span> <span class="o">==</span> <span class="n">NODE_LEAF</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">leaf_node_find</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">root_page_num</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">internal_node_find</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">root_page_num</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>这个函数将执行二分搜索，以找到应包含给定键的子节点。记住，每个子指针右侧的键是该子节点包含的最大键。</p>
<p><img src="https://cstack.github.io/db_tutorial/assets/images/btree6.png" alt="three-level btree"></p>
<p>因此，我们的二分搜索比较要找到的键和子节点指针右侧的键：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">Cursor</span><span class="o">*</span> <span class="nf">internal_node_find</span><span class="p">(</span><span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">page_num</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">page_num</span><span class="p">);</span>
  <span class="kt">uint32_t</span> <span class="n">num_keys</span> <span class="o">=</span> <span class="o">*</span><span class="n">internal_node_num_keys</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

  <span class="cm">/* Binary search to find index of child to search */</span>
  <span class="kt">uint32_t</span> <span class="n">min_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">max_index</span> <span class="o">=</span> <span class="n">num_keys</span><span class="p">;</span> <span class="cm">/* there is one more child than key */</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">min_index</span> <span class="o">!=</span> <span class="n">max_index</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_index</span> <span class="o">+</span> <span class="n">max_index</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">key_to_right</span> <span class="o">=</span> <span class="o">*</span><span class="n">internal_node_key</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">key_to_right</span> <span class="o">&gt;=</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">max_index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">min_index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div><p>还要记住，内部节点的子节点可以是叶节点，也可以是更多的内部节点。在找到正确的子节点后，在其上调用适当的搜索函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">  <span class="kt">uint32_t</span> <span class="n">child_num</span> <span class="o">=</span> <span class="o">*</span><span class="n">internal_node_child</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">min_index</span><span class="p">);</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">child</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">child_num</span><span class="p">);</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">get_node_type</span><span class="p">(</span><span class="n">child</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">NODE_LEAF</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">leaf_node_find</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">child_num</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
    <span class="k">case</span> <span class="nl">NODE_INTERNAL</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">internal_node_find</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">child_num</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="测试">测试</h3>
<p>现在在多节点 B 树中插入一个键不再导致错误。我们可以更新我们的测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">       &#34;    - 12&#34;,
       &#34;    - 13&#34;,
       &#34;    - 14&#34;,
-      &#34;db &gt; Need to implement searching an internal node&#34;,
+      &#34;db &gt; Executed.&#34;,
+      &#34;db &gt; &#34;,
     ])
   end
</code></pre></div><p>我也认为是时候重新审视另一个测试了。试图插入 1400 行的测试。它仍然出错，但错误消息是新的。目前，我们的测试在程序崩溃时处理得并不好。如果发生这种情况，让我们只使用到目前为止得到的输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">     raw_output = nil
     IO.popen(&#34;./db test.db&#34;, &#34;r+&#34;) do |pipe|
       commands.each do |command|
-        pipe.puts command
+        begin
+          pipe.puts command
+        rescue Errno::EPIPE
+          break
+        end
       end

       pipe.close_write
</code></pre></div><p>这暴露了我们 1400 行测试的错误输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">     end
     script &lt;&lt; &#34;.exit&#34;
     result = run_script(script)
-    expect(result[-2]).to eq(&#39;db &gt; Error: Table full.&#39;)
+    expect(result.last(2)).to match_array([
+      &#34;db &gt; Executed.&#34;,
+      &#34;db &gt; Need to implement updating parent after split&#34;,
+    ])
   end
</code></pre></div><p>看起来这是我们接下来要做的事情！</p>
<h2 id="第十二部分---扫描多层-b-树">第十二部分 - 扫描多层 B 树</h2>
<p>我们现在支持构建多层 B 树，但在此过程中我们破坏了 <code>select</code> 语句。下面是一个测试案例，插入了 15 行然后尝试打印它们。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gi">+  it &#39;prints all rows in a multi-level tree&#39; do
</span><span class="gi">+    script = []
</span><span class="gi">+    (1..15).each do |i|
</span><span class="gi">+      script &lt;&lt; &#34;insert #{i} user#{i} person#{i}@example.com&#34;
</span><span class="gi">+    end
</span><span class="gi">+    script &lt;&lt; &#34;select&#34;
</span><span class="gi">+    script &lt;&lt; &#34;.exit&#34;
</span><span class="gi">+    result = run_script(script)
</span><span class="gi">+
</span><span class="gi">+    expect(result[15...result.length]).to match_array([
</span><span class="gi">+      &#34;db &gt; (1, user1, person1@example.com)&#34;,
</span><span class="gi">+      &#34;(2, user2, person2@example.com)&#34;,
</span><span class="gi">+      &#34;(3, user3, person3@example.com)&#34;,
</span><span class="gi">+      &#34;(4, user4, person4@example.com)&#34;,
</span><span class="gi">+      &#34;(5, user5, person5@example.com)&#34;,
</span><span class="gi">+      &#34;(6, user6, person6@example.com)&#34;,
</span><span class="gi">+      &#34;(7, user7, person7@example.com)&#34;,
</span><span class="gi">+      &#34;(8, user8, person8@example.com)&#34;,
</span><span class="gi">+      &#34;(9, user9, person9@example.com)&#34;,
</span><span class="gi">+      &#34;(10, user10, person10@example.com)&#34;,
</span><span class="gi">+      &#34;(11, user11, person11@example.com)&#34;,
</span><span class="gi">+      &#34;(12, user12, person12@example.com)&#34;,
</span><span class="gi">+      &#34;(13, user13, person13@example.com)&#34;,
</span><span class="gi">+      &#34;(14, user14, person14@example.com)&#34;,
</span><span class="gi">+      &#34;(15, user15, person15@example.com)&#34;,
</span><span class="gi">+      &#34;Executed.&#34;, &#34;db &gt; &#34;,
</span><span class="gi">+    ])
</span><span class="gi">+  end
</span></code></pre></div><p>但当我们现在运行该测试案例时，实际发生的是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="n">db</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="k">select</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">user1</span><span class="p">,</span><span class="w"> </span><span class="n">person1</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="n">Executed</span><span class="p">.</span><span class="w">
</span></code></pre></div><p>这很奇怪。只打印了一行，并且该行看起来损坏了（注意 id 不匹配用户名）。</p>
<p>这种奇怪现象是因为 <code>execute_select()</code> 从表的开头开始，而我们当前的 <code>table_start()</code> 实现返回根节点的第 0 个单元格。但是我们的树的根现在是一个内部节点，它不包含任何行。打印出来的数据必须是当根节点是叶子节点时留下的。<code>execute_select()</code> 实际上应该返回最左边叶子节点的第 0 个单元格。</p>
<p>因此，去掉旧的实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">-</span><span class="n">Cursor</span><span class="o">*</span> <span class="n">table_start</span><span class="p">(</span><span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
<span class="o">-</span>  <span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Cursor</span><span class="p">));</span>
<span class="o">-</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">=</span> <span class="n">table</span><span class="p">;</span>
<span class="o">-</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">page_num</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">root_page_num</span><span class="p">;</span>
<span class="o">-</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">cell_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">-</span>
<span class="o">-</span>  <span class="kt">void</span><span class="o">*</span> <span class="n">root_node</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">root_page_num</span><span class="p">);</span>
<span class="o">-</span>  <span class="kt">uint32_t</span> <span class="n">num_cells</span> <span class="o">=</span> <span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">root_node</span><span class="p">);</span>
<span class="o">-</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">end_of_table</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_cells</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="o">-</span>
<span class="o">-</span>  <span class="k">return</span> <span class="n">cursor</span><span class="p">;</span>
<span class="o">-</span><span class="p">}</span>
</code></pre></div><p>并添加一个新的实现，搜索键为 0（可能不存在于表中，但此方法将返回最小 id 的位置，即最左叶子节点的开头）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span><span class="n">Cursor</span><span class="o">*</span> <span class="n">table_start</span><span class="p">(</span><span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span> <span class="o">=</span>  <span class="n">table_find</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="kt">void</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">page_num</span><span class="p">);</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">num_cells</span> <span class="o">=</span> <span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="o">+</span>  <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">end_of_table</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_cells</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="k">return</span> <span class="n">cursor</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span>
</code></pre></div><p>有了这些更改，它仍然只打印了一节点的行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="n">db</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="k">select</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">user1</span><span class="p">,</span><span class="w"> </span><span class="n">person1</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">user2</span><span class="p">,</span><span class="w"> </span><span class="n">person2</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">user3</span><span class="p">,</span><span class="w"> </span><span class="n">person3</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">user4</span><span class="p">,</span><span class="w"> </span><span class="n">person4</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">user5</span><span class="p">,</span><span class="w"> </span><span class="n">person5</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="n">user6</span><span class="p">,</span><span class="w"> </span><span class="n">person6</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">user7</span><span class="p">,</span><span class="w"> </span><span class="n">person7</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="n">Executed</span><span class="p">.</span><span class="w">
</span><span class="w"></span><span class="n">db</span><span class="w"> </span><span class="o">&gt;</span><span class="w">
</span></code></pre></div><p>有 15 条目，我们的 B 树包含一个内部节点和两个叶子节点，大致如下：</p>
<p><img src="https://cstack.github.io/db_tutorial/assets/images/btree3.png" alt="我们的 B 树结构"></p>
<p>为了扫描整个表，我们需要在到达第一个叶子节点的末尾后跳转到第二个叶子节点。为此，我们将在叶子节点头部添加一个新的字段，称为 “next_leaf”，它将保存右侧叶子节点的页面号。最右侧的叶子节点的 <code>next_leaf</code> 值将为 0，表示没有兄弟节点（页面 0 通常保留给表的根节点）。</p>
<p>更新叶子节点头部格式以包括新的字段：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"> <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LEAF_NODE_NUM_CELLS_SIZE</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
 <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LEAF_NODE_NUM_CELLS_OFFSET</span> <span class="o">=</span> <span class="n">COMMON_NODE_HEADER_SIZE</span><span class="p">;</span>
<span class="o">-</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LEAF_NODE_HEADER_SIZE</span> <span class="o">=</span>
<span class="o">-</span>    <span class="n">COMMON_NODE_HEADER_SIZE</span> <span class="o">+</span> <span class="n">LEAF_NODE_NUM_CELLS_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LEAF_NODE_NEXT_LEAF_SIZE</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LEAF_NODE_NEXT_LEAF_OFFSET</span> <span class="o">=</span>
<span class="o">+</span>    <span class="n">LEAF_NODE_NUM_CELLS_OFFSET</span> <span class="o">+</span> <span class="n">LEAF_NODE_NUM_CELLS_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">LEAF_NODE_HEADER_SIZE</span> <span class="o">=</span> <span class="n">COMMON_NODE_HEADER_SIZE</span> <span class="o">+</span>
<span class="o">+</span>                                       <span class="n">LEAF_NODE_NUM_CELLS_SIZE</span> <span class="o">+</span>
<span class="o">+</span>                                       <span class="n">LEAF_NODE_NEXT_LEAF_SIZE</span><span class="p">;</span>
 
</code></pre></div><p>添加一个访问新字段的方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="n">leaf_node_next_leaf</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="k">return</span> <span class="n">node</span> <span class="o">+</span> <span class="n">LEAF_NODE_NEXT_LEAF_OFFSET</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span>
</code></pre></div><p>在初始化新的叶子节点时，默认将 <code>next_leaf</code> 设置为 0：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="err">@@</span> <span class="o">-</span><span class="mi">322</span><span class="p">,</span><span class="mi">6</span> <span class="o">+</span><span class="mi">330</span><span class="p">,</span><span class="mi">7</span> <span class="err">@@</span> <span class="kt">void</span> <span class="n">initialize_leaf_node</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">set_node_type</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">NODE_LEAF</span><span class="p">);</span>
   <span class="n">set_node_root</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
   <span class="o">*</span><span class="n">leaf_node_num_cells</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">+</span>  <span class="o">*</span><span class="n">leaf_node_next_leaf</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 0 表示无兄弟节点
</span><span class="c1"></span> <span class="p">}</span>
</code></pre></div><p>每当我们拆分叶子节点时，更新兄弟节点指针。旧叶子节点的兄弟节点变成新的叶子节点，新叶子节点的兄弟节点变成旧叶子节点的兄弟节点。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="err">@@</span> <span class="o">-</span><span class="mi">659</span><span class="p">,</span><span class="mi">6</span> <span class="o">+</span><span class="mi">671</span><span class="p">,</span><span class="mi">8</span> <span class="err">@@</span> <span class="kt">void</span> <span class="n">leaf_node_split_and_insert</span><span class="p">(</span><span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">key</span><span class="p">,</span> <span class="n">Row</span><span class="o">*</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
   <span class="kt">uint32_t</span> <span class="n">new_page_num</span> <span class="o">=</span> <span class="n">get_unused_page_num</span><span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">);</span>
   <span class="kt">void</span><span class="o">*</span> <span class="n">new_node</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">new_page_num</span><span class="p">);</span>
   <span class="n">initialize_leaf_node</span><span class="p">(</span><span class="n">new_node</span><span class="p">);</span>
<span class="o">+</span>  <span class="o">*</span><span class="n">leaf_node_next_leaf</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">leaf_node_next_leaf</span><span class="p">(</span><span class="n">old_node</span><span class="p">);</span>
<span class="o">+</span>  <span class="o">*</span><span class="n">leaf_node_next_leaf</span><span class="p">(</span><span class="n">old_node</span><span class="p">)</span> <span class="o">=</span> <span class="n">new_page_num</span><span class="p">;</span>
</code></pre></div><p>添加新字段会更改一些常量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff">   it &#39;prints constants&#39; do
     script = [
       &#34;.constants&#34;,
<span class="gu">@@ -199,9 +228,9 @@ describe &#39;database&#39; do
</span><span class="gu"></span>       &#34;db &gt; Constants:&#34;,
       &#34;ROW_SIZE: 293&#34;,
       &#34;COMMON_NODE_HEADER_SIZE: 6&#34;,
<span class="gd">-      &#34;LEAF_NODE_HEADER_SIZE: 10&#34;,
</span><span class="gd"></span><span class="gi">+      &#34;LEAF_NODE_HEADER_SIZE: 14&#34;,
</span><span class="gi"></span>       &#34;LEAF_NODE_CELL_SIZE: 297&#34;,
<span class="gd">-      &#34;LEAF_NODE_SPACE_FOR_CELLS: 4086&#34;,
</span><span class="gd"></span><span class="gi">+      &#34;LEAF_NODE_SPACE_FOR_CELLS: 4082&#34;,
</span><span class="gi"></span>       &#34;LEAF_NODE_MAX_CELLS: 13&#34;,
       &#34;db &gt; &#34;,
     ])
</code></pre></div><p>现在，每当我们想要推进游标超出叶子节点的末尾时，可以检查叶子节点是否有兄弟节点。如果有，就跳到兄弟节点；否则，我们到达表的末尾。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gu">@@ -428,7 +432,15 @@ void cursor_advance(Cursor* cursor) {
</span><span class="gu"></span> 
   cursor-&gt;cell_num += 1;
   if (cursor-&gt;cell_num &gt;= (*leaf_node_num_cells(node))) {
<span class="gd">-    cursor-&gt;end_of_table = true;
</span><span class="gd"></span><span class="gi">+    /* 前进到下一个叶子节点 */
</span><span class="gi">+    uint32_t next_page_num = *leaf_node_next_leaf(node);
</span><span class="gi">+    if (next_page_num == 0) {
</span><span class="gi">+      /* 这是最右边的叶子节点 */
</span><span class="gi">+      cursor-&gt;end_of_table = true;
</span><span class="gi">+    } else {
</span><span class="gi">+      cursor-&gt;page_num = next_page_num;
</span><span class="gi">+      cursor-&gt;cell_num = 0;
</span><span class="gi">+    }
</span><span class="gi"></span>   }
 }
</code></pre></div><p>在这些更改之后，我们实际上打印了 15 行&hellip;</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="n">db</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="k">select</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">user1</span><span class="p">,</span><span class="w"> </span><span class="n">person1</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">user2</span><span class="p">,</span><span class="w"> </span><span class="n">person2</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">user3</span><span class="p">,</span><span class="w"> </span><span class="n">person3</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">user4</span><span class="p">,</span><span class="w"> </span><span class="n">person4</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">user5</span><span class="p">,</span><span class="w"> </span><span class="n">person5</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="n">user6</span><span class="p">,</span><span class="w"> </span><span class="n">person6</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">user7</span><span class="p">,</span><span class="w"> </span><span class="n">person7</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">user8</span><span class="p">,</span><span class="w"> </span><span class="n">person8</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="n">user9</span><span class="p">,</span><span class="w"> </span><span class="n">person9</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="n">user10</span><span class="p">,</span><span class="w"> </span><span class="n">person10</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="n">user11</span><span class="p">,</span><span class="w"> </span><span class="n">person11</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="n">user12</span><span class="p">,</span><span class="w"> </span><span class="n">person12</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="n">user13</span><span class="p">,</span><span class="w"> </span><span class="n">person13</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">1919251317</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">,</span><span class="w"> </span><span class="n">on14</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="n">user15</span><span class="p">,</span><span class="w"> </span><span class="n">person15</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="n">Executed</span><span class="p">.</span><span class="w">
</span><span class="w"></span><span class="n">db</span><span class="w"> </span><span class="o">&gt;</span><span class="w">
</span></code></pre></div><p>&hellip;但其中一行看起来损坏了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">(1919251317, 14, on14@example.com)
</code></pre></div><p>经过一些调试，我发现是因为我们在拆分叶子节点时存在一个 bug：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="err">@@</span> <span class="o">-</span><span class="mi">676</span><span class="p">,</span><span class="mi">7</span> <span class="o">+</span><span class="mi">690</span><span class="p">,</span><span class="mi">9</span> <span class="err">@@</span> <span class="kt">void</span> <span class="n">leaf_node_split_and_insert</span><span class="p">(</span><span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">key</span><span class="p">,</span> <span class="n">Row</span><span class="o">*</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
     <span class="kt">void</span><span class="o">*</span> <span class="n">destination</span> <span class="o">=</span> <span class="n">leaf_node_cell</span><span class="p">(</span><span class="n">destination_node</span><span class="p">,</span> <span class="n">index_within_node</span><span class="p">);</span>
 
     <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">cell_num</span><span class="p">)</span> <span class="p">{</span>
<span class="o">-</span>      <span class="n">serialize_row</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">destination</span><span class="p">);</span>
<span class="o">+</span>      <span class="n">serialize_row</span><span class="p">(</span><span class="n">value</span><span class="p">,</span>
<span class="o">+</span>                    <span class="n">leaf_node_value</span><span class="p">(</span><span class="n">destination_node</span><span class="p">,</span> <span class="n">index_within_node</span><span class="p">));</span>
<span class="o">+</span>      <span class="o">*</span><span class="n">leaf_node_key</span><span class="p">(</span><span class="n">destination_node</span><span class="p">,</span> <span class="n">index_within_node</span><span class="p">)</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
     <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">cell_num</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">memcpy</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="n">leaf_node_cell</span><span class="p">(</span><span class="n">old_node</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">LEAF_NODE_CELL_SIZE</span><span class="p">);</span>
     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</code></pre></div><p>请记住，叶子节点中的每个单元格首先是一个键，然后是一个值：</p>
<p><img src="https://cstack.github.io/db_tutorial/assets/images/leaf-node-format.png" alt="原始叶子节点格式"></p>
<p>我们将新行（值）写入了单元格的开头，而其中应该放置键。这意味着用户名的一部分进入了 id 的部分（因此 id 很大）。</p>
<p>修复了这个 bug 之后，我们最终按预期打印了整个表：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="n">db</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="k">select</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">user1</span><span class="p">,</span><span class="w"> </span><span class="n">person1</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">user2</span><span class="p">,</span><span class="w"> </span><span class="n">person2</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">user3</span><span class="p">,</span><span class="w"> </span><span class="n">person3</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">user4</span><span class="p">,</span><span class="w"> </span><span class="n">person4</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">user5</span><span class="p">,</span><span class="w"> </span><span class="n">person5</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="n">user6</span><span class="p">,</span><span class="w"> </span><span class="n">person6</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">user7</span><span class="p">,</span><span class="w"> </span><span class="n">person7</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">user8</span><span class="p">,</span><span class="w"> </span><span class="n">person8</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="n">user9</span><span class="p">,</span><span class="w"> </span><span class="n">person9</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="n">user10</span><span class="p">,</span><span class="w"> </span><span class="n">person10</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="n">user11</span><span class="p">,</span><span class="w"> </span><span class="n">person11</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="n">user12</span><span class="p">,</span><span class="w"> </span><span class="n">person12</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="n">user13</span><span class="p">,</span><span class="w"> </span><span class="n">person13</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">14</span><span class="p">,</span><span class="w"> </span><span class="n">user14</span><span class="p">,</span><span class="w"> </span><span class="n">person14</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="w"> </span><span class="n">user15</span><span class="p">,</span><span class="w"> </span><span class="n">person15</span><span class="o">@</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="n">Executed</span><span class="p">.</span><span class="w">
</span><span class="w"></span><span class="n">db</span><span class="w"> </span><span class="o">&gt;</span><span class="w">
</span></code></pre></div><p>哇！一个接一个的 bug，但我们正在取得进展。</p>
<p>下次再见。</p>
<h2 id="第十三部分---分裂叶子节点后更新父节点">第十三部分 - 分裂叶子节点后更新父节点</h2>
<p>在我们史诗般的 B 树实现旅程中的下一步，我们将处理分裂叶子节点后修复父节点。我将使用以下示例作为参考：</p>
<p><img src="https://cstack.github.io/db_tutorial/assets/images/updating-internal-node.png" alt="更新内部节点示例"></p>
<p>在这个示例中，我们将键“3”添加到树中。这导致左叶子节点分裂。在分裂后，我们进行以下操作来修复树：</p>
<ol>
<li>将父节点中的第一个键更新为左子节点中的最大键（“3”）</li>
<li>在更新后的键之后添加一个新的子节点/键对
<ul>
<li>新指针指向新的子节点</li>
<li>新键是新子节点中的最大键（“5”）</li>
</ul>
</li>
</ol>
<p>首先，替换我们的存根代码为两个新的函数调用：<code>update_internal_node_key()</code> 用于步骤 1 和 <code>internal_node_insert()</code> 用于步骤 2。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="err">@@</span> <span class="o">-</span><span class="mi">670</span><span class="p">,</span><span class="mi">9</span> <span class="o">+</span><span class="mi">725</span><span class="p">,</span><span class="mi">11</span> <span class="err">@@</span> <span class="kt">void</span> <span class="n">leaf_node_split_and_insert</span><span class="p">(</span><span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">key</span><span class="p">,</span> <span class="n">Row</span><span class="o">*</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
   <span class="err">*/</span>
 
   <span class="kt">void</span><span class="o">*</span> <span class="n">old_node</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">cursor</span><span class="o">-&gt;</span><span class="n">page_num</span><span class="p">);</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">old_max</span> <span class="o">=</span> <span class="n">get_node_max_key</span><span class="p">(</span><span class="n">old_node</span><span class="p">);</span>
   <span class="kt">uint32_t</span> <span class="n">new_page_num</span> <span class="o">=</span> <span class="n">get_unused_page_num</span><span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">);</span>
   <span class="kt">void</span><span class="o">*</span> <span class="n">new_node</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">new_page_num</span><span class="p">);</span>
   <span class="n">initialize_leaf_node</span><span class="p">(</span><span class="n">new_node</span><span class="p">);</span>
<span class="o">+</span>  <span class="o">*</span><span class="n">node_parent</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">node_parent</span><span class="p">(</span><span class="n">old_node</span><span class="p">);</span>
   <span class="o">*</span><span class="n">leaf_node_next_leaf</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">leaf_node_next_leaf</span><span class="p">(</span><span class="n">old_node</span><span class="p">);</span>
   <span class="o">*</span><span class="n">leaf_node_next_leaf</span><span class="p">(</span><span class="n">old_node</span><span class="p">)</span> <span class="o">=</span> <span class="n">new_page_num</span><span class="p">;</span>
 
<span class="err">@@</span> <span class="o">-</span><span class="mi">709</span><span class="p">,</span><span class="mi">8</span> <span class="o">+</span><span class="mi">766</span><span class="p">,</span><span class="mi">12</span> <span class="err">@@</span> <span class="kt">void</span> <span class="n">leaf_node_split_and_insert</span><span class="p">(</span><span class="n">Cursor</span><span class="o">*</span> <span class="n">cursor</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">key</span><span class="p">,</span> <span class="n">Row</span><span class="o">*</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">is_node_root</span><span class="p">(</span><span class="n">old_node</span><span class="p">))</span> <span class="p">{</span>
     <span class="k">return</span> <span class="n">create_new_root</span><span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">,</span> <span class="n">new_page_num</span><span class="p">);</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="o">-</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Need to implement updating parent after split</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="o">-</span>    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="o">+</span>    <span class="kt">uint32_t</span> <span class="n">parent_page_num</span> <span class="o">=</span> <span class="o">*</span><span class="n">node_parent</span><span class="p">(</span><span class="n">old_node</span><span class="p">);</span>
<span class="o">+</span>    <span class="kt">uint32_t</span> <span class="n">new_max</span> <span class="o">=</span> <span class="n">get_node_max_key</span><span class="p">(</span><span class="n">old_node</span><span class="p">);</span>
<span class="o">+</span>    <span class="kt">void</span><span class="o">*</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">parent_page_num</span><span class="p">);</span>
<span class="o">+</span>
<span class="o">+</span>    <span class="n">update_internal_node_key</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">old_max</span><span class="p">,</span> <span class="n">new_max</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">internal_node_insert</span><span class="p">(</span><span class="n">cursor</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">,</span> <span class="n">parent_page_num</span><span class="p">,</span> <span class="n">new_page_num</span><span class="p">);</span>
<span class="o">+</span>    <span class="k">return</span><span class="p">;</span>
   <span class="p">}</span>
 <span class="p">}</span>
</code></pre></div><p>为了获取父节点的引用，我们需要开始在每个节点中记录指向其父节点的指针。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="n">node_parent</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">node</span> <span class="o">+</span> <span class="n">PARENT_POINTER_OFFSET</span><span class="p">;</span> <span class="p">}</span>
<span class="err">@@</span> <span class="o">-</span><span class="mi">660</span><span class="p">,</span><span class="mi">6</span> <span class="o">+</span><span class="mi">675</span><span class="p">,</span><span class="mi">48</span> <span class="err">@@</span> <span class="kt">void</span> <span class="n">create_new_root</span><span class="p">(</span><span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">right_child_page_num</span><span class="p">)</span> <span class="p">{</span>
   <span class="kt">uint32_t</span> <span class="n">left_child_max_key</span> <span class="o">=</span> <span class="n">get_node_max_key</span><span class="p">(</span><span class="n">left_child</span><span class="p">);</span>
   <span class="o">*</span><span class="n">internal_node_key</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">left_child_max_key</span><span class="p">;</span>
   <span class="o">*</span><span class="n">internal_node_right_child</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">=</span> <span class="n">right_child_page_num</span><span class="p">;</span>
<span class="o">+</span>  <span class="o">*</span><span class="n">node_parent</span><span class="p">(</span><span class="n">left_child</span><span class="p">)</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">root_page_num</span><span class="p">;</span>
<span class="o">+</span>  <span class="o">*</span><span class="n">node_parent</span><span class="p">(</span><span class="n">right_child</span><span class="p">)</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">root_page_num</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div><p>现在我们需要找到受影响的父节点中的单元格。子节点不知道自己的页面号，所以我们无法查找它。但是它知道自己的最大键，所以我们可以在父节点中搜索该键。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span><span class="kt">void</span> <span class="n">update_internal_node_key</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">old_key</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">new_key</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">old_child_index</span> <span class="o">=</span> <span class="n">internal_node_find_child</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">old_key</span><span class="p">);</span>
<span class="o">+</span>  <span class="o">*</span><span class="n">internal_node_key</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">old_child_index</span><span class="p">)</span> <span class="o">=</span> <span class="n">new_key</span><span class="p">;</span>
<span class="o">+</span><span class="p">}</span>
</code></pre></div><p>在 <code>internal_node_find_child()</code> 中，我们将重用已经存在的用于在内部节点中查找键的一些代码。重构 <code>internal_node_find()</code> 以使用新的辅助方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">-</span><span class="kt">uint32_t</span><span class="o">*</span> <span class="n">internal_node_key</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">key_num</span><span class="p">)</span> <span class="p">{</span>
<span class="o">-</span>  <span class="k">return</span> <span class="n">internal_node_cell</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">key_num</span><span class="p">)</span> <span class="o">+</span> <span class="n">INTERNAL_NODE_CHILD_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="kt">uint32_t</span> <span class="n">internal_node_find_child</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="cm">/*
</span><span class="cm">+  返回应包含给定键的子节点的索引。
</span><span class="cm">+  */</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">num_keys</span> <span class="o">=</span> <span class="o">*</span><span class="n">internal_node_num_keys</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="cm">/* 二分查找 */</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">min_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">max_index</span> <span class="o">=</span> <span class="n">num_keys</span><span class="p">;</span> <span class="cm">/* 子节点数比键数多一个 */</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="k">while</span> <span class="p">(</span><span class="n">min_index</span> <span class="o">!=</span> <span class="n">max_index</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="kt">uint32_t</span> <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_index</span> <span class="o">+</span> <span class="n">max_index</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="o">+</span>    <span class="kt">uint32_t</span> <span class="n">key_to_right</span> <span class="o">=</span> <span class="o">*</span><span class="n">internal_node_key</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
<span class="o">+</span>
<span class="o">+</span>    <span class="k">if</span> <span class="p">(</span><span class="n">key_to_right</span> <span class="o">&gt;=</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>      <span class="n">max_index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
<span class="o">+</span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="o">+</span>      <span class="n">min_index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="o">+</span>    <span class="p">}</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="k">return</span> <span class="n">min_index</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div><p>现在让我们来看看 <code>internal_node_insert()</code> 的其余部分。我会分步解释。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span><span class="kt">void</span> <span class="n">internal_node_insert</span><span class="p">(</span><span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">parent_page_num</span><span class="p">,</span>
<span class="o">+</span>                          <span class="kt">uint32_t</span> <span class="n">child_page_num</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>  <span class="cm">/*
</span><span class="cm">+  向父节点添加一个新的子节点/键对，对应于子节点
</span><span class="cm">+  */</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="kt">void</span><span class="o">*</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">parent_page_num</span><span class="p">);</span>
<span class="o">+</span>  <span class="kt">void</span><span class="o">*</span> <span class="n">child</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">child_page_num</span><span class="p">);</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">child_max_key</span> <span class="o">=</span> <span class="n">get_node_max_key</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">internal_node_find_child</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">child_max_key</span><span class="p">);</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">original_num_keys</span> <span class="o">=</span> <span class="o">*</span><span class="n">internal_node_num_keys</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
<span class="o">+</span>  <span class="o">*</span><span class="n">internal_node_num_keys</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="o">=</span> <span class="n">original_num_keys</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">original_num_keys</span> <span class="o">&gt;=</span> <span class="n">INTERNAL_NODE_MAX_CELLS</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Need to implement splitting internal node</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="o">+</span>    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="o">+</span>  <span class="p">}</span>
</code></pre></div><p>新单元格（子节点/键对）应该插入的索引取决于新子节点中的最大键。在我们查看的示例中，<code>child_max_key</code> 将为 5，<code>index</code> 将为 1。</p>
<p>如果内部节点没有足够的空间容纳另一个单元格，则抛出错误。稍后我们将实现这一点。</p>
<p>现在让我们看看函数的其余部分：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span>
<span class="o">+</span>  <span class="kt">uint32_t</span> <span class="n">right_child_page_num</span> <span class="o">=</span> <span class="o">*</span><span class="n">internal_node_right_child</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
<span class="o">+</span>  <span class="kt">void</span><span class="o">*</span> <span class="n">right_child</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">pager</span><span class="p">,</span> <span class="n">right_child_page_num</span><span class="p">);</span>
<span class="o">+</span>
<span class="o">+</span>  <span class="k">if</span> <span class="p">(</span><span class="n">child_max_key</span> <span class="o">&gt;</span> <span class="n">get_node_max_key</span><span class="p">(</span><span class="n">right_child</span><span class="p">))</span> <span class="p">{</span>
<span class="o">+</span>    <span class="cm">/* 替换右子节点 */</span>
<span class="o">+</span>    <span class="o">*</span><span class="n">internal_node_child</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">original_num_keys</span><span class="p">)</span> <span class="o">=</span> <span class="n">right_child_page_num</span><span class="p">;</span>
<span class="o">+</span>    <span class="o">*</span><span class="n">internal_node_key</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">original_num_keys</span><span class="p">)</span> <span class="o">=</span>
<span class="o">+</span>        <span class="n">get_node_max_key</span><span class="p">(</span><span class="n">right_child</span><span class="p">);</span>
<span class="o">+</span>    <span class="o">*</span><span class="n">internal_node_right_child</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="o">=</span> <span class="n">child_page_num</span><span class="p">;</span>
<span class="o">+</span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="o">+</span>    <span class="cm">/* 为新单元格腾出空间 */</span>
<span class="o">+</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">original_num_keys</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">index</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
<span class="o">+</span>      <span class="kt">void</span><span class="o">*</span> <span class="n">destination</span> <span class="o">=</span> <span class="n">internal_node_cell</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="o">+</span>      <span class="kt">void</span><span class="o">*</span> <span class="n">source</span> <span class="o">=</span> <span class="n">internal_node_cell</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="o">+</span>      <span class="n">memcpy</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">INTERNAL_NODE_CELL_SIZE</span><span class="p">);</span>
<span class="o">+</span>    <span class="p">}</span>
<span class="o">+</span>    <span class="o">*</span><span class="n">internal_node_child</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="o">=</span> <span class="n">child_page_num</span><span class="p">;</span>
<span class="o">+</span>    <span class="o">*</span><span class="n">internal_node_key</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="o">=</span> <span class="n">child_max_key</span><span class="p">;</span>
<span class="o">+</span>  <span class="p">}</span>
<span class="o">+</span><span class="p">}</span>
</code></pre></div><p>因为我们单独存储了最右边的子节点指针和其他子节点/键对，所以如果新子节点将成为最右边的子节点，则必须以不同的方式处理事情。</p>
<p>在我们的示例中，我们将进入 <code>else</code> 块。首先，我们为新单元格腾出空间，将其他单元格向右移动一位。（尽管在我们的示例中没有要移动的单元格）</p>
<p>接下来，我们将新子节点指针和键写入由 <code>index</code> 确定的单元格。</p>
<p>为了减少所需的测试用例大小，我现在先硬编码 <code>INTERNAL_NODE_MAX_CELLS</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="err">@@</span> <span class="o">-</span><span class="mi">126</span><span class="p">,</span><span class="mi">6</span> <span class="o">+</span><span class="mi">126</span><span class="p">,</span><span class="mi">8</span> <span class="err">@@</span> <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">INTERNAL_NODE_KEY_SIZE</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
 <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">INTERNAL_NODE_CHILD_SIZE</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
 <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">INTERNAL_NODE_CELL_SIZE</span> <span class="o">=</span>
     <span class="n">INTERNAL_NODE_CHILD_SIZE</span> <span class="o">+</span> <span class="n">INTERNAL_NODE_KEY_SIZE</span><span class="p">;</span>
<span class="o">+</span><span class="cm">/* 为了测试，保持较小 */</span>
<span class="o">+</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">INTERNAL_NODE_MAX_CELLS</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</code></pre></div><p>说到测试，我们的大型数据集测试已经通过了旧的存根，并且到达了我们的新存根：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="err">@@</span> <span class="o">-</span><span class="mi">65</span><span class="p">,</span><span class="mi">7</span> <span class="o">+</span><span class="mi">65</span><span class="p">,</span><span class="mi">7</span> <span class="err">@@</span> <span class="n">describe</span> <span class="err">&#39;</span><span class="n">database</span><span class="err">&#39;</span> <span class="k">do</span>
     <span class="n">result</span> <span class="o">=</span> <span class="n">run_script</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
     <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">last</span><span class="p">(</span><span class="mi">2</span><span class="p">)).</span><span class="n">to</span> <span class="n">match_array</span><span class="p">([</span>
       <span class="s">&#34;db &gt; Executed.&#34;</span><span class="p">,</span>
<span class="o">-</span>      <span class="s">&#34;db &gt; Need to implement updating parent after split&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;db &gt; Need to implement splitting internal node&#34;</span><span class="p">,</span>
     <span class="p">])</span>
</code></pre></div><p>非常令人满意，我知道。</p>
<p>我将添加另一个测试，用于打印一个四节点树的结构。为了测试更多情况，而不仅仅是顺序 id，这个测试将以伪随机顺序添加记录。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">+</span>  <span class="n">it</span> <span class="err">&#39;</span><span class="n">allows</span> <span class="n">printing</span> <span class="n">out</span> <span class="n">the</span> <span class="n">structure</span> <span class="n">of</span> <span class="n">a</span> <span class="mi">4</span><span class="o">-</span><span class="n">leaf</span><span class="o">-</span><span class="n">node</span> <span class="n">btree</span><span class="err">&#39;</span> <span class="k">do</span>
<span class="o">+</span>    <span class="n">script</span> <span class="o">=</span> <span class="p">[</span>
<span class="o">+</span>      <span class="s">&#34;insert 18 user18 person18@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 7 user7 person7@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 10 user10 person10@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 29 user29 person29@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 23 user23 person23@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 4 user4 person4@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 14 user14 person14@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 30 user30 person30@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 15 user15 person15@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 26 user26 person26@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 22 user22 person22@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 19 user19 person19@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 2 user2 person2@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 1 user1 person1@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 21 user21 person21@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 11 user11 person11@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 6 user6 person6@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 20 user20 person20@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 5 user5 person5@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 8 user8 person8@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 9 user9 person9@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 3 user3 person3@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 12 user12 person12@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 27 user27 person27@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 17 user17 person17@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 16 user16 person16@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 13 user13 person13@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 24 user24 person24@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 25 user25 person25@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;insert 28 user28 person28@example.com&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;.btree&#34;</span><span class="p">,</span>
<span class="o">+</span>      <span class="s">&#34;.exit&#34;</span><span class="p">,</span>
<span class="o">+</span>    <span class="p">]</span>
<span class="o">+</span>    <span class="n">result</span> <span class="o">=</span> <span class="n">run_script</span><span class="p">(</span><span class="n">script</span><span class="p">)</span>
</code></pre></div><p>目前，它将输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="o">-</span> <span class="n">internal</span> <span class="p">(</span><span class="n">size</span> <span class="mi">3</span><span class="p">)</span>
  <span class="o">-</span> <span class="n">leaf</span> <span class="p">(</span><span class="n">size</span> <span class="mi">7</span><span class="p">)</span>
    <span class="o">-</span> <span class="mi">1</span>
    <span class="o">-</span> <span class="mi">2</span>
    <span class="o">-</span> <span class="mi">3</span>
    <span class="o">-</span> <span class="mi">4</span>
    <span class="o">-</span> <span class="mi">5</span>
    <span class="o">-</span> <span class="mi">6</span>
    <span class="o">-</span> <span class="mi">7</span>
  <span class="o">-</span> <span class="n">key</span> <span class="mi">1</span>
  <span class="o">-</span> <span class="n">leaf</span> <span class="p">(</span><span class="n">size</span> <span class="mi">8</span><span class="p">)</span>
    <span class="o">-</span> <span class="mi">8</span>
    <span class="o">-</span> <span class="mi">9</span>
    <span class="o">-</span> <span class="mi">10</span>
    <span class="o">-</span> <span class="mi">11</span>
    <span class="o">-</span> <span class="mi">12</span>
    <span class="o">-</span> <span class="mi">13</span>
    <span class="o">-</span> <span class="mi">14</span>
    <span class="o">-</span> <span class="mi">15</span>
  <span class="o">-</span> <span class="n">key</span> <span class="mi">15</span>
  <span class="o">-</span> <span class="n">leaf</span> <span class="p">(</span><span class="n">size</span> <span class="mi">7</span><span class="p">)</span>
    <span class="o">-</span> <span class="mi">16</span>
    <span class="o">-</span> <span class="mi">17</span>
    <span class="o">-</span> <span class="mi">18</span>
    <span class="o">-</span> <span class="mi">19</span>
    <span class="o">-</span> <span class="mi">20</span>
    <span class="o">-</span> <span class="mi">21</span>
    <span class="o">-</span> <span class="mi">22</span>
  <span class="o">-</span> <span class="n">key</span> <span class="mi">22</span>
  <span class="o">-</span> <span class="n">leaf</span> <span class="p">(</span><span class="n">size</span> <span class="mi">8</span><span class="p">)</span>
    <span class="o">-</span> <span class="mi">23</span>
    <span class="o">-</span> <span class="mi">24</span>
    <span class="o">-</span> <span class="mi">25</span>
    <span class="o">-</span> <span class="mi">26</span>
    <span class="o">-</span> <span class="mi">27</span>
    <span class="o">-</span> <span class="mi">28</span>
    <span class="o">-</span> <span class="mi">29</span>
    <span class="o">-</span> <span class="mi">30</span>
<span class="n">db</span> <span class="o">&gt;</span>
</code></pre></div><p>仔细观察，您会发现一个 bug：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">    <span class="o">-</span> <span class="mi">5</span>
    <span class="o">-</span> <span class="mi">6</span>
    <span class="o">-</span> <span class="mi">7</span>
  <span class="o">-</span> <span class="n">key</span> <span class="mi">1</span>
</code></pre></div><p>那里的键应该是 7，而不是 1！</p>
<p>经过一番调试，我发现这是由于一些错误的指针算术引起的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"> <span class="kt">uint32_t</span><span class="o">*</span> <span class="nf">internal_node_key</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">key_num</span><span class="p">)</span> <span class="p">{</span>
<span class="o">-</span>  <span class="k">return</span> <span class="n">internal_node_cell</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">key_num</span><span class="p">)</span> <span class="o">+</span> <span class="n">INTERNAL_NODE_CHILD_SIZE</span><span class="p">;</span>
<span class="o">+</span>  <span class="k">return</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">internal_node_cell</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">key_num</span><span class="p">)</span> <span class="o">+</span> <span class="n">INTERNAL_NODE_CHILD_SIZE</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div><p><code>INTERNAL_NODE_CHILD_SIZE</code> 是 4。我在这里的意图是将 4 字节添加到 <code>internal_node_cell()</code> 的结果中，但由于 <code>internal_node_cell()</code> 返回一个 <code>uint32_t*</code>，因此实际上添加了 <code>4 * sizeof(uint32_t)</code> 字节。我通过在进行算术运算之前将其转换为 <code>void*</code> 来进行修复。</p>
<p>注意！<a href="https://stackoverflow.com/questions/3523145/pointer-arithmetic-for-void-pointer-in-c/46238658#46238658">C 标准中没有 void 指针的指针算术，可能无法与你的编译器一起工作</a>。也许将来我会撰写一篇关于可移植性的文章，但目前我保留了我的 void 指针算术。</p>
<p>好的，又迈出了一步，朝着一个完全可操作的 B 树实现迈进。下一步应该是拆分内部节点。在那之前！</p>
<h2 id="第十四部分---拆分内部节点">第十四部分 - 拆分内部节点</h2>
<p>我们旅程的下一段将是拆分无法容纳新键的内部节点。考虑下面的例子：</p>
<p><img src="https://cstack.github.io/db_tutorial/assets/images/splitting-internal-node.png" alt="拆分内部节点的示例"></p>
<p>在这个例子中，我们向树中添加键“11”。这将导致我们的根节点拆分。在拆分内部节点时，为了保持一切的正常运作，我们需要做一些事情：</p>
<ol>
<li>创建一个兄弟节点来存储原始节点的(n-1)/2个键</li>
<li>将这些键从原始节点移动到兄弟节点</li>
<li>更新父节点中原始节点的键，以反映其在拆分后的新最大键</li>
<li>将兄弟节点插入父节点（可能导致父节点也被拆分）</li>
</ol>
<p>我们将首先用<code>internal_node_split_and_insert</code>来替换我们的存根代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gi">+void internal_node_split_and_insert(Table* table, uint32_t parent_page_num,
</span><span class="gi">+                          uint32_t child_page_num);
</span><span class="gi">+
</span><span class="gi"></span> void internal_node_insert(Table* table, uint32_t parent_page_num,
                           uint32_t child_page_num) {
   /*
<span class="gu">@@ -685,25 +714,39 @@ void internal_node_insert(Table* table, uint32_t parent_page_num,
</span><span class="gu"></span> 
   void* parent = get_page(table-&gt;pager, parent_page_num);
   void* child = get_page(table-&gt;pager, child_page_num);
<span class="gd">-  uint32_t child_max_key = get_node_max_key(child);
</span><span class="gd"></span><span class="gi">+  uint32_t child_max_key = get_node_max_key(table-&gt;pager, child);
</span><span class="gi"></span>   uint32_t index = internal_node_find_child(parent, child_max_key);
 
   uint32_t original_num_keys = *internal_node_num_keys(parent);
<span class="gd">-  *internal_node_num_keys(parent) = original_num_keys + 1;
</span><span class="gd"></span> 
   if (original_num_keys &gt;= INTERNAL_NODE_MAX_CELLS) {
<span class="gd">-    printf(&#34;Need to implement splitting internal node\n&#34;);
</span><span class="gd">-    exit(EXIT_FAILURE);
</span><span class="gd"></span><span class="gi">+    internal_node_split_and_insert(table, parent_page_num, child_page_num);
</span><span class="gi">+    return;
</span><span class="gi"></span>   }
 
   uint32_t right_child_page_num = *internal_node_right_child(parent);
<span class="gi">+  /*
</span><span class="gi">+  An internal node with a right child of INVALID_PAGE_NUM is empty
</span><span class="gi">+  */
</span><span class="gi">+  if (right_child_page_num == INVALID_PAGE_NUM) {
</span><span class="gi">+    *internal_node_right_child(parent) = child_page_num;
</span><span class="gi">+    return;
</span><span class="gi">+  }
</span><span class="gi">+
</span><span class="gi"></span>   void* right_child = get_page(table-&gt;pager, right_child_page_num);
<span class="gi">+  /*
</span><span class="gi">+  If we are already at the max number of cells for a node, we cannot increment
</span><span class="gi">+  before splitting. Incrementing without inserting a new key/child pair
</span><span class="gi">+  and immediately calling internal_node_split_and_insert has the effect
</span><span class="gi">+  of creating a new key at (max_cells + 1) with an uninitialized value
</span><span class="gi">+  */
</span><span class="gi">+  *internal_node_num_keys(parent) = original_num_keys + 1;
</span><span class="gi"></span> 
<span class="gd">-  if (child_max_key &gt; get_node_max_key(right_child)) {
</span><span class="gd"></span><span class="gi">+  if (child_max_key &gt; get_node_max_key(table-&gt;pager, right_child)) {
</span><span class="gi"></span>     /* Replace right child */
     *internal_node_child(parent, original_num_keys) = right_child_page_num;
     *internal_node_key(parent, original_num_keys) =
<span class="gd">-        get_node_max_key(right_child);
</span><span class="gd"></span><span class="gi">+        get_node_max_key(table-&gt;pager, right_child);
</span><span class="gi"></span>     *internal_node_right_child(parent) = child_page_num;
</code></pre></div><p>除了替换存根之外，这里我们进行了三个重要的更改：</p>
<ul>
<li>首先，<code>internal_node_split_and_insert</code>被提前声明，因为我们将在其定义中调用<code>internal_node_insert</code>，以避免代码重复。</li>
<li>此外，我们将递增父节点的键数逻辑移到函数定义的下方，以确保在拆分之前不要执行这一步。</li>
<li>最后，我们确保将插入到空内部节点的子节点成为该内部节点的右子节点，而不执行任何其他操作，因为空的内部节点没有其他可以操作的键。</li>
</ul>
<p>上述更改要求我们能够识别空节点 - 为此，我们首先定义一个常量，表示每个空节点的无效页面编号。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">+#define INVALID_PAGE_NUM UINT32_MAX
</code></pre></div><p>现在，当初始化内部节点时，我们将其右子节点初始化为此无效页面编号。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gu">@@ -330,6 +335,12 @@ void initialize_internal_node(void* node) {
</span><span class="gu"></span>   set_node_type(node, NODE_INTERNAL);
   set_node_root(node, false);
   *internal_node_num_keys(node) = 0;
<span class="gi">+  /*
</span><span class="gi">+  Necessary because the root page number is 0; by not initializing an internal 
</span><span class="gi">+  node&#39;s right child to an invalid page number when initializing the node, we may
</span><span class="gi">+  end up with 0 as the node&#39;s right child, which makes the node a parent of the root
</span><span class="gi">+  */
</span><span class="gi">+  *internal_node_right_child(node) = INVALID_PAGE_NUM;
</span><span class="gi"></span> }
</code></pre></div><p>这一步是必要的，因为上面的注释试图总结的问题 - 在初始化内部节点时，如果没有明确初始化右子节点字段，那么运行时该字段的值可能为0，这取决于编译器或程序执行的机器体系结构。由于我们使用0作为根页面编号，这意味着新分配的内部节点将是根的父节点。</p>
<p>我们在<code>internal_node_child</code>函数中添加了一些防护措施，在尝试访问无效页面时会引发错误。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gu">@@ -186,9 +188,19 @@ uint32_t* internal_node_child(void* node, uint32_t child_num) {
</span><span class="gu"></span>     printf(&#34;Tried to access child_num %d &gt; num_keys %d\n&#34;, child_num, num_keys);
     exit(EXIT_FAILURE);
   } else if (child_num == num_keys) {
<span class="gd">-    return internal_node_right_child(node);
</span><span class="gd"></span><span class="gi">+    uint32_t* right_child = internal_node_right_child(node);
</span><span class="gi">+    if (*right_child == INVALID_PAGE_NUM) {
</span><span class="gi">+      printf(&#34;Tried to access right child of node, but was invalid page\n&#34;);
</span><span class="gi">+      exit(EXIT_FAILURE);
</span><span class="gi">+    }
</span><span class="gi">+    return right_child;
</span><span class="gi"></span>   } else {
<span class="gd">-    return internal_node_cell(node, child_num);
</span><span class="gd"></span><span class="gi">+    uint32_t* child = internal_node_cell(node, child_num);
</span><span class="gi">+    if (*child == INVALID_PAGE_NUM) {
</span><span class="gi">+      printf(&#34;Tried to access child %d of node, but was invalid page\n&#34;, child_num);
</span><span class="gi">+      exit(EXIT_FAILURE);
</span><span class="gi">+    }
</span><span class="gi">+    return child;
</span><span class="gi"></span>   }
 }
</code></pre></div><p>我们的<code>print_tree</code>函数还需要添加一个防护措施，以确保我们不会尝试打印一个空节点，因为这会涉及尝试访问一个无效页面。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gu">@@ -294,15 +305,17 @@ void print_tree(Pager* pager, uint32_t page_num, uint32_t indentation_level) {
</span><span class="gu"></span>       num_keys = *internal_node_num_keys(node);
       indent(indentation_level);
       printf(&#34;- internal (size %d)\n&#34;, num_keys);
<span class="gd">-      for (uint32_t i = 0; i &lt; num_keys; i++) {
</span><span class="gd">-        child = *internal_node_child(node, i);
</span><span class="gd"></span><span class="gi">+      if (num_keys &gt; 0) {
</span><span class="gi">+        for (uint32_t i = 0; i &lt; num_keys; i++) {
</span><span class="gi">+          child = *internal_node_child(node, i);
</span><span class="gi">+          print_tree(pager, child, indentation_level + 1);
</span><span class="gi">+
</span><span class="gi">+          indent(indentation_level + 1);
</span><span class="gi">+          printf(&#34;- key %d\n&#34;, *internal_node_key(node, i));
</span><span class="gi">+        }
</span><span class="gi">+        child = *internal_node_right_child(node);
</span><span class="gi"></span>         print_tree(pager, child, indentation_level + 1);
<span class="gd">-
</span><span class="gd">-        indent(indentation_level + 1);
</span><span class="gd">-        printf(&#34;- key %d\n&#34;, *internal_node_key(node, i));
</span><span class="gd"></span>       }
<span class="gd">-      child = *internal_node_right_child(node);
</span><span class="gd">-      print_tree(pager, child, indentation_level + 1);
</span><span class="gd"></span>       break;
   }
 }
</code></pre></div><p>现在是关于 <code>internal_node_split_and_insert</code> 的主要部分。我们首先提供完整的内容，然后逐步分解说明。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gi">+void internal_node_split_and_insert(Table* table, uint32_t parent_page_num,
</span><span class="gi">+                          uint32_t child_page_num) {
</span><span class="gi">+  uint32_t old_page_num = parent_page_num;
</span><span class="gi">+  void* old_node = get_page(table-&gt;pager,parent_page_num);
</span><span class="gi">+  uint32_t old_max = get_node_max_key(table-&gt;pager, old_node);
</span><span class="gi">+
</span><span class="gi">+  void* child = get_page(table-&gt;pager, child_page_num); 
</span><span class="gi">+  uint32_t child_max = get_node_max_key(table-&gt;pager, child);
</span><span class="gi">+
</span><span class="gi">+  uint32_t new_page_num = get_unused_page_num(table-&gt;pager);
</span><span class="gi">+
</span><span class="gi">+  /*
</span><span class="gi">+  在更新指针之前声明一个标志，
</span><span class="gi">+  记录此操作是否涉及分割根节点 -
</span><span class="gi">+  如果是的话，我们将在创建表的新根时插入我们新创建的节点。
</span><span class="gi">+  如果不是，我们必须在旧节点的键已转移后将新创建的节点插入其父节点。
</span><span class="gi">+  如果新创建的节点的父节点不是新初始化的根节点，我们无法这样做，
</span><span class="gi">+  因为在这种情况下，其父节点可能有除我们正在分割的旧节点之外的现有键。
</span><span class="gi">+  如果是这样，我们需要在其父节点中为新创建的节点找到一个位置，
</span><span class="gi">+  如果它还没有任何键，则无法在正确的索引处插入它
</span><span class="gi">+  */
</span><span class="gi">+  uint32_t splitting_root = is_node_root(old_node);
</span><span class="gi">+
</span><span class="gi">+  void* parent;
</span><span class="gi">+  void* new_node;
</span><span class="gi">+  if (splitting_root) {
</span><span class="gi">+    create_new_root(table, new_page_num);
</span><span class="gi">+    parent = get_page(table-&gt;pager,table-&gt;root_page_num);
</span><span class="gi">+    /*
</span><span class="gi">+    如果我们正在分割根节点，我们需要将 old_node 更新为指向新根的左子节点，
</span><span class="gi">+    new_page_num 已经指向新根的右子节点
</span><span class="gi">+    */
</span><span class="gi">+    old_page_num = *internal_node_child(parent,0);
</span><span class="gi">+    old_node = get_page(table-&gt;pager, old_page_num);
</span><span class="gi">+  } else {
</span><span class="gi">+    parent = get_page(table-&gt;pager,*node_parent(old_node));
</span><span class="gi">+    new_node = get_page(table-&gt;pager, new_page_num);
</span><span class="gi">+    initialize_internal_node(new_node);
</span><span class="gi">+  }
</span><span class="gi">+  
</span><span class="gi">+  uint32_t* old_num_keys = internal_node_num_keys(old_node);
</span><span class="gi">+
</span><span class="gi">+  uint32_t cur_page_num = *internal_node_right_child(old_node);
</span><span class="gi">+  void* cur = get_page(table-&gt;pager, cur_page_num);
</span><span class="gi">+
</span><span class="gi">+  /*
</span><span class="gi">+  首先将右子节点放入新节点，并将旧节点的右子节点设置为无效页码
</span><span class="gi">+  */
</span><span class="gi">+  internal_node_insert(table, new_page_num, cur_page_num);
</span><span class="gi">+  *node_parent(cur) = new_page_num;
</span><span class="gi">+  *internal_node_right_child(old_node) = INVALID_PAGE_NUM;
</span><span class="gi">+  /*
</span><span class="gi">+  对于每个键，直到达到中间键，将键和子节点移动到新节点
</span><span class="gi">+  */
</span><span class="gi">+  for (int i = INTERNAL_NODE_MAX_CELLS - 1; i &gt; INTERNAL_NODE_MAX_CELLS / 2; i--) {
</span><span class="gi">+    cur_page_num = *internal_node_child(old_node, i);
</span><span class="gi">+    cur = get_page(table-&gt;pager, cur_page_num);
</span><span class="gi">+
</span><span class="gi">+    internal_node_insert(table, new_page_num, cur_page_num);
</span><span class="gi">+    *node_parent(cur) = new_page_num;
</span><span class="gi">+
</span><span class="gi">+    (*old_num_keys)--;
</span><span class="gi">+  }
</span><span class="gi">+
</span><span class="gi">+  /*
</span><span class="gi">+  设置中间键之前的子节点，现在是最高的键，为节点的右子节点，
</span><span class="gi">+  并减少键的数量
</span><span class="gi">+  */
</span><span class="gi">+  *internal_node_right_child(old_node) = *internal_node_child(old_node,*old_num_keys - 1);
</span><span class="gi">+  (*old_num_keys)--;
</span><span class="gi">+
</span><span class="gi">+  /*
</span><span class="gi">+  确定分割后的两个节点中应包含要插入的子节点，
</span><span class="gi">+  并插入子节点
</span><span class="gi">+  */
</span><span class="gi">+  uint32_t max_after_split = get_node_max_key(table-&gt;pager, old_node);
</span><span class="gi">+
</span><span class="gi">+  uint32_t destination_page_num = child_max &lt; max_after_split ? old_page_num : new_page_num;
</span><span class="gi">+
</span><span class="gi">+  internal_node_insert(table, destination_page_num, child_page_num);
</span><span class="gi">+  *node_parent(child) = destination_page_num;
</span><span class="gi">+
</span><span class="gi">+  update_internal_node_key(parent, old_max, get_node_max_key(table-&gt;pager, old_node));
</span><span class="gi">+
</span><span class="gi">+  if (!splitting_root) {
</span><span class="gi">+    internal_node_insert(table,*node_parent(old_node),new_page_num);
</span><span class="gi">+    *node_parent(new_node) = *node_parent(old_node);
</span><span class="gi">+  }
</span><span class="gi">+}
</span><span class="gi">+
</span></code></pre></div><p>我们首先需要创建一个变量来存储我们要拆分的节点的页面编号（从这里开始称为旧节点）。这是必要的，因为如果旧节点恰好是表的根节点，则旧节点的页面编号将会改变。我们还需要记住节点的当前最大值，因为该值代表其在父节点中的键，在拆分发生后，需要更新该键为旧节点的新最大值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gi">+  uint32_t old_page_num = parent_page_num;
</span><span class="gi">+  void* old_node = get_page(table-&gt;pager,parent_page_num);
</span><span class="gi">+  uint32_t old_max = get_node_max_key(table-&gt;pager, old_node);
</span></code></pre></div><p>下一个重要步骤是基于旧节点是否为表的根节点的分支逻辑。我们需要跟踪这个值以备后用；正如注释所述，如果我们不在函数定义的开始存储这些信息，我们将遇到问题——如果我们不是拆分根节点，则无法立即将新创建的兄弟节点插入到旧节点的父节点中，因为父节点还不包含任何键，因此新节点无法正确放置在父节点中的其他键/子节点对之间，这些键/子节点对可能已经存在于父节点中，也可能不存在。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gi">+  uint32_t splitting_root = is_node_root(old_node);
</span><span class="gi">+
</span><span class="gi">+  void* parent;
</span><span class="gi">+  void* new_node;
</span><span class="gi">+  if (splitting_root) {
</span><span class="gi">+    create_new_root(table, new_page_num);
</span><span class="gi">+    parent = get_page(table-&gt;pager,table-&gt;root_page_num);
</span><span class="gi">+    /*
</span><span class="gi">+    如果我们在拆分根节点，我们需要更新旧节点，使其指向新根节点的左子节点，而new_page_num将指向新根节点的右子节点
</span><span class="gi">+    */
</span><span class="gi">+    old_page_num = *internal_node_child(parent,0);
</span><span class="gi">+    old_node = get_page(table-&gt;pager, old_page_num);
</span><span class="gi">+  } else {
</span><span class="gi">+    parent = get_page(table-&gt;pager,*node_parent(old_node));
</span><span class="gi">+    new_node = get_page(table-&gt;pager, new_page_num);
</span><span class="gi">+    initialize_internal_node(new_node);
</span><span class="gi">+  }
</span></code></pre></div><p>当我们解决了是否拆分根节点的问题后，我们开始将键从旧节点移动到其兄弟节点。我们必须首先移动旧节点的右子节点，并将其右子节点字段设置为无效页面编号，以表示它为空。现在，我们循环遍历旧节点剩余的键，在每次迭代中执行以下步骤：</p>
<ol>
<li>获取旧节点当前索引处的键和子节点的引用</li>
<li>将子节点插入到兄弟节点中</li>
<li>更新子节点的父节点值，使其指向兄弟节点</li>
<li>减少旧节点的键数</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gi">+  uint32_t* old_num_keys = internal_node_num_keys(old_node);
</span><span class="gi">+
</span><span class="gi">+  uint32_t cur_page_num = *internal_node_right_child(old_node);
</span><span class="gi">+  void* cur = get_page(table-&gt;pager, cur_page_num);
</span><span class="gi">+
</span><span class="gi">+  /*
</span><span class="gi">+  首先将右子节点放入新节点中，并将旧节点的右子节点字段设置为无效页面编号
</span><span class="gi">+  */
</span><span class="gi">+  internal_node_insert(table, new_page_num, cur_page_num);
</span><span class="gi">+  *node_parent(cur) = new_page_num;
</span><span class="gi">+  *internal_node_right_child(old_node) = INVALID_PAGE_NUM;
</span><span class="gi">+  /*
</span><span class="gi">+  对于每个键，直到达到中间键，将键和子节点移动到新节点中
</span><span class="gi">+  */
</span><span class="gi">+  for (int i = INTERNAL_NODE_MAX_CELLS - 1; i &gt; INTERNAL_NODE_MAX_CELLS / 2; i--) {
</span><span class="gi">+    cur_page_num = *internal_node_child(old_node, i);
</span><span class="gi">+    cur = get_page(table-&gt;pager, cur_page_num);
</span><span class="gi">+
</span><span class="gi">+    internal_node_insert(table, new_page_num, cur_page_num);
</span><span class="gi">+    *node_parent(cur) = new_page_num;
</span><span class="gi">+
</span><span class="gi">+    (*old_num_keys)--;
</span><span class="gi">+  }
</span></code></pre></div><p>第4步很重要，因为它的目的是“擦除”旧节点的键/子节点对。虽然我们实际上没有释放旧节点页面中该字节偏移量的内存，但</p>
<p>通过减少旧节点的键数，我们使得该内存位置无法访问，并且下次插入子节点到旧节点时，这些字节将被覆盖。</p>
<p>同时注意我们循环不变式的行为——如果将来我们的内部节点最大键数发生变化，我们的逻辑确保在拆分后，无论是旧节点还是兄弟节点，它们都会拥有（n-1）/2个键，而剩余的1个键会移动到父节点。如果选择偶数作为节点的最大键数，那么n/2个节点将留在旧节点，而（n-1）/2个节点将移动到兄弟节点。这种逻辑修改将会很直接。</p>
<p>当需要移动的键移动完成后，我们将旧节点的第i个子节点设置为其右子节点，并减少其键数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gi">+  /*
</span><span class="gi">+  将中间键（现在是最大键）之前的子节点设置为节点的右子节点，并减少键数
</span><span class="gi">+  */
</span><span class="gi">+  *internal_node_right_child(old_node) = *internal_node_child(old_node,*old_num_keys - 1);
</span><span class="gi">+  (*old_num_keys)--;
</span></code></pre></div><p>然后，我们根据子节点的最大键将子节点插入到旧节点或兄弟节点中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gi">+  uint32_t max_after_split = get_node_max_key(table-&gt;pager, old_node);
</span><span class="gi">+
</span><span class="gi">+  uint32_t destination_page_num = child_max &lt; max_after_split ? old_page_num : new_page_num;
</span><span class="gi">+
</span><span class="gi">+  internal_node_insert(table, destination_page_num, child_page_num);
</span><span class="gi">+  *node_parent(child) = destination_page_num;
</span></code></pre></div><p>最后，我们在旧节点的父节点中更新旧节点的键，并在必要时插入兄弟节点，并更新兄弟节点的父指针。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gi">+  update_internal_node_key(parent, old_max, get_node_max_key(table-&gt;pager, old_node));
</span><span class="gi">+
</span><span class="gi">+  if (!splitting_root) {
</span><span class="gi">+    internal_node_insert(table,*node_parent(old_node),new_page_num);
</span><span class="gi">+    *node_parent(new_node) = *node_parent(old_node);
</span><span class="gi">+  }
</span></code></pre></div><p>要支持这种新逻辑的一个重要更改是在我们的<code>create_new_root</code>函数中进行的。以前，我们只考虑了新根节点的子节点将是叶节点的情况。如果新根节点的子节点实际上是内部节点，我们需要做两件事：</p>
<ol>
<li>正确地初始化根节点的新子节点为内部节点</li>
<li>除了对memcpy的调用之外，我们还需要将根节点的每个键插入到其新左子节点中，并更新每个子节点的父指针</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gu">@@ -661,22 +680,40 @@ void create_new_root(Table* table, uint32_t right_child_page_num) {
</span><span class="gu"></span>   uint32_t left_child_page_num = get_unused_page_num(table-&gt;pager);
   void* left_child = get_page(table-&gt;pager, left_child_page_num);
 
<span class="gi">+  if (get_node_type(root) == NODE_INTERNAL) {
</span><span class="gi">+    initialize_internal_node(right_child);
</span><span class="gi">+    initialize_internal_node(left_child);
</span><span class="gi">+  }
</span><span class="gi">+
</span><span class="gi"></span>   /* 左子节点复制了旧根节点的数据 */
   memcpy(left_child, root, PAGE_SIZE);
   set_node_root(left_child, false);
 
<span class="gi">+  if (get_node_type(left_child) == NODE_INTERNAL) {
</span><span class="gi">+    void* child;
</span><span class="gi">+    for (int i = 0; i &lt; *internal_node_num_keys(left_child); i++) {
</span><span class="gi">+      child = get_page(table-&gt;pager, *internal_node_child(left_child,i));
</span><span class="gi">+      *node_parent(child) = left_child_page_num;
</span><span class="gi">+    }
</span><span class="gi">+    child = get_page(table-&gt;pager, *internal_node_right_child(left_child));
</span><span class="gi">+    *node_parent(child) = left_child_page_num;
</span><span class="gi">+  }
</span><span class="gi">+
</span><span class="gi"></span>   /* 根节点是一个新的内部节点，有一个键和两个子节点 */
   initialize_internal_node(root);
   set_node_root(root, true);
   *internal_node_num_keys(root) = 1;
   *internal_node_child(root, 0) = left_child_page_num;
<span class="gd">-  uint32_t left_child_max_key = get_node_max_key(left_child);
</span><span class="gd"></span><span class="gi">+  uint32_t left_child_max_key = get_node_max_key(table-&gt;pager, left_child);
</span><span class="gi"></span>   *internal_node_key(root, 0) = left_child_max_key;
   *internal_node_right_child(root) = right_child_page_num;
   *node_parent(left_child) = table-&gt;root_page_num;
   *node_parent(right_child) = table-&gt;root_page_num;
 }
</code></pre></div><p>另一个重要更改是对<code>get_node_max_key</code>进行的，就像本文开头提到的一样。由于内部节点的键表示其左侧子树的最大键，并且该子树可以是任意深度的树，因此我们需要沿着该树的右子节点走下去，直到到达叶节点，然后取该叶节点的最大键。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gi">+uint32_t get_node_max_key(Pager* pager, void* node) {
</span><span class="gi">+  if (get_node_type(node) == NODE_LEAF) {
</span><span class="gi">+    return *leaf_node_key(node, *leaf_node_num_cells(node) - 1);
</span><span class="gi">+  }
</span><span class="gi">+  void* right_child = get_page(pager,*internal_node_right_child(node));
</span><span class="gi">+  return get_node_max_key(pager, right_child);
</span><span class="gi">+}
</span></code></pre></div><p>我们编写了一个单一测试来证明在引入内部节点拆分后，我们的<code>print_tree</code>函数仍然有效。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gi">+  it &#39;allows printing out the structure of a 7-leaf-node btree&#39; do
</span><span class="gi">+    script = [
</span><span class="gi">+      &#34;insert 58 user58 person58@example.com&#34;,
</span><span class="gi">+      &#34;insert 56 user56 person56@example.com&#34;,
</span><span class="gi">+      &#34;insert 8 user8 person8@example.com&#34;,
</span><span class="gi">+      &#34;insert 54 user54 person54@example.com&#34;,
</span><span class="gi">+      &#34;insert 77 user77 person77@example.com&#34;,
</span><span class="gi">+      &#34;insert 7 user7 person7@example.com&#34;,
</span><span class="gi">+      &#34;insert 25 user25 person25@example.com&#34;,
</span><span class="gi">+      &#34;insert 71 user71 person71@example.com&#34;,
</span><span class="gi">+      &#34;insert 13 user13 person13@example.com&#34;,
</span><span class="gi">+      &#34;insert 22 user22 person22@example.com&#34;,
</span><span class="gi">+      &#34;insert 53 user53 person53@example.com&#34;,
</span><span class="gi">+      &#34;insert 51 user51 person51@example.com&#34;,
</span><span class="gi">+      &#34;insert 59 user59 person59@example.com&#34;,
</span><span class="gi">+      &#34;insert 32 user32 person32@example.com&#34;,
</span><span class="gi">+      &#34;insert 36 user36 person36@example.com&#34;,
</span><span class="gi">+      &#34;insert 79 user79 person79@example.com&#34;,
</span><span class="gi">+      &#34;insert 10 user10 person10@example.com&#34;,
</span><span class="gi">+      &#34;insert 33 user33 person33@example.com&#34;,
</span><span class="gi">+      &#34;insert 20 user20 person20@example.com&#34;,
</span><span class="gi">+      &#34;insert 4 user4 person4@example.com&#34;,
</span><span class="gi">+      &#34;insert 35 user35 person35@example.com&#34;,
</span><span class="gi">+      &#34;insert 76 user76 person76@example.com&#34;,
</span><span class="gi">+      &#34;insert 49 user49 person49@example.com&#34;,
</span><span class="gi">+      &#34;insert 24 user24 person24@example.com&#34;,
</span><span class="gi">+      &#34;insert 70 user70 person70@example.com&#34;,
</span><span class="gi">+      &#34;insert 48 user48 person48@example.com&#34;,
</span><span class="gi">+      &#34;insert 39 user39 person39@example.com&#34;,
</span><span class="gi">+      &#34;insert 15 user15 person15@example.com&#34;,
</span><span class="gi">+      &#34;insert 47 user47 person47@example.com&#34;,
</span><span class="gi">+      &#34;insert 30 user30 person30@example.com&#34;,
</span><span class="gi">+      &#34;insert 86 user86 person86@example.com&#34;,
</span><span class="gi">+      &#34;insert 31 user31 person31@example.com&#34;,
</span><span class="gi">+      &#34;insert 68 user68 person68@example.com&#34;,
</span><span class="gi">+      &#34;insert 37 user37 person37@example.com&#34;,
</span><span class="gi">+      &#34;insert 66 user66 person66@example.com&#34;,
</span><span class="gi">+      &#34;insert 63 user63 person63@example.com&#34;,
</span><span class="gi">+      &#34;insert 40 user40 person40@example.com&#34;,
</span><span class="gi">+      &#34;insert 78 user78 person78@example.com&#34;,
</span><span class="gi">+      &#34;insert 19 user19 person19@example.com&#34;,
</span><span class="gi">+      &#34;insert 46 user46 person46@example.com&#34;,
</span><span class="gi">+      &#34;insert 14 user14 person14@example.com&#34;,
</span><span class="gi">+      &#34;insert 81 user81 person81@example.com&#34;,
</span><span class="gi">+      &#34;insert 72 user72 person72@example.com&#34;,
</span><span class="gi">+      &#34;insert 6 user6 person6@example.com&#34;,
</span><span class="gi">+      &#34;insert 50 user50 person50@example.com&#34;,
</span><span class="gi">+      &#34;insert 85 user85 person85@example.com&#34;,
</span><span class="gi">+      &#34;insert 67 user67 person67@example.com&#34;,
</span><span class="gi">+      &#34;insert 2 user2 person2@example.com&#34;,
</span><span class="gi">+      &#34;insert 55 user55 person55@example.com&#34;,
</span><span class="gi">+      &#34;insert 69 user69 person69@example.com&#34;,
</span><span class="gi">+      &#34;insert 5 user5 person5@example.com&#34;,
</span><span class="gi">+      &#34;insert 65 user65 person65@example.com&#34;,
</span><span class="gi">+      &#34;insert 52 user52 person52@example.com&#34;,
</span><span class="gi">+      &#34;insert 1 user1 person1@example.com&#34;,
</span><span class="gi">+      &#34;insert 29 user29 person29@example.com&#34;,
</span><span class="gi">+      &#34;insert 9 user9 person9@example.com&#34;,
</span><span class="gi">+      &#34;insert 43 user43 person43@example.com&#34;,
</span><span class="gi">+      &#34;insert 75 user75 person75@example.com&#34;,
</span><span class="gi">+      &#34;insert 21 user21 person21@example.com&#34;,
</span><span class="gi">+      &#34;insert 82 user82 person82@example.com&#34;,
</span><span class="gi">+      &#34;insert 12 user12 person12@example.com&#34;,
</span><span class="gi">+      &#34;insert 18 user18 person18@example.com&#34;,
</span><span class="gi">+      &#34;insert 60 user60 person60@example.com&#34;,
</span><span class="gi">+      &#34;insert 44 user44 person44@example.com&#34;,
</span><span class="gi">+      &#34;.btree&#34;,
</span><span class="gi">+      &#34;.exit&#34;,
</span><span class="gi">+    ]
</span><span class="gi">+    result = run_script(script)
</span><span class="gi">+
</span><span class="gi">+    expect(result[64...(result.length)]).to match_array([
</span><span class="gi">+      &#34;db &gt; Tree:&#34;,
</span><span class="gi">+      &#34;- internal (size 1)&#34;,
</span><span class="gi">+      &#34;  - internal (size 2)&#34;,
</span><span class="gi">+      &#34;    - leaf (size 7)&#34;,
</span><span class="gi">+      &#34;      - 1&#34;,
</span><span class="gi">+      &#34;      - 2&#34;,
</span><span class="gi">+      &#34;      - 4&#34;,
</span><span class="gi">+      &#34;      - 5&#34;,
</span><span class="gi">+      &#34;      - 6&#34;,
</span><span class="gi">+      &#34;      - 7&#34;,
</span><span class="gi">+      &#34;      - 8&#34;,
</span><span class="gi">+      &#34;    - key 8&#34;,
</span><span class="gi">+      &#34;    - leaf (size 11)&#34;,
</span><span class="gi">+      &#34;      - 9&#34;,
</span><span class="gi">+      &#34;      - 10&#34;,
</span><span class="gi">+      &#34;      - 12&#34;,
</span><span class="gi">+      &#34;      - 13&#34;,
</span><span class="gi">+      &#34;      - 14&#34;,
</span><span class="gi">+      &#34;      - 15&#34;,
</span><span class="gi">+      &#34;      - 18&#34;,
</span><span class="gi">+      &#34;      - 19&#34;,
</span><span class="gi">+      &#34;      - 20&#34;,
</span><span class="gi">+      &#34;      - 21&#34;,
</span><span class="gi">+      &#34;      - 22&#34;,
</span><span class="gi">+      &#34;    - key 22&#34;,
</span><span class="gi">+      &#34;    - leaf (size 8)&#34;,
</span><span class="gi">+      &#34;      - 24&#34;,
</span><span class="gi">+      &#34;      - 25&#34;,
</span><span class="gi">+      &#34;      - 29&#34;,
</span><span class="gi">+      &#34;      - 30&#34;,
</span><span class="gi">+      &#34;      - 31&#34;,
</span><span class="gi">+      &#34;      - 32&#34;,
</span><span class="gi">+      &#34;      - 33&#34;,
</span><span class="gi">+      &#34;      - 35&#34;,
</span><span class="gi">+      &#34;  - key 35&#34;,
</span><span class="gi">+      &#34;  - internal (size 3)&#34;,
</span><span class="gi">+      &#34;    - leaf (size 12)&#34;,
</span><span class="gi">+      &#34;      - 36&#34;,
</span><span class="gi">+      &#34;      - 37&#34;,
</span><span class="gi">+      &#34;      - 39&#34;,
</span><span class="gi">+      &#34;      - 40&#34;,
</span><span class="gi">+      &#34;      - 43&#34;,
</span><span class="gi">+      &#34;      - 44&#34;,
</span><span class="gi">+      &#34;      - 46&#34;,
</span><span class="gi">+      &#34;      - 47&#34;,
</span><span class="gi">+      &#34;      - 48&#34;,
</span><span class="gi">+      &#34;      - 49&#34;,
</span><span class="gi">+      &#34;      - 50&#34;,
</span><span class="gi">+      &#34;      - 51&#34;,
</span><span class="gi">+      &#34;    - key 51&#34;,
</span><span class="gi">+      &#34;    - leaf (size 11)&#34;,
</span><span class="gi">+      &#34;      - 52&#34;,
</span><span class="gi">+      &#34;      - 53&#34;,
</span><span class="gi">+      &#34;      - 54&#34;,
</span><span class="gi">+      &#34;      - 55&#34;,
</span><span class="gi">+      &#34;      - 56&#34;,
</span><span class="gi">+      &#34;      - 58&#34;,
</span><span class="gi">+      &#34;      - 59&#34;,
</span><span class="gi">+      &#34;      - 60&#34;,
</span><span class="gi">+      &#34;      - 63&#34;,
</span><span class="gi">+      &#34;      - 65&#34;,
</span><span class="gi">+      &#34;      - 66&#34;,
</span><span class="gi">+      &#34;    - key 66&#34;,
</span><span class="gi">+      &#34;    - leaf (size 7)&#34;,
</span><span class="gi">+      &#34;      - 67&#34;,
</span><span class="gi">+      &#34;      - 68&#34;,
</span><span class="gi">+      &#34;      - 69&#34;,
</span><span class="gi">+      &#34;      - 70&#34;,
</span><span class="gi">+      &#34;      - 71&#34;,
</span><span class="gi">+      &#34;      - 72&#34;,
</span><span class="gi">+      &#34;      - 75&#34;,
</span><span class="gi">+      &#34;    - key 75&#34;,
</span><span class="gi">+      &#34;    - leaf (size 8)&#34;,
</span><span class="gi">+      &#34;      - 76&#34;,
</span><span class="gi">+      &#34;      - 77&#34;,
</span><span class="gi">+      &#34;      - 78&#34;,
</span><span class="gi">+      &#34;      - 79&#34;,
</span><span class="gi">+      &#34;      - 81&#34;,
</span><span class="gi">+      &#34;      - 82&#34;,
</span><span class="gi">+      &#34;      - 85&#34;,
</span><span class="gi">+      &#34;      - 86&#34;,
</span><span class="gi">+      &#34;db &gt; &#34;,
</span><span class="gi">+    ])
</span><span class="gi">+  end
</span></code></pre></div><p>完整源码：  <a href="https://github.com/cstack/db_tutorial">https://github.com/cstack/db_tutorial</a></p>
    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">weedge</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
      2024-01-09
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://weedge.github.io/tags/db/">db</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/db_tutorial_go/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">构建一个简单的数据库[golang版]</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        
          <a class="next" href="/post/llm/llm-knowledge-point-all-u-need/">
            <span class="next-text nav-default">LLM 知识点 All u need</span>
            <span class="prev-text nav-mobile">下一篇</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  

  
  

  

  
  

  

  

  <div class="disqus-comment">
  <div class="disqus-button" id="load_disqus" onclick="load_disqus()">
    显示 Disqus 评论
  </div>
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_config = function () {
      this.page.url = "https://weedge.github.io/post/db_tutorial_zh/";
    };
    function load_disqus() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'weedge';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);

      $('#load_disqus').remove();
    };
  </script>
  <noscript>Please enable JavaScript to view the
    <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
  </noscript>
  
  </div>

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="mailto:weege007@gmail.com" rel="me noopener" class="iconfont"
      title="email" >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://github.com/weedge" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>
  
    <a href="https://weibo.com/weedge" rel="me noopener" class="iconfont"
      title="weibo"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M385.714286 733.714286q12-19.428571 6.285714-39.428571t-25.714286-28.571429q-19.428571-8-41.714286-0.571429t-34.285714 26.285714q-12.571429 19.428571-7.428571 39.142857t24.571429 28.857143 42.571429 1.428571 35.714286-27.142857zm53.714286-69.142857q4.571429-7.428571 2-15.142857t-10-10.571429q-8-2.857143-16.285714 2.857143t-12.285714 10.571429q-9.714286 17.714286 7.428571 25.714286 8 2.857143 16.571429 2.857143t12.571429-10.571429zm99.428571 61.142857q-25.714286 58.285714-90.285714 85.714286t-128 6.857143q-61.142857-19.428571-84.285714-72.285714t3.714286-107.142857q26.857143-53.142857 86.571429-79.428571t120.285714-10.857143q63.428571 16.571429 90.571429 68.285714t1.428571 108.857143zm178.285714-91.428571q-5.142857-54.857143-50.857143-97.142857t-119.142857-62.285714-156.857143-12q-127.428571 13.142857-211.142857 80.857143t-75.714286 151.142857q5.142857 54.857143 50.857143 97.142857t119.142857 62.285714 156.857143 12q127.428571-13.142857 211.142857-80.857143t75.714286-151.142857zm176 2.285714q0 38.857143-21.142857 79.714286t-62.285714 78.285714-96.285714 67.142857-129.142857 47.428571-154.571429 17.714286-157.142857-19.142857-137.428571-53.142857-98-86.285714-37.142857-114q0-65.714286 39.714286-140t112.857143-147.428571q96.571429-96.571429 195.142857-134.857143t140.857143 4q37.142857 36.571429 11.428571 119.428571-2.285714 8-0.571429 11.428571t5.714286 4 8.285714 2.857143 7.714286-2l3.428571-1.142857q79.428571-33.714286 140.571429-33.714286t87.428571 34.857143q25.714286 36 0 101.714286-1.142857 7.428571-2.571429 11.428571t2.571429 7.142857 6.857143 4.285714 9.714286 3.428571q32.571429 10.285714 58.857143 26.857143t45.714286 46.571429 19.428571 66.571429zm-42.285714-356.571429q24 26.857143 31.142857 62t-3.714286 67.142857q-4.571429 13.142857-16.857143 19.428571t-25.428571 2.285714q-13.142857-4.571429-19.428571-16.857143t-2.285714-25.428571q11.428571-36-13.714286-63.428571t-61.142857-20q-13.714286 2.857143-25.714286-4.571429t-14.285714-21.142857q-2.857143-13.714286 4.571429-25.428571t21.142857-14.571429q34.285714-7.428571 68 3.142857t57.714286 37.428571zm103.428571-93.142857q49.714286 54.857143 64.285714 127.142857t-7.714286 138q-5.142857 15.428571-19.428571 22.857143t-29.714286 2.285714-22.857143-19.428571-2.857143-29.714286q16-46.857143 5.714286-98.285714t-45.714286-90.285714q-35.428571-39.428571-84.571429-54.571429t-98.857143-4.857143q-16 3.428571-29.714286-5.428571t-17.142857-24.857143 5.428571-29.428571 24.857143-16.857143q70.285714-14.857143 139.428571 6.571429t118.857143 76.857143z"></path>
</svg>

    </a>


<a href="https://weedge.github.io/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2013 -
    2024
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        weedge
        
      </span></span>

  
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  









  <script id="dsq-count-scr" src="//weedge.disqus.com/count.js" async></script>






  <script src="/js/copy-to-clipboard.js"></script>


</body>
</html>
