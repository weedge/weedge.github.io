<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>时间飘过</title>
    <link>https://weedge.github.io/</link>
    <description>Recent content on 时间飘过</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 08 Nov 2021 10:26:23 +0800</lastBuildDate>
    
        <atom:link href="https://weedge.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>https://weedge.github.io/about/</link>
      <pubDate>Sun, 20 Jan 2013 21:38:52 +0800</pubDate>
      
      <guid>https://weedge.github.io/about/</guid>
      
        <description>&lt;p&gt;简单的木头人，简单，呆木，喜欢自言自语，愚人自扰型。时间飞逝，仅仅记录，留住某人某事，某些好玩的技术，KISS and just do IT.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>mysql-w</title>
      <link>https://weedge.github.io/todo/mysql-w/</link>
      <pubDate>Mon, 08 Nov 2021 10:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/todo/mysql-w/</guid>
      
        <description>&lt;h2 id=&#34;序言&#34;&gt;序言&lt;/h2&gt;
&lt;p&gt;一条mysql 写操作，增删改SQL语句通过mysql协议提交&lt;/p&gt;
&lt;p&gt;InnoDB 存储引擎架构&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dev.mysql.com/doc/refman/8.0/en/images/innodb-architecture.png&#34; alt=&#34;innodb-architecture&#34;&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>WAL</title>
      <link>https://weedge.github.io/todo/wal/</link>
      <pubDate>Mon, 08 Nov 2021 10:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/todo/wal/</guid>
      
        <description>&lt;h2 id=&#34;序言&#34;&gt;序言&lt;/h2&gt;
</description>
      
    </item>
    
    <item>
      <title>缓存淘汰策略-LRU</title>
      <link>https://weedge.github.io/post/lru/</link>
      <pubDate>Mon, 08 Nov 2021 10:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/lru/</guid>
      
        <description>&lt;h2 id=&#34;序言&#34;&gt;序言&lt;/h2&gt;
&lt;p&gt;​	在计算机硬件中缓/内存设计是用来机器启动的时候加载程序，分配运行空间数据，停机，缓/内存中的数据会丢失；磁盘用来持久化存储，提供数据加载到内存中，内存的读写速度比磁盘快很多，以下是&lt;a href=&#34;https://research.google/people/jeff/&#34;&gt;Jeff Dean&lt;/a&gt;  &amp;ldquo;&lt;a href=&#34;http://brenocon.com/dean_perf.html&#34;&gt;Numbers Everyone Should Know&lt;/a&gt;&amp;rdquo; 中提供的数据(虽然过去10多年了)， 读取1MB数据，从内存中读比从磁盘中读取快100+倍；但是缓/内存的空间比磁盘空间少，为了加快数据的访问，减少缓存/磁盘io，大概分为三种：1. 可以提前将数据从磁盘加载到内/缓存中(page)、2. 内/缓存miss从下层存储获取数据(cache,pool,page)、3. 无需加载，直接内/缓存evict；如果提供给进程的最大内/缓存资源到了最大限制，需要对存储资源进行evict操作，常用的evict策略可以从&lt;a href=&#34;https://en.wikipedia.org/wiki/Cache_replacement_policies&#34;&gt;Cache_replacement_policies&lt;/a&gt;中了解；有关特定于分页的详细算法，请参阅&lt;a href=&#34;https://en.wikipedia.org/wiki/Page_replacement_algorithm&#34;&gt;页面替换算法&lt;/a&gt;；有关特定于 CPU 和 RAM 之间缓存的详细算法，请参阅&lt;a href=&#34;https://en.wikipedia.org/wiki/CPU_cache&#34;&gt;CPU 缓存&lt;/a&gt;。这里主要关注LRU evict相关策略。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;OP(io)&lt;/th&gt;
&lt;th&gt;cost&lt;!-- raw HTML omitted --&gt;（1s= 10^9ns)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;L1 cache reference 读取CPU的一级缓存&lt;/td&gt;
&lt;td&gt;0.5 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Branch mispredict(转移、分支预测)&lt;/td&gt;
&lt;td&gt;5 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L2 cache reference 读取CPU的二级缓存&lt;/td&gt;
&lt;td&gt;7 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mutex lock/unlock 互斥锁\解锁&lt;/td&gt;
&lt;td&gt;100 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Main memory reference 读取内存数据&lt;/td&gt;
&lt;td&gt;100 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Compress 1K bytes with Zippy 1k字节压缩&lt;/td&gt;
&lt;td&gt;10,000 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Send 2K bytes over 1 Gbps network 在1Gbps的网络上发送2k字节&lt;/td&gt;
&lt;td&gt;20,000 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Read 1 MB sequentially from memory 从内存顺序读取1MB&lt;/td&gt;
&lt;td&gt;250,000 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Round trip within same datacenter 从一个数据中心往返一次，ping一下&lt;/td&gt;
&lt;td&gt;500,000 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Disk seek  磁盘搜索&lt;/td&gt;
&lt;td&gt;10,000,000 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Read 1 MB sequentially from network 从网络上顺序读取1兆的数据&lt;/td&gt;
&lt;td&gt;10,000,000 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Read 1 MB sequentially from disk 从磁盘里面读出1MB&lt;/td&gt;
&lt;td&gt;30,000,000 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Send packet CA-&amp;gt;Netherlands-&amp;gt;CA 一个包的一次远程访问&lt;/td&gt;
&lt;td&gt;150,000,000 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;lru算法&#34;&gt;LRU算法&lt;/h2&gt;
&lt;p&gt;​	LRU(least recently used)是一种缓存 evict 策略算法：在缓存有限的情况下，如果有新的数据需要加载进缓存，则需要将最不可能被继续访问的缓存剔除掉。这是一种提前预判假设的算法，因为缓存是否可能被访问到没法做预测的，所以假设 &lt;strong&gt;一个key经常被访问，那么该key的idle time应该是最小的。&lt;/strong&gt; (但这个假设也是基于概率，并不是充要条件,很明显,idle time最小的,甚至都不一定会被再次访问到)。&lt;/p&gt;
&lt;p&gt;​	LRU 的工作原理是一种时间局部性原理的假设，在过去的几条指令中使用最多的页面最有可能在接下来的几条指令中也被大量使用。&lt;/p&gt;
&lt;p&gt;​	实现方式可以采用wiki中的实现，每个缓存item中有序列号(每个新访问的增量为 1)，缓存满了将序列号最低的替换掉，这种实现需要找到最低的进行比较替换；还有种实现实现方式是通过hashMap+双向链表的方式实现，空间换时间的方式，&lt;a href=&#34;https://leetcode-cn.com/problems/lru-cache/&#34;&gt;leetcode上有这道题&lt;/a&gt;，一般面试会问到；&lt;/p&gt;
&lt;p&gt;实际工程实现中，由于实现成本，根据使用场景，考虑空间利用和时间的折中，使用的&lt;a href=&#34;https://en.wikipedia.org/wiki/Page_replacement_algorithm#Variants_on_LRU&#34;&gt;LRU算法变体&lt;/a&gt;：(以下定义来自wiki)&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Page_replacement_algorithm#cite_note-15&#34;&gt;LRU-K&lt;/a&gt; 驱逐过去第 K 次最近访问最远的页面。例如，LRU-1 只是 LRU，而 LRU-2 根据倒数第二次访问的时间驱逐页面。LRU-K 在时间上的局部性方面大大改进了 LRU。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Page_replacement_algorithm#cite_note-16&#34;&gt;ARC&lt;/a&gt; 算法通过保持最近驱逐页面的历史可LRU，并使用此选项可以更改的偏好近期或频繁访问。它对顺序扫描特别有抵抗力。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Page_replacement_algorithm#cite_note-17&#34;&gt;2Q&lt;/a&gt; 算法改进了 LRU 和 LRU/2 算法。通过具有两个队列，一个用于热路径项目，另一个用于慢路径项目，项目首先被放置在慢路径队列中，并且在第二次访问放置在热路径项目中的项目之后；由于对添加项的引用比 LRU 和 LRU/2 算法中的保留时间更长，因此它具有更好的热路径队列，从而提高了缓存的命中率。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Cache_replacement_policies#Segmented_LRU_(SLRU)&#34;&gt;SLRU&lt;/a&gt; 缓存分为两个段，试用段和保护段。每个段中的行按从最近访问到最近最少访问的顺序排列。来自未命中的数据被添加到试用段最近访问的末端的缓存中。命中从它们当前所在的任何地方删除，并添加到受保护段的最近访问端。因此，受保护段中的行至少被访问了两次。&lt;/p&gt;
&lt;h2 id=&#34;本地缓存中的实现机制&#34;&gt;本地缓存中的实现机制&lt;/h2&gt;
&lt;p&gt;go语言实现的本地缓存策略中有开源方案&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/golang/groupcache&#34;&gt;https://github.com/golang/groupcache&lt;/a&gt;  (LRU)&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://github.com/dgryski/go-s4lru&#34;&gt;http://github.com/dgryski/go-s4lru&lt;/a&gt; (S4LRU)&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/dgryski/go-arc&#34;&gt;https://github.com/dgryski/go-arc&lt;/a&gt; (ARC)&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/hashicorp/golang-lru&#34;&gt;https://github.com/hashicorp/golang-lru&lt;/a&gt; (LRU, ARC, TwoQueue)&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/vmihailenco/go-cache-benchmark&#34;&gt;https://github.com/vmihailenco/go-cache-benchmark&lt;/a&gt; 对不同的cache 淘汰策略的对比，引用结果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TinyLFU最适合少量的key(少于100k)。TinyLFU内存开销可以通过第二个参数进行调整。
Clock-pro有明显较小的内存使用大量的key(当key的数量超过 1m)。
分段LRU的内存使用量更小，但命中率不一致。
如果你需要它提供的额外功能，Ristretto仍然是一个不错的选择。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;存储组件中的实现机制&#34;&gt;存储组件中的实现机制&lt;/h2&gt;
&lt;h3 id=&#34;redis-dictsdsredisobject-lru-evict策略&#34;&gt;redis Dict(sds,redisObject) LRU evict策略&lt;/h3&gt;
&lt;p&gt;redis 是缓存数据库，缓存空间是有限的，可以指定最大内存使用空间；redis提供过期机制，给key制定过期时间，redis实现了删除这些过期key的删除策略（定期删除+惰性删除），但是还是存在问题，对于一些key没有设置过期时间，总会到最大内存使用空间，需要实现内存淘汰回收策略，其中策略就是LRU, 操作对象分为全部key (allkeys-lru) 和 过期key(volatile-lru)；这里整体介绍下redis缓存策略，然后单独介绍对应的redis LRU evict策略:&lt;/p&gt;
&lt;h4 id=&#34;最大内存配置选项&#34;&gt;最大内存配置选项&lt;/h4&gt;
&lt;p&gt;maxmemory 配置选项使用来配置 Redis 的存储数据所能使用的最大内存限制。可以通过在内置文件redis.conf中配置，也可在Redis运行时通过命令CONFIG SET来配置。例如，我们要配置内存上限是100M的Redis缓存，那么我们可以在 redis.conf 配置如下：maxmemory 100mb&lt;/p&gt;
&lt;p&gt;设置 maxmemory 为 0 表示没有内存限制。在 64-bit 系统中，默认是 0 无限制，但是在 32-bit 系统中默认是 3GB。当存储数据达到限制时，Redis 会根据情形选择不同策略，或者返回errors（这样会导致浪费更多的内存），或者清除一些旧数据回收内存来添加新数据。&lt;/p&gt;
&lt;h4 id=&#34;惰性释放的策略&#34;&gt;惰性释放的策略&lt;/h4&gt;
&lt;p&gt;应用这种策略的原因在于对于某些数据对象的释放需要消耗过多的系统资源，如果在&lt;em&gt;Redis&lt;/em&gt;的主线程中采用同步的方式去删除以及释放这样的&lt;em&gt;key-value&lt;/em&gt;数据，那么会导致系统长时间的阻塞在释放数据操作上，而无法处理其他的业务逻辑。对于这种情况，我们以惰性释放的策略，使用一个后台线程，通过异步的方式来对数据对象进行释放，无疑是一种较为合适的选择，可配置三种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;redisServer.lazyfree_lazy_eviction： 是否在淘汰某个&lt;em&gt;key&lt;/em&gt;时，使用惰性释放策略；这个在内存淘汰策略异步释放会用到；&lt;/li&gt;
&lt;li&gt;redisServer.lazyfree_lazy_expire：是否在过期某个&lt;em&gt;key&lt;/em&gt;时，使用惰性释放策略;&lt;/li&gt;
&lt;li&gt;redisServer.lazyfree_lazy_server_del: 服务器端删除某个&lt;em&gt;key&lt;/em&gt;时，是否使用惰性释放策略;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;过期删除缓存策略&#34;&gt;过期删除缓存策略&lt;/h4&gt;
&lt;p&gt;分为定期删除，惰性删除, 两种策略配合使用：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定期删除&lt;/strong&gt; 指的是Redis默认会每隔一定时间（默认100ms）就会&lt;!-- raw HTML omitted --&gt;抽取一批设置了过期时间的key&lt;!-- raw HTML omitted --&gt;来检测是否过期，过期就删除。&lt;/p&gt;
&lt;p&gt;在Redis2.6版本中，规定每秒运行10次，大概100ms运行一次。在Redis2.8版本后，可以通过修改配置文件redis.conf 的 &lt;strong&gt;hz&lt;/strong&gt; 选项来调整每秒次数(一般用默认值， 过高会的cpu造成一定压力)。由redis.c/activeExpireCycle 函数实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;惰性删除&lt;/strong&gt; 在获取某个Key时Redis会先检测一下，这个key是否设置了过期时间？如果设置了过期时间那么是否过期？过期就删除。由 db.c/expireIfNeeded 函数实现。&lt;/p&gt;
&lt;p&gt;如果定期抽取一批过期key删除, 以及没有对过期key访问了，这样会存在大量过期key未删除回收的情况，会导致内存使用率大大降低；所以redis内部提供了不同的内存淘汰回收策略。&lt;/p&gt;
&lt;h4 id=&#34;内存淘汰回收策略&#34;&gt;内存淘汰回收策略&lt;/h4&gt;
&lt;p&gt;当内存达到限制时，Redis 具体的回收策略是通过 maxmemory-policy 配置项配置的。&lt;/p&gt;
&lt;p&gt;以下的策略都是可用的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;noenviction：不清除数据，只是返回错误，这样会导致浪费掉更多的内存，对大多数写命令（DEL 命令和其他的少数命令例外）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;allkeys-lru：从所有的数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰，以供新数据使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰，以供新数据使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;allkeys-random：从所有数据集（server.db[i].dict）中任意选择数据淘汰，以供新数据使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰，以供新数据使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰，以供新数据使用&lt;/p&gt;
&lt;p&gt;从 Redis 4.0 版开始，引入了新的 LFU（最近最不常用）策略。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;volatile-lfu：从已设置过期时间的数据集（server.db[i].expires）中挑选近似 LFU 数据淘汰。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;allkeys-lfu：从所有的数据集（server.db[i].dict）中挑选近似 LFU 数据淘汰。&lt;/p&gt;
&lt;p&gt;LFU 类似于 LRU：它使用一个概率计数器，称为&lt;a href=&#34;https://en.wikipedia.org/wiki/Approximate_counting_algorithm&#34;&gt;莫里斯计数器&lt;/a&gt;，以便仅使用每个对象的几位来估计对象访问频率，并结合衰减周期，以便计数器随着时间的推移而减少：在某些时候，我们不再希望将key视为经常访问的key，即使它们过去是这样，以便算法可以适应访问的转变。LFU具有可调参数:  （见：&lt;a href=&#34;http://antirez.com/news/109&#34;&gt;Random notes on improving the Redis LRU algorithm&lt;/a&gt; Least Frequently Used)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;lfu-log-factor 10 //在大约一百万个请求时使计数器饱和因子，计数器对数因子会改变需要多少次命中才能使频率计数器饱和，这恰好在 0-255 的范围内。系数越高，需要越多的访问以达到最大值。系数越低，低访问计数器的分辨率越好，见redis示例redis.conf文件
lfu-decay-time 1 //每一分钟衰减一次计数器。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当 cache 中没有符合清除条件的 key 时，回收策略 volatile-lru, volatile-random 和volatile-ttl 将会和 策略 noeviction 一样返回错误。选择正确的回收策略是很重要的，取决于你的应用程序的访问模式。但是，你可以在程序运行时重新配置策略，使用 INFO 输出来监控缓存命中和错过的次数，以调优你的设置。&lt;/p&gt;
&lt;p&gt;普适经验规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果期望用户请求呈现幂律分布(power-law distribution)，也就是，期望一部分子集元素被访问得远比其他元素多时，可以使用allkeys-lru策略。在你不确定时这是一个好的选择。&lt;/li&gt;
&lt;li&gt;如果期望是循环周期的访问，所有的键被连续扫描，或者期望请求符合平均分布(每个元素以相同的概率被访问)，可以使用allkeys-random策略。&lt;/li&gt;
&lt;li&gt;如果你期望能让 Redis 通过使用你创建缓存对象的时候设置的TTL值，确定哪些对象应该是较好的清除候选项，可以使用volatile-ttl策略。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当你想使用单个Redis实例来实现缓存和持久化一些键，allkeys-lru和volatile-random策略会很有用。但是，通常最好是运行两个Redis实例来解决这个问题。&lt;/p&gt;
&lt;p&gt;另外值得注意的是，为键设置过期时间需要消耗内存，所以使用像allkeys-lru这样的策略会更高效，因为在内存压力下没有必要为键的回收设置过期时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回收过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;理解回收过程是运作流程非常的重要，回收过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个客户端运行一个新命令，添加了新数据。&lt;/li&gt;
&lt;li&gt;Redis检查内存使用情况，如果大于maxmemory限制，根据策略来回收键。&lt;/li&gt;
&lt;li&gt;一个新的命令被执行，如此等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们添加数据时通过检查，然后回收键以返回到限制以下，来连续不断的穿越内存限制的边界。如果一个命令导致大量的内存被占用(比如一个很大的集合保存到一个新的键)，那么内存限制很快就会被这个明显的内存量所超越。&lt;/p&gt;
&lt;h4 id=&#34;近似lru算法&#34;&gt;近似LRU算法&lt;/h4&gt;
&lt;p&gt;Redis整体上是一个大的dict，如果实现一个双向链表需要在每个key上首先增加两个指针，需要16个字节，并且额外需要一个list结构体去存储该双向链表的头尾节点信息。Redis作者认为这样实现不仅内存占用太大，而且可能导致性能降低。具体详见作者博客文章：&lt;a href=&#34;http://antirez.com/news/109&#34;&gt;Random notes on improving the Redis LRU algorithm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;Redis为什么不使用原生LRU算法？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原生LRU算法需要 双向链表 来管理数据，需要&lt;strong&gt;额外内存&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;数据访问时涉及&lt;strong&gt;数据移动，有性能损耗&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;Redis现有&lt;strong&gt;数据结构需要改造&lt;/strong&gt;，dictEntry, key指向sds, val指向redisObject，dictEntry 是个单向链表；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Redis的LRU算法不是一个严格的LRU实现。这意味着Redis不能选择最佳候选键来回收，也就是最久未被访问的那些键。相反，Redis 会尝试执行一个近似的LRU算法，通过采样一小部分键，然后在采样键中回收最适合(拥有最久访问时间)的那个。然而，从Redis3.0开始，算法被改进为维护一个回收候选键池。这改善了算法的性能，使得更接近于真实的LRU算法的行为。Redis的LRU算法有一点很重要，你可以调整算法的精度，通过改变每次回收时检查的采样数量。这个参数可以通过如下配置指令：&lt;code&gt;maxmemory-samples 5&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Redis没有使用真实的LRU实现的原因，是因为这会消耗更多的内存。然而，近似值对使用Redis的应用来说基本上也是等价的。文章&lt;a href=&#34;https://redis.io/topics/lru-cache&#34;&gt;Using Redis as an LRU cache&lt;/a&gt;为Redis使用的LRU近似值和真实LRU之间的比较。&lt;/p&gt;
&lt;p&gt; 触发时机是在redis server执行新的写命令时, 当 mem_used &amp;gt; maxmemory 的时候，通过 &lt;a href=&#34;https://github.com/redis/redis/blob/c1718f9d862267bc44b2a326cdc8cb1ca5b81a39/src/evict.c#L531:5&#34;&gt;performEvictions&lt;/a&gt; 方法完成数据淘汰(所看的Redis6.2.6源码)。LRU策略淘汰核心逻辑在 &lt;a href=&#34;https://github.com/redis/redis/blob/c1718f9d862267bc44b2a326cdc8cb1ca5b81a39/src/evict.c#L145:6&#34;&gt;evictionPoolPopulate&lt;/a&gt;（淘汰数据集合填充） 方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Redis6.2.6 淘汰策略整体逻辑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/weedge/lib/blob/main/client/redis/redis-lru.png?raw=true&#34; alt=&#34;redis-lru&#34;&gt;&lt;/p&gt;
&lt;p&gt;key访问变更策略值(用于计算idle)：&lt;/p&gt;
&lt;p&gt;在Redis的dict中每次按key获取一个值的时候，都会调用&lt;code&gt;lookupKey&lt;/code&gt;函数，前提是没有fork出来的saving子进程(会触发copy on write)
如果配置使用了LRU模式,该函数&lt;code&gt;LRU_CLOCK&lt;/code&gt;会更新val-&amp;gt;redisObject中的lru字段为当前秒级别的时间戳, 在估算idle time的时候，&lt;code&gt;estimateObjectIdleTime&lt;/code&gt;会再次调用&lt;code&gt;LRU_CLOCK&lt;/code&gt;获取时间戳和最近一次val-&amp;gt;redisObject中的lru相减获取idle；
为后面的样本池中获取bestKey来淘汰删除。&lt;/p&gt;
&lt;p&gt;采样方法：&lt;/p&gt;
&lt;p&gt;遍历数据库，根据淘汰策略从dict(没有过期时间的key)还是expires(有过期时间的key)中获取随机&lt;code&gt;maxmemory_samples&lt;/code&gt;个样本，放入&lt;code&gt;static struct evictionPoolEntry *EvictionPoolLRU&lt;/code&gt; pool样本池中。样本池中的样本idle值从低到高插入排序，数据淘汰策略每次选择idle最高数据进行淘汰释放(根据配置是否开启惰性淘汰策略释放异步释放还是同步释放)；样本池大小是&lt;code&gt;EVPOOL_SIZE 16&lt;/code&gt;，所以采集样本要根据自己的idle值大小或池中是否有空位来确定是否成功插入样本池中，如果池中没有空位，或者被插入样本的idle值都小于池子中的数据，那插入将会失败；这样样本池中一致存放idle最大，最大几率被淘汰的key(sds)样本(通过key找到dictEntry中的val-&amp;gt;redisObject 去释放)。&lt;/p&gt;
&lt;p&gt;Idle获取：&lt;/p&gt;
&lt;p&gt;如果是LRU策略：estimateObjectIdleTime(o)  获取redisObject 的 idle 时间，一个key经常被访问，那么该key的idle time应该是最小；
如果是LFU策略：255-LFUDecrAndReturn(o) 最大使用频率255减去redisObject的使用频率，所以最小使用频率，idle越大；
如果是已过期中淘汰策略： ULLONG_MAX - (long)dictGetVal(de);  过期越早越好；
pool中按idle从小到大插入排序，便于获取bestKey,用于删除。&lt;/p&gt;
&lt;p&gt;淘汰删除策略：&lt;/p&gt;
&lt;p&gt;如果开启惰性淘汰策略，则使用dbAsyncDelete 异步回收只释放key, 不会对主线程造成过大的负担否则使用dbSyncDelete同步回收；
异步回收如果释放对象数目&amp;gt;64, 将对象创建job加入lazy free list；通知&lt;code&gt;signal type: bio_lazy_free&lt;/code&gt;回收处理线程进行回收；
这两种操作都是会将key从数据库的键空间中移除，唯一的区别就在于，对value数据的释放，是同步操作还是异步操作。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/redis/redis/blob/79ac57561f268814babe212c9216efe45cfdf937/src/server.c#L5330&#34;&gt;触发代码在server.c中&lt;/a&gt;：activeExpireCycle performEvictions 函数 在 &lt;a href=&#34;https://github.com/redis/redis/blob/b71c5849e3e5c040b029c6e25cec2069d70760c1/README.md#serverc&#34;&gt;server.c&lt;/a&gt; readme中有介绍什么时候触发，&lt;/p&gt;
&lt;h3 id=&#34;mysql80-innodb-page-buffer-pool-lru-evict策略&#34;&gt;Mysql8.0 InnoDB page buffer pool LRU evict策略&lt;/h3&gt;
&lt;h4 id=&#34;页page&#34;&gt;页Page&lt;/h4&gt;
&lt;p&gt;数据库的数据是放在磁盘空间以表空间存放的，加载的时候以页page为单位进行加载，页是InnoDB存储引擎磁盘管理的最小单位，每个页默认16KB；可以通过参数innodb_page_size设置(一个页内必须存储2行记录，否则就不是B+tree，而是链表了)，页面类型：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数据页（B-tree Node）&lt;/p&gt;
&lt;p&gt;undo页（undo Log Page）&lt;/p&gt;
&lt;p&gt;系统页（System Page）&lt;/p&gt;
&lt;p&gt;事务数据页（Transaction system Page）&lt;/p&gt;
&lt;p&gt;插入缓冲位图页（Insert Buffer Page）&lt;/p&gt;
&lt;p&gt;插入缓冲空闲列表页（Insert Buffer Free List）&lt;/p&gt;
&lt;p&gt;未压缩的二进制大对象页（Uncompressd BLOB Page）&lt;/p&gt;
&lt;p&gt;压缩的二进制大对象页（Compressd BLOB Page）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://blogstatic.haohtml.com/uploads/2019/08/innodb_engine_struct.png&#34; alt=&#34;innodb_engine_struct&#34;&gt;&lt;/p&gt;
&lt;p&gt;从InnoDB存储引擎的逻辑结构看，所有数据都被逻辑地存放在一个空间内，称为表空间(tablespace)，而表空间由段（sengment）、区（extent）、页（page）组成。 在一些文档中extend又称块（block）。这里有几个概念简单介绍下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;表空间（Tablespace）&lt;/strong&gt; 是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为&lt;a href=&#34;https://dev.mysql.com/doc/refman/5.7/en/innodb-system-tablespace.html&#34;&gt;系统表空间&lt;/a&gt;、&lt;a href=&#34;https://dev.mysql.com/doc/refman/5.7/en/innodb-file-per-table-tablespaces.html&#34;&gt;File-per-table 表空间&lt;/a&gt;、&lt;a href=&#34;https://dev.mysql.com/doc/refman/5.7/en/general-tablespaces.html&#34;&gt;通用表空间&lt;/a&gt;、&lt;a href=&#34;https://dev.mysql.com/doc/refman/5.7/en/innodb-undo-tablespaces.html&#34;&gt;撤销表空间&lt;/a&gt;、&lt;a href=&#34;https://dev.mysql.com/doc/refman/5.7/en/innodb-temporary-tablespace.html&#34;&gt;临时表空间&lt;/a&gt;。(表空间文件可以通过xxd进行分析)&lt;/p&gt;
&lt;p&gt;在 InnoDB 中存在两种表空间的类型：共享表空间(例如系统表空间或通用表空间)和独立表空间(File-per-table 表空间)。如果是共享表空间就意味着多张表共用一个表空间。如果是独立表空间，就意味着每张表有一个独立的表空间，也就是数据和索引信息都会保存在自己的表空间中。独立的表空间可以在不同的数据库之间进行迁移。禁用&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_file_per_table&#34;&gt;&lt;code&gt;innodb_file_per_table&lt;/code&gt;&lt;/a&gt; 会在系统表空间中创建表。&lt;/p&gt;
&lt;p&gt;mysql8.0 InnoDB存储引擎对磁盘结构中的表空间操作有些改变：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;8.0版本中，系统表空间只是更改缓冲区的存储区域；以前版本是InnoDB数据字典、双写缓冲区、更改缓冲区和撤消日志的存储区域 。(如果表是在系统表空间中创建的，而不是在每个表文件或通用表空间中创建，则它还可能包含表和索引数据)&lt;/li&gt;
&lt;li&gt;在8.0以前的 MySQL 版本中，系统表空间包含InnoDB数据字典。在 MySQL 8.0 中InnoDB将元数据存储在 MySQL 数据字典中。&lt;/li&gt;
&lt;li&gt;在 MySQL 8.0.20 之前，doublewrite 缓冲区存储区位于InnoDB系统表空间中；从 MySQL 8.0.20 开始，双写缓冲区存储区域位于双写文件中。附上官方mysql8.0 InnoDB存储引擎架构图(对比 &lt;a href=&#34;https://dev.mysql.com/doc/refman/5.7/en/innodb-architecture.html&#34;&gt;5.7版本架构&lt;/a&gt;)：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://dev.mysql.com/doc/refman/8.0/en/images/innodb-architecture.png&#34; alt=&#34;innodb-architecture&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;段（Segment）&lt;/strong&gt; 由一个或多个区组成，区在文件系统是一个连续分配的空间（在 InnoDB 中是连续的 64 个页），不过在段中不要求区与区之间是相邻的。段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;区（extent）&lt;/strong&gt; 在 InnoDB 存储引擎中，一个区会分配 64 个连续的页。因为 InnoDB 中的页大小默认是 16KB，所以一个区的大小是 64*16KB=1MB。在任何情况下每个区大小都为1MB，为了保证页的连续性，InnoDB存储引擎每次从磁盘一次申请4-5个区。默认情况下，InnoDB存储引擎的页大小为16KB，即一个区中有64个连续的页。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;页（page）&lt;/strong&gt; 是InnoDB存储引擎磁盘管理的最小单位，每个页默认16KB，页结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blogstatic.haohtml.com/uploads/2019/08/1d49c975639e53fe92466f0b1ebe2b2a99672e8b-1024x828.jpeg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Page directory 页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），每个槽相当于指针指向了不同组的最后一个记录，这样方便二分查找快速定位到记录；&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://blogstatic.haohtml.com/uploads/2019/08/innodb-page-dir-1024x959.jpg&#34; alt=&#34;page-slot&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;行（row）&lt;/strong&gt; InnoDB存储引擎是按行进行存放的，每个页存放的行记录也是有硬性定义的，最多允许存放16KB/2-200，即7992行记录。&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html&#34;&gt;InnoDB 行格式&lt;/a&gt;支持四名的格式：REDUNDANT，COMPACT， DYNAMIC，和COMPRESSED，默认DYNAMIC&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;B+ 树是如何进行记录检索的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果通过 B+ 树的索引查询行记录，首先是从 B+ 树的根开始，逐层检索，直到找到&lt;strong&gt;叶子节点&lt;/strong&gt;，也就是找到对应的&lt;strong&gt;数据页&lt;/strong&gt;为止，如果数据页没在缓冲池中，将数据页加载到内存 &lt;strong&gt;缓冲池(buffer pool)&lt;/strong&gt; 中，页目录中的 &lt;strong&gt;槽(slot)&lt;/strong&gt; 采用二分查找的方式先找到一个粗略的&lt;strong&gt;记录分组&lt;/strong&gt;，然后再在分组中通过链表遍历的方式查找&lt;strong&gt;记录&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;缓冲池buffer-pool--lru链表&#34;&gt;缓冲池(buffer pool) + LRU链表&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;缓冲池(buffer pool)&lt;/strong&gt; 是主内存中的一个区域，用于在 &lt;code&gt;InnoDB&lt;/code&gt;访问时缓存表和索引数据。缓冲池允许直接从内存访问经常使用的数据，从而加快处理速度。在专用服务器上，多达 80% 的物理内存通常分配给缓冲池。&lt;/p&gt;
&lt;p&gt;这里有个问题，比如有如下 场景，一个直播间id为1的观看人数上百万，假如运营后台需要查找全部数据，（这里假设没有通过CQRS模式将数据放入ES中，ES查询缓存也用到了LRU, 可以参考这篇&lt;a href=&#34;https://www.easyice.cn/archives/367&#34;&gt;Elasticsearch 的查询缓存&lt;/a&gt;）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;select * from room_student_history where room_id=1  and id&amp;gt;=(select id from room_student_history where order by id limit 1000000,1) order by id limit 1000&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果room_student_history中有大量长尾用户数据并且读取之后不会继续使用,则LRU头部会被大量的room_student_history中的数据占据。这样会造成热点数据被逐出缓存从而导致大量的磁盘io ;&lt;/p&gt;
&lt;p&gt;mysql innodb的buffer pool使用了一种改进的LRU算法，大意是将LRU链表分成两部分，一部分为newlist,一部分为oldlist,newlist是头部热点数据，oldlist是非热点数据,oldlist默认占整个list长度的3/8.当初次加载一个page的时候，会首先放入oldlist的头部，只有满足一定条件后，才被移到new list上，主要是为了防止预读的数据页和全表扫描污染buffer pool。详细介绍见&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://dev.mysql.com/doc/refman/8.0/en/images/innodb-buffer-pool-list.png&#34; alt=&#34;innodb-buffer-pool&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;​	缓/内存io比磁盘io快许多，但是缓/内存空间有限，且无法持久化，所以需要提供缓/内存淘汰机制来保证缓/内存使用命中率，本文介绍常用的LRU算法；golang实现的开源方案，可以结合业务场景，进行使用，redis 为了节省空间，通过抽样将淘汰的数据放入待淘汰数据池(evictionPoolEntry) 进行淘汰，在 Redis 3.0 中使用 10 个样本大小，该近似值非常接近 Redis 3.0 的原始LRU理论性能。mysql 需要充分利用缓存池资源，减少磁盘io, 因为加载单元是page, 如果第一次加载放入LRU链表头，可能这些数据使用频率不高，导致缓存池命中率低，将LRU链表按3/8分成old list 和new list , 第一次加载放入oldList头，再次访问时才会移动到newlist。根据淘汰的结构，根据数据使用场景，将LRU算法优化, redis和mysql 都用到了pool, 但是是两种场景，redis是为了淘汰释放使用样本pool, 样本池中放入的是idle值，根据不同策略算出的值，用来淘汰最大的idle, 方便扩展优化算法； mysql 中的pool是buffer pool 缓冲池，主要是为了存放page, page 是innodb磁盘管理的最小单位，为了减少磁盘io, 尽量减少缓存miss, 增加hit率，提高读写操作方案。&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;references&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)&#34;&gt;Cache_replacement_policies#Least_recently_used_(LRU)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Adaptive_replacement_cache&#34;&gt;Adaptive_replacement_cache&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Page_replacement_algorithm&#34;&gt;Page_replacement_algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://antirez.com/news/109&#34;&gt;Random notes on improving the Redis LRU algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://redis.io/topics/lru-cache&#34;&gt;Using Redis as an LRU cache&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://brenocon.com/dean_perf.html&#34;&gt;Numbers Everyone Should Know&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://videolectures.net/wsdm09_dean_cblirs/&#34;&gt;Challenges in Building Large-Scale Information Retrieval Systems&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html&#34;&gt;mysql8.0 innodb-buffer-pool&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/dev/mysql-server/latest/dir_7bd8f96740b7dc138f256daa629f1e06.html&#34;&gt;mysql8.0 source code page Directory Reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mysql.taobao.org/monthly/2017/11/05/&#34;&gt;MySQL · 源码分析 · InnoDB LRU List刷脏改进之路&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mysql.taobao.org/monthly/2017/05/01/&#34;&gt;MySQL · 引擎特性 · InnoDB Buffer Pool&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/internals/en/&#34;&gt;MySQL Internals Manual&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
      
    </item>
    
    <item>
      <title>服务改造简述</title>
      <link>https://weedge.github.io/post/servicetransformation/</link>
      <pubDate>Tue, 26 Oct 2021 22:04:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/servicetransformation/</guid>
      
        <description>&lt;h4 id=&#34;背景&#34;&gt;背景&lt;/h4&gt;
&lt;p&gt;随着前期业务迭代不断增多，会留下一些技术债务；用户不断累计增加，整体DAU,MAU,PV/UV的不断上升，为了符合根据组织结构和业务需求更加稳定健康的发展，需要对业务服务进行改造/重构；采用团队适合的语言开发，将服务进行分层，抽象底层模型，分离出不变/易变业务逻辑；业务改造和基础建设服务升级（整体系统认知的改变）&lt;/p&gt;
&lt;h4 id=&#34;过程&#34;&gt;过程&lt;/h4&gt;
&lt;p&gt;整体服务分为4个阶段进行简述：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;快速上线，需求多，迭代快，开发团队整体使用熟悉开发框架（效益：前期起步使用rd熟悉的开发脚本语言，支持需求快速迭代）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后面功能复用， 建设业务中台， 直播中台，互动中台的建设，中台的请求大，采用golang进行开发，（效益：整体机器资源消耗减少, 高峰期机器负载降低)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据直播业务场景，抽象中台底层数据模型，（效益：减少人力，提高复用，增加整体研发效能）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;开发语言迁移， 服务模型从多进程脚本弱类型语言切到多协程强类型语言，需要适配接口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要梳理核心服务接口和非核心服务接口，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务上线，迁移老接口， 需要做流量的切分，新老接口的diff , 有两种方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在业务层面加上灰度策略，通过策略配置，对不同的业务id进行异步分流，一份请求数据，2份响应数据，只返回老的响应数据，新老响应数据进行diff处理；优点：业务改造方自己把控；缺点：对业务代码有侵入，如果改造灰度策略多的话，会降低业务代码逻辑稳定性；&lt;/li&gt;
&lt;li&gt;在新老服务之上加一层接口代理层，接口适配，灰度策略流量切分，新老接口diff功能 移至 接口代理层做，相当于提供一层网关服务来处理；优点： 对接口灰度进行统一管理，不会对业务代码有浸入操作；缺点：多了一层代理层，接口响应时间会有所增加，需要保证代理层的稳定性；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;两种方案都可以，需要结合组织结构来考虑开发技术成本， 方案一：不需要额外的人力来支持维护代理层；方案二：需要单独的团队或者开发人员来维护代理层； 如果看整体收益的话，偏向于第二种方案，前者就是战术编程，后者就是战略编程，应该侧重战略编程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;课中直播是流量突发的场景，对于服务优化改造，服务压力测试必不可少：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;接口压测，关注qps，接口响应时间，服务监控，负载等情况；&lt;/li&gt;
&lt;li&gt;全链路压侧，关注tps，整体链路调用接口响应时间耗时，总响应时间耗时，各服务监控，负载等情况；并且输出测试报表；为了不污染线上数据，需要对基础存储组件 单独部署一套影子系统，服务链路上需要加上压侧标签参数；可参考：&lt;a href=&#34;https://help.aliyun.com/document_detail/29337.html&#34;&gt;性能测试 PTS&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保证切流过程中服务比较稳定，进行周期性引流，切流观察：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;旁路引流diff，覆盖到业务全场景的情况，diff在可接受范围内，进行下一步 流量切流&lt;/li&gt;
&lt;li&gt;为了保证服务稳定性，不出现p0,p1,p2事故，流量切换的周期一般比较长，按覆盖到的业务场景和整体服务监控情况而定，按1%、2%、10%、20%，40%，80%放量；查看客户端是否有异常以及用户的反馈工单，切流放量阶段diff还是正常进行，返回是否有问题，存放数据是否一致；没有问题，进入下一步  线上观察&lt;/li&gt;
&lt;li&gt;线上观察一段时间，会以月为单位，观察阶段主要服务流量是新改造的服务，如果发现有异动，还可以切回原来的服务；如果观察阶段没有问题，可以下掉原来的服务了；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务改造过程中，会有新的业务需求进来，如果是大的需求，开发周期比较长的项目，如果是紧急项目，只能在原有服务上进行开发，后续在迁移至新系统中；对于非紧急需求，可以暂缓压压，可以等新服务上线稳定之后，在使用新服务框架开发，上线部署，主要看需求中是否需要修改老接口，还是直接提供新接口就可以满足；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;容器化改造，上云（效益：整体测试，线上环节保持一致，节约开发测试时间；线上服务治理通过K8S+Istio,进行网格化治理, 以前部署在物理机或者虚拟机上，混部的情况，资源分配和隔离不合理，迁移后，可以充分合理利用宿主物理机/虚拟机资源，隔离，弹性扩缩容，部署上线前提条件是需要保证K8S可用性）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对不同语言服务进行容器化改造，有不同业务部门推进(主要是项目构建打包成镜像，docker的话需要编写Dockerfile)，基础的资源管理由devops提供CI(gitlab ci)/CD平台整合上线(可以部署物理机/虚拟机/部署(kubectl/istioctl)容器上云)&lt;/li&gt;
&lt;li&gt;在迁移至容器云(Kubernetes 集群中的应用)的过程中，会涉及到一部分服务容器化部署上线，一部分还是部署在物理机/虚拟机上，服务之间相互访问，容器云-&amp;gt;容器云，容器云-&amp;gt;物理机/虚拟机， 物理机/虚拟机-&amp;gt;容器云，需要业务梳理出服务之间的调用关系，然后对3种服务调用情况进行改造，其中可以使用sidecar模式进行流量输入输出&lt;/li&gt;
&lt;li&gt;通过K8S来编排服务，会出现服务治理的问题，需要可视化，监控，追查定位问题等相关平台来整合，对应的规范和开源工具整合进来，log: 采集日志，存储日志(热/冷)，查找日志；metric: 监控数据采集，监控指标，监控看板/大盘；trace: 服务请求访问链路追踪，服务调用响应时间，整体响应时间；以及k8s本身调度节点中pod资源监控&lt;/li&gt;
&lt;li&gt;部署至容器云后的整体测试，接口压侧，整体链路压侧&lt;/li&gt;
&lt;li&gt;上线后的切流方案&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;总结&#34;&gt;总结&lt;/h4&gt;
&lt;p&gt;随着业务的发展，服务不断迭代改造，涉及到业务层面抽象改造，以及基础平台服务的升级；最终目的都是为了满足日益增长的需求，缩短需求发布到上线的周期，复用，减少迭代对服务整体稳定性的影响。&lt;/p&gt;
&lt;h4 id=&#34;references&#34;&gt;References&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/practice/service-discovery-and-loadbalancing.html&#34;&gt;k8s-service-discovery-and-loadbalancing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.servicemesher.com/istio-handbook/practice/integration-registry.html&#34;&gt;istio集成服务注册中心&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.servicemesher.com/istio-handbook/concepts/sidecar-injection.html&#34;&gt;Sidecar 模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhaohuabing.com/post/2019-10-21-pilot-discovery-code-analysis/&#34;&gt;Istio Pilot 组件介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
      
    </item>
    
    <item>
      <title>工程师六大意识</title>
      <link>https://weedge.github.io/post/rd/</link>
      <pubDate>Sat, 02 Oct 2021 10:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/rd/</guid>
      
        <description>&lt;h2 id=&#34;1时间意识&#34;&gt;&lt;strong&gt;1.时间意识&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;​    时间意识的终极目标是按时保质的完成工作。时间是一种宝贵的资源，由于每天工作时间的有限的而需要处理事情是复杂多变性的，为了按时保质的完成工作，我们首先需要有极强的时间意识，使用科学的时间管理策略。总的来说，时间管理就是让我们更有计划的知道需要做什么，什么时候做什么，而时间管理的难点为：事情具有突发性、完成时间难以预算性、执行力和预期不符合。&lt;/p&gt;
&lt;h3 id=&#34;11做明确计划&#34;&gt;1.1做明确计划&lt;/h3&gt;
&lt;p&gt;​    花一定的时间专门做计划，精确到小时，磨刀不误砍材工。为了做出精确的计划，提高时间的利用率，我们可以把个人时间和任务安排分块化，让同性质的任务部门分配同一段时间来处理，让零碎的时间处理细碎的问题，高效率的时间做大块重要困难的问题。&lt;/p&gt;
&lt;h3 id=&#34;12能尽快完成就尽快完成给以突发事情一定预算余地&#34;&gt;1.2能尽快完成就尽快完成，给以突发事情一定预算余地&lt;/h3&gt;
&lt;p&gt;​    即使每天计划的清清楚楚的工作安排，还是很大可能出现突发事情打乱计划，因为我们的工作性质就是这样的，需要随时待命解决突发的问题，并且很多事情是难以准确预算完成时间的，所以我们应该尽快的完成任务而不是拖到最后甚至拖到明天，这样才能最大限度的留给未知可能的处理空间。&lt;/p&gt;
&lt;p&gt;​    现在的社会处于互联网产业高速发展时期，到处充满着机遇，但是不管对企业还对个人来说又都面领着极大的竞争挑战。想要在这样的环境下生存并且前进，需要我们具有争分夺秒的意识，今天落后一步，就需要无数天的加速才能追上别人，更重要的是，身为团队的一员，很可能因为自己的一点懈怠而拖慢团队的脚步。&lt;/p&gt;
&lt;h3 id=&#34;13总结提高锻炼坚毅的性格提高执行力度&#34;&gt;1.3总结提高，锻炼坚毅的性格，提高执行力度&lt;/h3&gt;
&lt;p&gt;​    除了事情本身的多变性和竞争的激烈性，还有一点就是我们通常会高估自己的执行力，这需要我们我们进行自我管理自我约束，培养坚毅的性格，具有很强的责任心，高效率的执行力，主动的向别人汇报进度，树立起一个让自己和别人都信得过的形象。我们还需要不断的总结提高计划的准确性，看清自己，看清问题，将自己和问题准确的在时间维度上来对应起来。&lt;/p&gt;
&lt;h2 id=&#34;2质量意识&#34;&gt;&lt;strong&gt;2.质量意识&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;​    时间是宝贵的资源，但是不能为了节省时间而降低质量，时间是用来使用的，真正的节省时间就是合理高效的使用时间。欲速则不达，在复杂庞大的网络环境中，每一个小小的质量问题，都可能导致巨大的灾难，比如有可能这个灾难只是因为某一个进制转换精度损失引起的。如何保证质量，需要个人的责任心、需要团队的正确文化氛围、需要科学的质量保证流程。&lt;/p&gt;
&lt;p&gt;​    首先需要我们拥有一个保证质量的责任心，每一个人都要对质量负责，要有居安思危的意识，不能默认没问题，而是要反复核对自己的工作，不要等着别人来发现自己的问题，不要依赖流程，比如开发不能依赖测试，测试只是最后的质量检查而已，而不是保证，而且局限性小，即使测试出问题，修改也是费时费力。&lt;/p&gt;
&lt;p&gt;​    然后就是有一套科学的质量保证流程，比如需求的审核、开发的测试、上线过程评审等，质量保证工作存在于每一个环节，早发现早解决，因为越到后面挽救的代价越大。&lt;/p&gt;
&lt;h2 id=&#34;3沟通意识&#34;&gt;&lt;strong&gt;3.沟通意识&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;​    沟通的本质就是，了解他人的需要，表达自己的需要，沟通是项目成功的重要技巧之一。沟通无处不在，包括：文档、邮件、合同，更直接点的就是电话、口头。对于开发而言，代码本身就是用于沟通，所以我们要严格要求代码规范，要意识到代码是要用于沟通的，让人一看就懂的才是好代码。&lt;/p&gt;
&lt;h3 id=&#34;31沟通的态度&#34;&gt;3.1沟通的态度&lt;/h3&gt;
&lt;p&gt;​    沟通中的双发是代表各自角色的沟通，而不是个人间的沟通，也是通常我们说的 对事不对人 。因此，我们在沟通中不要忘记自己的职业角色，也不要忽视对方的职业角色。在沟通中我们要公开和坦诚地表达自己的意见，同时要有尊重别人的权利的态度，多用描述性语句，少用判断性语句，要有积极的态度。&lt;/p&gt;
&lt;h3 id=&#34;32主动沟通&#34;&gt;3.2主动沟通&lt;/h3&gt;
&lt;p&gt;​    看问题的角度不同，看法和观点会不一致，我们无法寄希望于对方主动来找我们沟通，所以为了得到好的结果，我们需要主动去沟通。所以要做好以下几点：&lt;/p&gt;
&lt;p&gt;（1）做好沟通前的准备，想好要表述的问题和想知道的问题&lt;/p&gt;
&lt;p&gt;（2）把握沟通时机，要在适当的时间、地点，同时考虑好沟通对象的状态。&lt;/p&gt;
&lt;p&gt;（3）选择好沟通方式，根据沟通紧急程度，具体问题的不同，选择合适的沟通方式，如：面谈、电话、书面（含即时通讯工具）等&lt;/p&gt;
&lt;h2 id=&#34;4团队意识&#34;&gt;&lt;strong&gt;4.团队意识&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;​    要实现目标，最重要的就是团队，我们让自己变得优秀的本质也是为了能够为团队做更大的贡献，通过团队实现个人，也通过个人贡献团队。听说这样一句话，一个中国人是一条龙，一群中国人是一群虫，这就是我们在国外人眼中缺少团队的意识。对于团队我们要有以下意识：&lt;/p&gt;
&lt;h3 id=&#34;41集体荣誉感&#34;&gt;4.1集体荣誉感&lt;/h3&gt;
&lt;p&gt;​    要有集体荣誉感，凡事看大局，每个人都是团队的一份子，不能有打酱油的心态。&lt;/p&gt;
&lt;h3 id=&#34;42建立完善的规则&#34;&gt;4.2建立完善的规则&lt;/h3&gt;
&lt;p&gt;​    没有规矩，不以成方圆，没有没有纪律的军队，不可能打胜仗。对于研发团队，统一的规则可以有效的减低沟通成本，集合整个团队的智慧，降低错误的可能性，规则要不断总结，不断优化。&lt;/p&gt;
&lt;h3 id=&#34;43团结互进&#34;&gt;4.3团结互进&lt;/h3&gt;
&lt;p&gt;​    团队之间要互相信任，乐于为别人提供帮助，乐于和善于从其他同事那里获得帮助，互相学习共同进步。开诚布公、相互尊重、相互理解，多站在对方的立场上考虑，对事不对人。团队意识不等于哥们义气、拉帮结派，也不等于好好先生，建立优秀的团队氛围。&lt;/p&gt;
&lt;h3 id=&#34;44建立强沟通&#34;&gt;4.4建立强沟通&lt;/h3&gt;
&lt;p&gt;​    团队要强调沟通意识，以各种方式建立起成员之间的联系。&lt;/p&gt;
&lt;h2 id=&#34;5进取意识&#34;&gt;&lt;strong&gt;5.进取意识&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;​    要有理想，有进取心，不断的追求更高的目标。在激烈竞争的环境，要有忧患意识，不断进步，否则迟早要淘汰。而进取意识最终要的是客服自己的心态，“破山中贼易，破心中贼难”，&lt;strong&gt;对自己的要求比别人对自己的要求更严格&lt;/strong&gt; ，客服自己的内心，加强计划性和执行力，这是见于所有能快速成长的优秀工程师所共有特质，而恰恰是那些不适应一个高速成长的团队而被淘汰掉的工程师身上所最缺乏的东西。&lt;/p&gt;
&lt;p&gt;​    要未雨绸缪，也要容忍失败。进取是为了未雨绸缪，但是进取不代表不会失败，而是指能在失败面前勇于剖析、勇于承担责任，又能自我总结经验教训、保持自己的进取心。 ¡&lt;/p&gt;
&lt;h2 id=&#34;6求实意识&#34;&gt;&lt;strong&gt;6.求实意识&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;​    实事求是，是《毛泽东思想》的精髓之一，也正是实事求是，不搞虚的，才能有高速发展的中国的今天。在实际项目中要注重事实，反对弄虚作假，大胆的假设小心地求证，一切以数据说话，用准确的数字和事实来论证，不能只有臆测的结论。&lt;/p&gt;
&lt;p&gt;​    以量化指标作为判断的依据，实际数据为王，没有量化，就没有绩效，通过这些指标衡量自己的成长和进步，通过这些指标知道工作的方向和重点。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;工程师，是从复杂的需求中，&lt;strong&gt;定义问题&lt;/strong&gt;，解决问题，给出具体方案而生的工种，不能单兵作战，需要通过高效的工具进行武装，对复杂重复通用的场景进行沉淀下移，方便其他工程师使用，所谓开源；在不断挖坑填坑中，解决特定任务，锻炼出皮实耐操的难得品格，需求虐我千百遍，我对需求如初恋；没有需求何来架构落地呢，何来量化指标，升值加薪呢～&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>组织引擎</title>
      <link>https://weedge.github.io/post/zborg/</link>
      <pubDate>Sun, 05 Sep 2021 21:04:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/zborg/</guid>
      
        <description>&lt;h2 id=&#34;背景&#34;&gt;背景：&lt;/h2&gt;
&lt;p&gt;教学直播间场景多样性，按年龄段区分辅导后台角色，构成整个教学课中直播和互动的多样性，为了快速支持业务发展，导致后端服务接口过多，不易维护，统一管理。&lt;/p&gt;
&lt;p&gt;主要分为如下场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;对接辅导侧后台的场景：&lt;/strong&gt; 辅导侧不同的辅导运营后台，比如：低幼辅导，班主任(班课)，督学服务，0转化督学服务等，后续可能还有小鹿编程，大师素养课对应的辅导侧；辅导侧会分班去带学生，不同的辅导侧会有单独的课中业务服务来对接辅导后台的接口，课中理解不同的业务组织形态，代码逻辑和存放数据冗余，不方便维护；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;业务前台对接直播接口场景&lt;/strong&gt;：直播业务服务多样；按照课程类型分为专题课，班课，短训班，素养课，编程课等；直播服务：班主任出镜（课前，课中，课后），小班，小组，大班，自习室等；服务的多样性，导致业务接口繁琐，前期快速开发上线，针对每个直播服务业务场景单独提供接口， 带来的问题不方便统一管理维护；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;课中互动中台互动聊天场景：&lt;/strong&gt; 大班，小班，小组直播间场景依赖售卖和辅导侧的组织结构进行聊天，答题，鼓励，PK，发红包等互动；导致课前需要对这些组织结构按照不同直播场景+不同辅导侧数据进行提前预热处理，逻辑重复；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;设计目标&#34;&gt;设计目标：&lt;/h2&gt;
&lt;p&gt;需要一个承上启下的模块来连接辅导侧支撑课中直播/回放互动场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对不同业务直播场景进行收敛，减少重复开发；&lt;/li&gt;
&lt;li&gt;隔离底层业务后台辅导侧，售卖侧数据，统一接入辅导/售卖侧全量数据，以及异动，减少数据冗余；&lt;/li&gt;
&lt;li&gt;隔离底层业务数据，抽象直播中台数据模型，中台面向这个数据模型进行编程，提供原子化接口；&lt;/li&gt;
&lt;li&gt;当天上课课前预热数据需要在0-6点尽量全部预热完成；预热加速，预热后的数据检查；&lt;/li&gt;
&lt;li&gt;复用中台数据模型已支持的直播场景能力，提供saas化服务，前台使用中台定义的dsl，根据业务场景进行组装，提高开发效率；&lt;/li&gt;
&lt;li&gt;提供可配置后台，管理服务接口；&lt;/li&gt;
&lt;li&gt;将读写io最小化，提高原子化接口响应时间RT&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;原则： 高内聚低耦合、空间换时间&lt;/p&gt;
&lt;h2 id=&#34;数据模型&#34;&gt;数据模型：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一个章节会有多个直播间，比如辅导老师出镜(课前，课中，课后)，最多3n+1个直播间，n为课程章节下的辅导老师数目，liveRoom&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不同直播间，对应不同的直播间业务流程:  bizType&lt;/p&gt;
&lt;p&gt;三分屏直播间，进入教室→签到→直播/互动→离开(切直播间)&lt;/p&gt;
&lt;p&gt;小组直播间，进入教室→课件下载→分组→签到→直播/互动→离开(切直播间)&lt;/p&gt;
&lt;p&gt;小班直播间，进入直播间→ 课件下载→ 分班→ 直播/互动→离开(切直播间)&lt;/p&gt;
&lt;p&gt;自习室直播间，进入直播间→ 签到→直播&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不同直播间，对应不同的流媒体推拉流方案：streamPolicy&lt;/p&gt;
&lt;p&gt;三分屏直播间，rtmp + 长链接&lt;/p&gt;
&lt;p&gt;小组直播间，rtc + 长链接&lt;/p&gt;
&lt;p&gt;小班直播间，rtc + 长链接&lt;/p&gt;
&lt;p&gt;自习室直播间，rtmp + 长链接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不同组织关系对应聊天互动广播统计维度，抽象组织结构：orgPolicy, orgTree(node)&lt;/p&gt;
&lt;p&gt;一课三分屏：/课程章节,  无班主任，全员互动；课中自动生成；&lt;/p&gt;
&lt;p&gt;小英小数小语文小组直播间，/课程章节/辅导老师/{队/小组}，  辅导老师： 低幼辅导，班主任(班课)，督学服务，0转化督学服务等， 队/小组由课中学生选组自动生成；低幼辅导，班主任，督学服务，0转化督学服务提供数据；&lt;/p&gt;
&lt;p&gt;班主任小班直播间，/课程章节/辅导老师/小班，辅导老师： 低幼辅导，班主任(班课)，小班由辅导侧课前排灌班生成；低幼辅导，班主任服务提供数据；&lt;/p&gt;
&lt;p&gt;短训班，/课程章节/督学LPC/微信群，微信群有督学老师课前排灌班生产，督学服务提供数据；&lt;/p&gt;
&lt;p&gt;0转化服务，/课程章节/督学LPC , 0转化督学服务提供数据；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;lessonPolicy: (bizType,streamPolicy,orgPolicy)&lt;/p&gt;
&lt;p&gt;原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;直播中台解耦业务属性，支持抽象业务场景，作为底层直播能力输出；&lt;/li&gt;
&lt;li&gt;可复用，直播功能，性能，稳定性的复用；比如三分屏，班课，小组，伪直播等不同维度业务属性解耦前置到预热阶段；&lt;/li&gt;
&lt;li&gt;可扩展，直播数据模型属性如有新增，不会影响原有属性；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数据量&#34;&gt;数据量：&lt;/h2&gt;
&lt;p&gt;1天最高峰2w节课，总报名学生数量600w+， 在线学生100w+ ， 课中进入上课页面qps 120w+&lt;/p&gt;
&lt;p&gt;处理数据量：按一个课程章节来计算，最大的报名学生数目3w+  实际测试用60w+ 的报名学生，预热大概45多分钟&lt;/p&gt;
&lt;p&gt;3w 的报名学生， 小组直播间，班主任出镜，一个班主任最多带500学生，预热大概 1分钟30多秒&lt;/p&gt;
&lt;p&gt;策略数据： 一个章节对应一个策略，一个策略可以给多个章节使用，&lt;/p&gt;
&lt;p&gt;policy (id,conf,desc,name)&lt;/p&gt;
&lt;p&gt;lessonPolicy (keyId,keyType,bizType,partition,policyId)&lt;/p&gt;
&lt;p&gt;直播间数量： 3n+1 (n是班主任数目，出镜场景） 最多181个直播间 180*8*5(id,roomId,virturalRoomId,rootId,bizId,roomType,teacherUid,startTime,endTime,status) = 7.2KB&lt;/p&gt;
&lt;p&gt;组织节点数量：3w/6=5000个小组节点，5000/6 = 800多个队节点，60个辅导老师节点，总共6000个组织节点， 6000*8*7(id, nodeId,parentId,rootId,virturalNodeId,sourceId,path) =328KB&lt;/p&gt;
&lt;p&gt;用户数量： 3w+  每个班主任最多带500个学生，  3w/500 = 60  个班主任，最多 181 个直播间， 180*500 + 3w =12w条直播间用户数据， 按直播间维度协程任务分批处理; 12w*8*4(id,uid,nodeId,roomId) =3.7MB&lt;/p&gt;
&lt;p&gt;一天大概总共 2w * 4M =  78GB数据可能需要课前预热 （以一天最大2w节课程章节，每个章节报名人数3w计算, 报名学生2w*3w =6亿）&lt;/p&gt;
&lt;h2 id=&#34;依赖中间件基础服务&#34;&gt;依赖中间件基础服务&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;redis (stored k/v存储）  前期是哨兵模式架构， 后期采用proxy模式架构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DB(mysql ) 主从架构，未使用proxy数据库中间件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MQ(NMQ, RocketMQ) 消息队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前期用的NMQ  消息以push的方式发送的消费方，通过groupKey来保证有序，以及消息积压报警，无限重试，消费方来保证幂等&lt;/p&gt;
&lt;p&gt;RMQ是为了兼容NMQ , 对rocketMQ进行来封装， 消息生成侧提供proxy, 兼容nmqproxy；消费侧rocketMQ是pull长轮训方式，为了兼容NMQ的push方式，提供pusher模块；数据存放用rocketMQ的broker&lt;/p&gt;
&lt;p&gt;rocketMQ : &lt;a href=&#34;https://github.com/apache/rocketmq/tree/master/docs/cn&#34;&gt;https://github.com/apache/rocketmq/tree/master/docs/cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;kafka : &lt;a href=&#34;https://kafka.apachecn.org/intro.html&#34;&gt;https://kafka.apachecn.org/intro.html&lt;/a&gt; 长链接心跳打点数据 → kafka → 计算引擎&lt;/p&gt;
&lt;h2 id=&#34;流程&#34;&gt;流程&lt;/h2&gt;
&lt;h3 id=&#34;数据对接方&#34;&gt;&lt;strong&gt;数据对接方&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;预热模块接入辅导侧三方数据：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;班主任侧（小班，辅导老师：班主任）&lt;/li&gt;
&lt;li&gt;督学服务侧（微信服务，辅导老师：督学）&lt;/li&gt;
&lt;li&gt;0转化督学服务侧（拉新转化，辅导老师：0转化督学）&lt;/li&gt;
&lt;li&gt;低幼服务侧（小班，辅导老师：班主任）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;场景直播间维度&#34;&gt;&lt;strong&gt;场景（直播间维度）&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;一个章节里一个主直播间一个组织树 （非出境）&lt;/li&gt;
&lt;li&gt;一个章节里多个主直播间一个组织树 （出境）&lt;/li&gt;
&lt;li&gt;一个章节里多个主直播间对应多个从直播间多个组织树 （旁听+出境）&lt;/li&gt;
&lt;li&gt;多个章节情况都转化成一个章节下的直播间情况 （共享）&lt;/li&gt;
&lt;li&gt;跟课场景：一个章节可能给不同的辅导侧在使用，辅导平台的数据源不同，一个组织树对应多个业务组织，一个直播间主讲推流，多个辅导侧后台拉流监控&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;流程-1&#34;&gt;流程&lt;/h3&gt;
&lt;p&gt;定义规范辅导侧数据接入 → 上课课程章节绑定对应策略(如不满足，新增支持）→ 分发任务前置预热 → 生成中台理解的属性 (liveRoom,lessonPolicy,orgTree 等)  →直播中台面向这些属性编程，提供原子化读写接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/weedge/mypic/master/%E7%9B%B4%E6%92%AD%E4%B8%AD%E5%8F%B0-%E7%BB%84%E7%BB%87%E5%BC%95%E6%93%8E%E6%B5%81%E7%A8%8B%E6%A1%86%E6%A1%86%E6%96%BD%E5%B7%A5%E5%9B%BE.jpg&#34; alt=&#34;直播中台-组织引擎流程框框施工图.jpg&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;策略规则平台policy&#34;&gt;策略规则平台policy：&lt;/h2&gt;
&lt;p&gt;用于不同的业务直播间类型绑定组织策略，开发提供给运营产品团队使用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;推拉流策略（rtc(udp),rtmp(tcp)+CDN 延迟较高，价格低； 学生，老师小组直播间互动场景用的rtc, 一课(三分屏)直播间用的rtmp; 辅导跟课后台，监控后台用的rtmp）；&lt;/li&gt;
&lt;li&gt;直播间策略(班主任课前/课中/课后出镜直播间，主讲直播间)；&lt;/li&gt;
&lt;li&gt;互动组织策略（基于组织树，学生，班主任，老师 通过长链接的聊天广播模式）;&lt;/li&gt;
&lt;li&gt;预热策略（极简，简单，全部预热）;&lt;/li&gt;
&lt;li&gt;预热时间计算预热时长(根据直播间数，组织节点数，用户数，计算预热时长）；用于分层时间轮来监控预热任务超时报警&lt;/li&gt;
&lt;li&gt;缓存设计中直播间的学生集合和在线学生集合 zset 分片策略（根据课程报名人数和商品库存数调权相加获取）；&lt;/li&gt;
&lt;li&gt;数据源定义（辅导侧数据：低幼，0转化督学，督学，班主任等，售卖侧数据）；&lt;/li&gt;
&lt;li&gt;异动数据通知定义 (学生更换班主任/小班，老师更换，课程章节上课时间更改，课程章节重开）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;组织数据生成引擎core&#34;&gt;组织数据生成引擎core：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;缓存设计：&lt;/p&gt;
&lt;p&gt;策略缓存/本地缓存，组织树缓存，直播间缓存，学生缓存，预热任务缓存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据库数据设计：&lt;/p&gt;
&lt;p&gt;业务策略表，组织节点表，直播间表，学生表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直播中台组织引擎课中数据接口设计：&lt;/p&gt;
&lt;p&gt;直接从缓存中取，交互的数据通过write-behind 模式写入&lt;/p&gt;
&lt;p&gt;获取组织树节点信息，节点原始节点信息，子节点信息，学生所在直播间节点，选组/位置&lt;/p&gt;
&lt;p&gt;获取业务课程章节业务id的直播间信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直播中台组织引擎回放数据接口设计：&lt;/p&gt;
&lt;p&gt;接口数据缓存，cache-aside 模式读取，课后回放数据都是读的场景&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消息队列topic 消息体设计 ：异步落库，为了同步db,  同步db逻辑幂等，降低db的写压力&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;直播间，组织节点，学生数据&lt;/p&gt;
&lt;p&gt;内部优化设计：（原则：尽量减少读写io, 达到最优解）&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;异步缓冲buffer数据批量发送队列入库，减少网络io，降低db的写压力&lt;/li&gt;
&lt;li&gt;课中老师的课件信令记录，zset存缓存，学生高并发场景获取直播间信令记录，通过本地缓存来减少对zset 大key数据读取压力&lt;/li&gt;
&lt;li&gt;任务池化，并发批量处理任务，提高吞吐相应速度&lt;/li&gt;
&lt;li&gt;临时对象池化，高并发吞吐减少gc&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;配置平台conf-dashboard&#34;&gt;配置平台conf-dashboard：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;预热流程 DSL pipeline 配置,&lt;/li&gt;
&lt;li&gt;依赖缓存和数据配置 ，&lt;/li&gt;
&lt;li&gt;业务配置，&lt;/li&gt;
&lt;li&gt;预热报警通知配置,&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;预热数据监控平台monitor-dashboard&#34;&gt;预热数据监控平台monitor-dashboard:&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;提供手动触发预热和预热数据检查；&lt;/li&gt;
&lt;li&gt;查看预热好的直播间，组织树，学生所在直播间的组织节点信息，以及课中直播间开始结束时间，直播间状态，学生在线状态，聊天状态（禁言/可聊天), 分组信息，到课时间&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;开发工具&#34;&gt;开发工具&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;线上/线下预热通知群&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;预热报警通知群&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;预热回归diff检查工具&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/weedge/mypic/master/%E9%A2%84%E7%83%AD%E6%A3%80%E6%9F%A5.jpg&#34; alt=&#34;预热检查&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/weedge/mypic/master/preload-diff.png&#34; alt=&#34;preload-diff&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;容错处理&#34;&gt;容错处理&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;分布式任务处理，如果一个机器挂了不影响任务处理，failover机制&lt;/li&gt;
&lt;li&gt;任务执行失败会右报警机制，可以手动处理重新预热，还有自动轮训检查预热是否成功机制，如果预热失败，会在下个轮训周期出发预热， 轮训周期可调，默认是10分钟&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;qa&#34;&gt;Q&amp;amp;A&lt;/h2&gt;
&lt;p&gt;Q：课前预热直播间数据为什么选择先写缓存，然后在通过mq异步落db呢？&lt;/p&gt;
&lt;p&gt;A： 因为预热的过程是异步多台机器单机进程并行预热，进程中通过协程并发处理流程预热，为了预热提速；&lt;/p&gt;
&lt;p&gt;如果直接写db, 然后在更新缓存，因为mysql是主从架构，预热是写多读多场景， 写多是因为预热数据初始写入数据库，读多是因为数据入库之后，会通知接口缓存模块去请求读db接口缓存数据(接口数据为空，不会存储，都为insert操作成功之后，才通知接口缓存模块，不会出现不一致的情况)；读请求可以通过多个从来分担，但是写的话都是在主上，分库分表都是在单实例上, 单机抗大量写请求会成为整体预热的瓶颈；&lt;/p&gt;
&lt;p&gt;如果直接写入缓存，然后mq异步落db 的形式可以充分利用缓存比磁盘读写io速度快的优势，缓存的实例部署是以proxy的形式分布式部署，可以对slot分片进行读写 扩容，分散读写压力；不会成为预热的瓶颈；（以前是无中心化的形式通过业务使用方一致性hash 来访问分布式缓存slot分片, 后面改成proxy中心化的方式，统一管理方便运维，业务使用方直接通过redis协议请求，无需关心分片操作）&lt;/p&gt;
&lt;p&gt;通过mq异步落db，mq是通过push的方式直接发给后端接口入库的，降低mq的push的并发窗口，可以减少push频率，降低后端接口的请求量，但是会消费变慢，为了加快操作，对发送给mq的数据进行buffer 处理，批量发送，通过后端接口批量写入数据库，减少网络i/o, 提高写入吞吐量；&lt;/p&gt;
&lt;p&gt;Q: 预热过程中，如果有上线，预热中断了，怎么处理呢？&lt;/p&gt;
&lt;p&gt;A： 在预热的时候会上报预热的启动状态， 旁路脚本每半小时会检查一次预热的启动状态，如果一直处于运行中，则报警，根据阈值判断(比如报名人数估算处预热时间，报警次数) 触发自动预热重新预热上；预热监控后台也提供了手动触发预热；&lt;/p&gt;
&lt;p&gt;这里没有像数据库那样使用WAL机制（进程crash后，缓存中的数据没有了，可以通过WAL日志找回），业务场景可以回溯数据，按章节或者直播间重新预热&lt;/p&gt;
&lt;p&gt;Q: 组织树的作用是什么呢？&lt;/p&gt;
&lt;p&gt;A： 将业务组织关系进行解偶，如果接入其他业务组织关系，只需要提供原始数据，就可以服务用课中的组织关系能力，提供课中组织关系下的直播互动；课中组织树是可以动态扩展的，满足课中报名人数突增的情况；&lt;/p&gt;
&lt;p&gt;Q: 后续会提供用户维度的组织树操作接口吗？&lt;/p&gt;
&lt;p&gt;A： 现在是通过采集其他平台的组织数据进行一份转化生成提供给课中直播互动使用的组织树，后续提供相关的基础读写接口来初始/更改预热数据，使用方只需要在构造业务组织结构的时候调用写入缓存&lt;/p&gt;
&lt;p&gt;Q: 现在业务数据量有多大？&lt;/p&gt;
&lt;p&gt;A: 系统是按照最大量估算的，一天大概总共 2w * 4M =  78GB数据可能需要课前预热 （报名学生2w*3w =6亿）&lt;/p&gt;
&lt;p&gt;Q: 是否考虑用工作流任务调度的方式处理呢？&lt;/p&gt;
&lt;p&gt;A: 正在考虑中，现在方式是后台绑定好预热策略，把策略发到消息队列里，然后通过消息队列负载均衡推送给预热任务执行；&lt;/p&gt;
&lt;p&gt;后面会优化成工作流任务调度的方式，将整个预热流程拆分成可单独执行的任务，然后生成一个DAG工作流，通过任务调度模块，分发到预热执行机器上执行，入度为0的任务开始启动执行&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>网络模型</title>
      <link>https://weedge.github.io/post/poller/</link>
      <pubDate>Thu, 02 Sep 2021 10:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/poller/</guid>
      
        <description>&lt;p&gt;看了一些开源的网络I/O模型框架库，尝试着按照理解简单实现一个相对简单的网络I/O模型框架，类似netty的reactor模型。&lt;/p&gt;
&lt;p&gt;Netty的NIO模型是Reactor反应堆模型（Reactor相当于有分发功能的多路复用器Selector）。每一个连接对应一个Channel（多路指多个Channel，复用指多个连接复用了一个线程或少量线程，在Netty指EventLoop），一个Channel对应唯一的ChannelPipeline，多个Handler串行的加入到Pipeline中，每个Handler关联唯一的ChannelHandlerContext。&lt;/p&gt;
&lt;p&gt;Reactor 模式的基本工作流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Server 端完成在 &lt;code&gt;bind&amp;amp;listen&lt;/code&gt; 之后，将 listenfd 注册到 epollfd 中，最后进入 event-loop 事件循环。循环过程中会调用 &lt;code&gt;select/poll/epoll_wait&lt;/code&gt; 阻塞等待，若有在 listenfd 上的新连接事件则解除阻塞返回，并调用 &lt;code&gt;socket.accept&lt;/code&gt; 接收新连接 connfd，并将 connfd 加入到 epollfd 的 I/O 复用（监听）队列。&lt;/li&gt;
&lt;li&gt;当 connfd 上发生可读/可写事件也会解除 &lt;code&gt;select/poll/epoll_wait&lt;/code&gt; 的阻塞等待，然后进行 I/O 读写操作，这里读写 I/O 都是非阻塞 I/O，这样才不会阻塞 event-loop 的下一个循环。然而，这样容易割裂业务逻辑，不易理解和维护。&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;read&lt;/code&gt; 读取数据之后进行解码并放入队列中，等待工作线程处理。&lt;/li&gt;
&lt;li&gt;工作线程处理完数据之后，返回到 event-loop 线程，由这个线程负责调用 &lt;code&gt;write&lt;/code&gt; 把数据写回 client。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考这些网络模型，采用golang封装的底层epoll/kqueue系统调用方法，支持tcp协议，实现一个相对简单的网络模型，框架如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/weedge/im/main/go-epoll.png&#34; alt=&#34;go-epoll.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;代码实现：&lt;a href=&#34;https://github.com/weedge/lib/tree/main/poller&#34;&gt;https://github.com/weedge/lib/tree/main/poller&lt;/a&gt;  (对一个开源库进行的改造，codec编解码器待完善)&lt;/p&gt;
&lt;h4 id=&#34;参考&#34;&gt;参考：&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/panjf2000/gnet&#34;&gt;gnet&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/cloudwego/netpoll&#34;&gt;netpoll&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/tidwall/evio&#34;&gt;evio&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/AlexStocks/getty&#34;&gt;getty&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/netty/netty&#34;&gt;netty&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/xinali/articles/issues/57&#34;&gt;Linux网络编程模型&lt;/a&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>教学直播概括</title>
      <link>https://weedge.github.io/post/jxzb/</link>
      <pubDate>Wed, 01 Sep 2021 22:04:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/jxzb/</guid>
      
        <description>&lt;h2 id=&#34;背景&#34;&gt;背景：&lt;/h2&gt;
&lt;p&gt;不同于常规的主播互动直播；教学直播，面向k12人群，&lt;/p&gt;
&lt;p&gt;前期会有课前的准备工作比如课程创建，学生购买数据，老师课件，试卷题目的准备；&lt;/p&gt;
&lt;p&gt;双师模式：学生会分配给不同的辅导老师，辅导老师会对学生进行分班处理，课中也会有学生选组上课互动的场景，辅导老师也可以给学生上课，也会在后台进行跟课，监督学生上课；&lt;/p&gt;
&lt;p&gt;相对于常规的主播互动，会模拟线下上课的场景到线上课中直播，形成一套线上教学直播间场景模式&lt;/p&gt;
&lt;h2 id=&#34;业务发展&#34;&gt;业务发展：&lt;/h2&gt;
&lt;p&gt;课中直播是按章节维度进行直播交互的，一个章节一个直播间；&lt;/p&gt;
&lt;p&gt;随着业务发展，出现了一个章节多个不同直播间的场景（出镜），多个章节共享一个章节直播间的场景(共享直播间）； 一个章节有2个相同课中主讲直播间的场景（旁听）; 后面根据业务需求衍生出其他组合玩法；&lt;/p&gt;
&lt;h2 id=&#34;上课业务流程介绍&#34;&gt;上课业务流程介绍：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;售卖侧建课&lt;/strong&gt;：售卖老师在售卖后台新建课程章节，定义课程章节的属性，形成售卖商品上架；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学生侧购买报名&lt;/strong&gt;：学生在售卖页面可以购买课程章节上课，或者0元课扫二维码直接购买报名上课；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;辅导侧&lt;/strong&gt;： 根据上课用户的年龄段进行分类：低幼，班主任，督学，0转化督学；对报名的用户课前排灌班，以大班/小班/小组的组织形式上课；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;教学直播课前预热：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将当天课前准备的课件，试卷题目，课程章节老师辅导相关的等非状态非易变接口数据在上课之前预热至缓存中；因为课中上课是突发流量场景，减少对后台接口db的并发压力； 对课中不会变的接口数据可以加上本地缓存，提高相应吞吐效率；(读多写少场景接口，cache-aside模式）&lt;/li&gt;
&lt;li&gt;课前对课中异动易变数据需要直播间缓存，业务组织缓存等初始化缓存数据；提供给课中互动场景使用；后面通过业务策略绑定，把业务组织数据抽象一个课中理解的数据模型，直播间缓存， 组织树节点缓存，学生所在直播间节点缓存等初始数据；（基于这个课中缓存数据模型，进行编码，隔离业务属性）&lt;/li&gt;
&lt;li&gt;对于异动状态易变更新频繁的接口直接课中缓存交互，异步落盘，降低相应延迟减少对后台接口的读写压力；（写多频繁场景接口，write-behind模式）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;教学直播课中互动：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不同用户角色直播链路
&lt;ol&gt;
&lt;li&gt;老师端：初始化直播间(配置加载，不同的互动ui, 互动功能是否可用，流媒体appid/token)→ 加载课件(cocos资源) →进入直播间 → 通过流媒体推流拉流/连麦/通过长链接发送聊天消息和信令→互动（发题目/答案/红包/奖励）→ 切换直播间(辅导出镜)/结束直播&lt;/li&gt;
&lt;li&gt;学生端：初始化直播间(配置加载，流媒体appid/token, 流程配置)→加载资源(cocos互动资源包/ai模型资源包)→签到/分组→进入直播间→通过流媒体拉流推流/连麦/通过长链接发送聊天消息→互动（发题目/答案/红包/奖励/pk）→ 退出直播间&lt;/li&gt;
&lt;li&gt;辅导跟课后台：进入跟课后台→ 进入直播间→通过流媒体拉流/通过长链接发送聊天消息→处理报警/遮盖/鉴黄/标记→直播结束获取计算好的学生到课时长，作答率，出勤率，完课率等&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;互动依赖长链接，答题，pk等场景，都有开始到结束的过程，对每个互动场景用互动id来管理生命周期，涉及金额的互动，需要考虑黑产的影响，需要对答案加密，以及金额的提前计算预热和防止多发少发，互动读写接口尽量细化，防止读写io多在同一个接口中；尽量把计算放在用户端来处理， 比如 答题是否成功，pk是否赢了等，分散服务端流量压力；(原则：统一管理互动类型，可配置化，细化io, 计算前置,分流)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;教学直播课后回放：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建课后直接根据绑定的策略直接生成直播间，提供回放数据，比如素养课，伪直播&lt;/li&gt;
&lt;li&gt;课中的回放数据，会有直播间和用户互动最终状态数据落库&lt;/li&gt;
&lt;li&gt;回放数据是不会更改，读多写非常少的场景，缓存直接通过cache-aside的模式缓存db后台接口数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;教学整体概括架构&#34;&gt;教学整体概括架构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/weedge/mypic/master/zyb-jx.png&#34; alt=&#34;jxzb&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;总结思考&#34;&gt;总结思考&lt;/h2&gt;
&lt;p&gt;​	底层的基础建设比较重要(&lt;strong&gt;高效能&lt;/strong&gt;)；上层业务的发展离不开基础组件的稳定性(&lt;strong&gt;高可用&lt;/strong&gt;)；以及服务多了之后，如何高效快速迭代，上线之后保证整体服务性能的稳定性(&lt;strong&gt;高并发/低延迟/可监控/可配置&lt;/strong&gt;)； 以及服务模块之间的划分合理，细化出功能组件，异动业务代码的可维护性（&lt;strong&gt;低耦合高内聚&lt;/strong&gt;）；这些都需要理论知识加以指导(比如服务划分抽象原则DDD, 业务抽象设计原则SOLID)，以及实践场景中去平衡折中改进；没有永恒的银弹(内卷)，尚需不断迭代提高。一个字 &amp;ldquo;稳&amp;rdquo;。&lt;/p&gt;
&lt;h2 id=&#34;references&#34;&gt;references&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.infoq.cn/theme/119&#34;&gt;作业帮云原生探索和实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.infoq.cn/article/9jn0qfcx2xq7h6xltwa9&#34;&gt;学而思网校直播课堂的架构演进之路&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://insights.thoughtworks.cn/tag/domain-driven-design/&#34;&gt;Thoughtworks洞见-领域驱动设计&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tech.meituan.com/2020/03/19/design-pattern-practice-in-marketing.html&#34;&gt;设计模式在美团外卖营销业务中的实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tech.meituan.com/2017/12/22/ddd-in-practice.html&#34;&gt;领域驱动设计在互联网业务开发中的实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://read.douban.com/ebook/169386436/&#34;&gt;架构整洁之道&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sre.google/books/&#34;&gt;google-sre-book&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://2012.33degree.org/pdf/JamesLewisMicroServices.pdf&#34;&gt;JamesLewisMicroServices.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://icyfenix.cn/&#34;&gt;凤凰架构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.infoq.cn/article/6dlQZisMiXK3hzLIwEET&#34;&gt;微服务架构设计中的设计模式、原则及最佳实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/mojOSgEUaHWGU3H3j7WjlQ&#34;&gt;微服务拆分之道&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://book.douban.com/subject/26938710/&#34;&gt;系统架构-复杂系统的产品设计与开发&lt;/a&gt;: 理论知识，多读多思考多实践，&amp;lsquo;&amp;lsquo;虚实&#39;&amp;lsquo;结合&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&amp;amp;mid=2247497722&amp;amp;idx=1&amp;amp;sn=33df39c492c508b2086a704612edf186&#34;&gt;架构指导原则&lt;/a&gt;&lt;/strong&gt;: 值得反复推敲，内化，回顾以往做过的项目，总结出底层原理&lt;/li&gt;
&lt;/ol&gt;</description>
      
    </item>
    
    <item>
      <title>直播系列之消息模块演进</title>
      <link>https://weedge.github.io/post/jxzbim/</link>
      <pubDate>Mon, 02 Nov 2020 10:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/jxzbim/</guid>
      
        <description>&lt;h4 id=&#34;整体服务框架&#34;&gt;整体服务框架&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://github.com/weedge/im/blob/main/zbim.png?raw=true&#34; alt=&#34;zbim&#34;&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>policy worker</title>
      <link>https://weedge.github.io/todo/policyworker/</link>
      <pubDate>Wed, 10 Jun 2020 10:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/todo/policyworker/</guid>
      
        <description>&lt;h4 id=&#34;策略模型&#34;&gt;策略模型&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; (
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sync/atomic&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;time&amp;#34;&lt;/span&gt;
)

&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;loadConfig&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; {
  &lt;span style=&#34;color:#75715e&#34;&gt;// 从数据库或者文件系统中读取配置信息，然后以map的形式存放在内存里
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; make(&lt;span style=&#34;color:#66d9ef&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;)
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;requests&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; {
  &lt;span style=&#34;color:#75715e&#34;&gt;// 将从外界中接受到的请求放入到channel里
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; make(&lt;span style=&#34;color:#66d9ef&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;)
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
  &lt;span style=&#34;color:#75715e&#34;&gt;// config变量用来存放该服务的配置信息
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;config&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;atomic&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Value&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;// 初始化时从别的地方加载配置文件，并存到config变量里
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;config&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Store&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;loadConfig&lt;/span&gt;())
  &lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;() {
    &lt;span style=&#34;color:#75715e&#34;&gt;// 每10秒钟定时的拉取最新的配置信息，并且更新到config变量里
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; {
      &lt;span style=&#34;color:#a6e22e&#34;&gt;time&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Sleep&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;time&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Second&lt;/span&gt;)
      &lt;span style=&#34;color:#75715e&#34;&gt;// 对应于赋值操作 config = loadConfig()
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;config&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Store&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;loadConfig&lt;/span&gt;())
    }
  }()
  &lt;span style=&#34;color:#75715e&#34;&gt;// 创建工作线程，每个工作线程都会根据它所读取到的最新的配置信息来处理请求
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;() {
      &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;requests&lt;/span&gt;() {
        &lt;span style=&#34;color:#75715e&#34;&gt;// 对应于取值操作 c := config
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 由于Load()返回的是一个interface{}类型，所以我们要先强制转换一下
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;config&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Load&lt;/span&gt;().(&lt;span style=&#34;color:#66d9ef&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;)
        &lt;span style=&#34;color:#75715e&#34;&gt;// 这里是根据配置信息处理请求的逻辑...
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;
      }
    }()
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;参考&#34;&gt;参考：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.betacat.io/post/golang-atomic-value-exploration/&#34;&gt;https://blog.betacat.io/post/golang-atomic-value-exploration/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>2019 TODO</title>
      <link>https://weedge.github.io/post/2019todo/</link>
      <pubDate>Sat, 26 Jan 2019 01:16:30 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/2019todo/</guid>
      
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;p&gt; 2018年感觉过的好快，时间荏苒，有些事和人，感觉在2018变化很大；人都是有欲望的，在欲望的驱使下，去实现自己的目标，其中有失败，有成功，还有一直在路上前行的；每年给自己定的目标要么期望太高，要么随遇而安，到头来给自己的感觉是不太务实，有点好高骛远了和缺乏动力；但是如果没有梦想和目标，和咸鱼有什么分别呢？所以把2019年的新年目标任务写下来，给自己立个flag，实施准则：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;低头看书学习做事，抬头思考总结做人~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;书&#34;&gt;书&lt;/h2&gt;
&lt;p&gt;现在大部分时间看书都是利用手机，在上班下班的时间，碎片化阅读；双休日和假期的时候，找一个天上午下午来深度阅读；不过感觉后面给书的时间越来越少了，时间的管理是越发的重要。&lt;/p&gt;
&lt;h3 id=&#34;非技术类&#34;&gt;非技术类&lt;/h3&gt;
&lt;p&gt;读书不分先后顺序， 按一年12个月算，暂时定每个月看完一到两本书，这里大部分心理学和经济学方面的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;a href=&#34;https://book.douban.com/subject/1012611/&#34;&gt;乌合之众&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;a href=&#34;https://book.douban.com/subject/10785583/&#34;&gt;思考，快与慢&lt;/a&gt; (书比较难啃)&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;a href=&#34;https://book.douban.com/subject/10785583/&#34;&gt;原则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;a href=&#34;https://book.douban.com/subject/11445548/&#34;&gt;自私的基因&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;a href=&#34;https://book.douban.com/subject/30259720/&#34;&gt;今日简史&lt;/a&gt; &lt;a href=&#34;https://book.douban.com/subject/26945094/&#34;&gt;未来简史&lt;/a&gt; &lt;a href=&#34;https://book.douban.com/subject/25985021/&#34;&gt;人类简史&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;a href=&#34;https://book.douban.com/subject/30186119/&#34;&gt;硅谷增长黑客实战笔记&lt;/a&gt; (适合ab策略数据分析)&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;a href=&#34;https://book.douban.com/subject/27167992/&#34;&gt;见识&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;a href=&#34;https://book.douban.com/subject/26704143/&#34;&gt;把时间当作朋友&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;a href=&#34;https://book.douban.com/subject/27662713/&#34;&gt;舆论&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;a href=&#34;https://book.douban.com/subject/26412113/&#34;&gt;机器人叛乱&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;a href=&#34;https://book.douban.com/subject/6811366/&#34;&gt;禅与摩托车维修艺术&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;技术类&#34;&gt;技术类&lt;/h3&gt;
&lt;p&gt;技术类的主要是最近工作可能会用到的，作为参考书籍，具体还需要到工作中实践转化成自己，就如一本武功秘籍，还需要日积月累的修炼，大侠不是一招一式就能混迹江湖的；技术迭代越来越快，学习是一个长期的过期，新技术层出不穷(新技术的学习离不开开源社区github，代码是最好的文档)，但是计算机基础的东西是不变的，技术的迭代都是在原有的基础技术上发展，所以修炼内功心法还是很重要的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;a href=&#34;https://book.douban.com/subject/26337939/&#34;&gt;七周七并发模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;a href=&#34;https://book.douban.com/subject/26586598/&#34;&gt;性能之巅&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;a href=&#34;https://book.douban.com/subject/26586598/&#34;&gt;Linux高性能服务器编程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;a href=&#34;https://book.douban.com/subject/10590856/&#34;&gt;统计学习方法&lt;/a&gt; &lt;a href=&#34;https://book.douban.com/subject/26708119/&#34;&gt;机器学习&lt;/a&gt; &lt;a href=&#34;https://book.douban.com/subject/27087503/&#34;&gt;深度学习&lt;/a&gt; (这个学起来有些枯燥，需要网上找点代码case来结合实际应用场景)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他语言类的，网络编程类的，数据库操作优化类的数据都可以在越到问题的时候，通过技术专有的关键字可以google/百度一下, 去解决实际越到问题，要比直接看书要印象深刻的多，知其然而知所以然。&lt;/p&gt;
&lt;h2 id=&#34;事&#34;&gt;事&lt;/h2&gt;
&lt;p&gt;2018的事还是比较简单的。&lt;/p&gt;
&lt;p&gt;工作上大部分时间是解决业务需求，偶尔也会写出一些bug, 做事缺乏全面的考虑，有些事情不是自己愿意去做的，有时候缺乏积极性；作为一个在职场混迹六年的人来说，范这些错误，难免会有点尴尬，所以在后面的职场工作中，不管是喜欢和重复厌倦的事情，都要认真负责的去对待，工作是给公司解决问题，不能带着情绪化处理；还有工作上需要协调把控好效率和产出质量。&lt;/p&gt;
&lt;p&gt;感情上通过相亲认识了投缘的另一半，虽然两人外形上可能有些不搭调~，但是最后异地恋走在一起挺不容易的；年底总数把买房子的事情给结尾，装修的事情两人商量着慢慢来，彼此相信会有一个温馨的家🏠&lt;/p&gt;
&lt;p&gt;2019的规划：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主要是自己工作上有突破，不管是技能还是处理事情&lt;/li&gt;
&lt;li&gt;帮助她找到一份还算满意的工作&lt;/li&gt;
&lt;li&gt;弄完房子准备结婚🎎&lt;/li&gt;
&lt;li&gt;接父母过来玩&lt;/li&gt;
&lt;li&gt;用golang 重构一下小机器人&lt;/li&gt;
&lt;li&gt;完成网关weegate&lt;/li&gt;
&lt;li&gt;more&amp;hellip;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;思&#34;&gt;思&lt;/h2&gt;
&lt;p&gt;年复一年，岁月催人老，30+的程序猿看着00后都已经开始上大学，开始进入社会实习了，突然危机感油然而生，是否就一定会被社会淘汰呢，是否就到了35+岁, 就不能编程了呢，给公司创造的价值就打折了呢？也许这些问题和社会上的鸭梨一直会存在，并激励着资历老猿们去反思，去复盘总结；经验是有的，斗志在，就怕不学习，俗话说的好：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;活到老，学到老，干到老！（为即将或者已成老猿 代言，笔芯~）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;最后&#34;&gt;最后&lt;/h2&gt;
&lt;p&gt;借用我最喜欢的乔布斯语录，作为本文的结尾（虽然有点鸡血的感觉）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;人这一辈子没法做太多的事情，所以每一件都要做得精彩绝伦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;你的时间有限，所以不要为别人而活。不要被教条所限，不要活在别人的观念里。不要让别人的意见左右自己内心的声音。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;最重要的是，勇敢的去追随自己的心灵和直觉，只有自己的心灵和直觉才知道你自己的真实想法，其他一切都是次要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;链接&#34;&gt;链接&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;amp;mid=2651011968&amp;amp;idx=1&amp;amp;sn=3d500660f7dd47c9fa4033bd9fa69c2f&#34;&gt;解读2018：我们处在一个什么样的技术浪潮当中？&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/22937279&#34;&gt;程序员工作只能做到 35 岁吗？&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzI2MDI5NDQwMg==&amp;amp;mid=2247483959&amp;amp;idx=1&amp;amp;sn=bcb5fb9eb2aca5810d87ad3b63c4612b&amp;amp;chksm=ea6a905add1d194c57468ac88b611b9005290d1d922154a7b6fe9fec3fdd710c27de41282608&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0327cbNpv&#34;&gt;35岁以后的大龄程序员，正处于怎样一种状态?&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>屏蔽macbook内置键盘</title>
      <link>https://weedge.github.io/post/mackeyboard-hhkb/</link>
      <pubDate>Sat, 19 Jan 2019 10:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/mackeyboard-hhkb/</guid>
      
        <description>&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;  昨天晚上和女友争吵，不小心把水洒在macbook的键盘上了，当时没有及时关机烘干，直接就把本给关上了，导致今天早上起来发现键盘按z左边的shift键失灵，有时候一直重复z键，过了一段时间z键失灵，还有其他几个键也失灵了，网上搜了一下，有可能是排线的原因，找官网修理一下, 估计也得300到1000不等；想想这些维修费用都可以买个键盘了。&lt;/p&gt;
&lt;p&gt;  生日的时候女友给我买了一个有线静容无刻版的hhkb（答应用这个努力赚钱的），当时用了一段时间，无刻版的数字键不是很好按，后面觉得上班每天背着它有点沉，就搁浅了；现在好了，内置键盘已坏，以后就靠这个键盘了，一直用也不换了;&lt;/p&gt;
&lt;p&gt;但是有个问题，把键盘放在macbook的内置键盘上有可能会触发上面的按键， 需要禁用掉内置键盘；网上找了一个挺好用的软件&lt;a href=&#34;https://pqrs.org/osx/karabiner/&#34;&gt;Karabiner&lt;/a&gt;，也可以设置物理键映射，具体操作帮助文档可以见&lt;a href=&#34;https://pqrs.org/osx/karabiner/document.html&#34;&gt;官网文档&lt;/a&gt;；下载安装后，设置如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/weedge/weedge.github.io/master/image/kar.png&#34; alt=&#34;karabiner&#34;&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>abtest</title>
      <link>https://weedge.github.io/todo/abtest/</link>
      <pubDate>Sat, 23 Dec 2017 10:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/todo/abtest/</guid>
      
        <description></description>
      
    </item>
    
    <item>
      <title>id生成</title>
      <link>https://weedge.github.io/post/idgen/</link>
      <pubDate>Tue, 12 Dec 2017 10:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/idgen/</guid>
      
        <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;  用户业务数据增长过快，比如文章评论系统，feed流系统，订单系统；数据的存放模型需要从主从的单机单库 演变成 分布式集群数据库； 分库分表的数据查询需用到全局唯一标识的id来查询业务，比如莫个feed的评论数据、推送消息、购物订单、活动优惠劵等等都需要进行唯一ID标识；以便分布式存储(mysql,nosql,newsql)索引(b+tree, LSMtree,inverted index)快速查询；至于数据一致性通过约定规范协议保证(强：类Paxos算法/raft算法，弱: mq) 。&lt;/p&gt;
&lt;h2 id=&#34;特征&#34;&gt;特征&lt;/h2&gt;
&lt;p&gt;根据不同的需求场景进行总体归纳全局id生成服务的特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局唯一：最基本要求，不能出现重复的id；&lt;/li&gt;
&lt;li&gt;趋势递增：业务中如果大量使用mysql innodb来存放数据，而innodb使用聚集索引(cluster index)，使用b+tree来存放索引数据，所以在主键的选择存放上应该尽量使用整数型有序的主键，来保证数据的写入性能(顺序io)&lt;/li&gt;
&lt;li&gt;单调递增：IM增量消息，排序序列号&lt;/li&gt;
&lt;li&gt;可解码：比如统计分析id的生成情况，尽量是服务分布均匀，需要查看业务id(appID),生成时间(time ms), 以及id服务节点号(nodeID)&lt;/li&gt;
&lt;li&gt;信息安全：生成id的规律不能过于简单，比如单调递增，信息详情展示页会有规律的爬取，这样直接可以估算出一些指标数据(天订单量，天feed产生流量等)；所以需要id无规律生成(可以内部获取有规律的id后，进行加盐编码处理)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些特征有些是互斥的，不能同时满足，需要根据业务场景具体分析(可能有些场景特征还未考虑到，后续加入），选择对应特征方案来满足。&lt;/p&gt;
&lt;p&gt;id生成服务的评价指标：（由于在分布式系统中，id生成服务依赖度非常高，需要高可用和高性能）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;平均响应时间和所有请求中的千分之999的最低相应时间(TP999)尽可能的低；&lt;/li&gt;
&lt;li&gt;SLA(可用性)5个9(全年低于5分钟的不可用时间)&lt;/li&gt;
&lt;li&gt;QPS(每秒请求量)尽可能的高&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;方案&#34;&gt;方案&lt;/h2&gt;
&lt;h3 id=&#34;uuid&#34;&gt;uuid&lt;/h3&gt;
&lt;p&gt;标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的36个字符，无序，不适合用来做为数据库(B+Tree)中的主键。&lt;/p&gt;
&lt;h3 id=&#34;snowflake&#34;&gt;snowflake&lt;/h3&gt;
&lt;p&gt;twitter中的feed数据从mysql迁移至Cassandra中存放，cassandra没有顺序id生成机制，提出的一种解决方案；不依赖其他组件服务，直接程序算法实现；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;41位的时间序列（精确到毫秒，41位的长度可以使用69年）&lt;/li&gt;
&lt;li&gt;10位的机器标识（10位的长度最多支持部署1024个节点），根据业务服务类型和部署还可进行细分，比如idc,机器,业务id(appid)&lt;/li&gt;
&lt;li&gt;12位的计数顺序号（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号）&lt;/li&gt;
&lt;li&gt;最高位是符号位，始终为0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/weedge/weedge.github.io/master/image/snowflake-64bit.jpg&#34; alt=&#34;snowflake&#34;&gt;&lt;/p&gt;
&lt;p&gt;64位bigint类型ID, 最大2^63-1  19位10进制数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缺点: 多机部署时，必须保证时间是同步的，否则如果存在时间回溯，出现重复id。&lt;/li&gt;
&lt;li&gt;解决方案：可以加上多台机器时间同步检测恢复机制&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E6%99%82%E9%96%93%E5%8D%94%E5%AE%9A&#34;&gt;NTP网络时间协议&lt;/a&gt;，可以尽量避免&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;redis生成id&#34;&gt;redis生成id:&lt;/h3&gt;
&lt;p&gt;利用redis的单线程机制，以及原子递增操作INCR和INCRBY来实现；多台部署：采用按起始值分N台机器数间隔递增(等差数列)，格式：时间戳+单日增长号；(单点故障，由于等差值N机器数是事先定义好的，水平扩容不方便，不便于运维)&lt;/p&gt;
&lt;h3 id=&#34;mysql生成id64位&#34;&gt;mysql生成id(64位):&lt;/h3&gt;
&lt;p&gt;利用mysql的auto_increment自助机制 + replace into table操作(table定义两个字段，一个是64位的主键自增字段，一个是属性唯一字段) +InnoDB/MyISAM引擎 来实现，多台主从部署：采用按起始值分N台机器数间隔递增(等差数列)，需要设置mysql自增参数：set auto_increment_increment=N.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存在问题：&lt;br&gt;
主跪了，切从，主从数据同步存在延时的话，id会出现重复的情况，以及每次生成id，都要访问一次数据库replace操作，性能会降低很多；&lt;/li&gt;
&lt;li&gt;解决方案：&lt;br&gt;
通过“号段”segment批量获取的方式，从mysql中获取ID,然后扩大倍数M,设定范围[ID*M,(ID+1)*M]，然后从内存中的这个范围里生成一个自增序列号，如果到了范围的最大值，则阻塞其他请求，由最早的线程去db获取id，设定范围，或者在号码到达最大范围的10~75%的时候提前去db获取id，这样就不会阻塞的情况；然后继续以述过程。这个方案有个小缺陷就是服务重启，以往内存中的id范围段就会浪费掉，但是64位还是挺多的，性能提高了，浪费点也就无所谓啦~ 当然如果你是处女座，最求极致可以旁路监控记录已经分配出去的id，启动的时候在捞回来放入内存中继续分配生成id）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个方案比较常用，稳定，依赖mysql，需要与dba配合操作,和redis生成id一样不便于水平扩展，运维维护，改进方案类似于美团的Leaf-segment设计，采用元数据(tag,max_id,step,desc,create_time,update_time)管理，对业务tag进行分库扩容，减低运维维护成本&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;性能上当然snowflake性能最好，全局唯一，趋势递增，可解码，不依赖其他组件，唯一缺陷是时间不同步的问题，如果回退的时间比较大，服务可能就跪了，解决方案：服务启动时就进行校验时间是否与启动的服务节点一致，依赖于zk或者etcd来记录监控各个genId service服务节点的时间信息，验证相同则ok，否则启动失败，报警。应用场景feed流&lt;/li&gt;
&lt;li&gt;稳定上mysql生成id方案比较好，全局唯一，单个mysql实例可以保证单调递增，扩容多实例变成趋势递增(proxy wrr负载均衡w=1)，性能和主从同步延迟导致id重复问题，这些问题可以通过内存中的ID范围段segment来计算生成自增序列id解决。应用场景订单号，消息id&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考阅读&#34;&gt;参考阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/F7WTNeC3OUr76sZARtqRjw&#34;&gt;分布式架构系统生成全局唯一序列号的一个思路&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tech.meituan.com/MT_Leaf.html&#34;&gt;美团点评id生成器系统-Leaf&lt;/a&gt;  (HA，性能，便于扩容,通过管理元数据(tag,max_id,step,desc,create_time,update_time)，对业务tag进行分库扩容；通过zk来同步每个启动的Leaf节点时间，新的服务启动是通过时间校验机制来规避时间戳不同步，回拨问题上的监控)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yuerblog.cc/2017/11/21/golang-id-alloc/&#34;&gt;golang分布式id生成服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://thesecretlivesofdata.com/raft/&#34;&gt;raft&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>消息队列</title>
      <link>https://weedge.github.io/todo/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link>
      <pubDate>Sun, 12 Nov 2017 10:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/todo/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</guid>
      
        <description>&lt;h2 id=&#34;消息队列介绍what&#34;&gt;消息队列介绍what&lt;/h2&gt;
&lt;h3 id=&#34;协议&#34;&gt;协议：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;MQTT&lt;/strong&gt;(Message Queuing Telemetry Transport，消息队列遥测传输，基于二进制消息的发布/订阅编程模式的消息协议):&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://docs.emqtt.cn/zh_CN/latest/mqtt.html&#34;&gt;http://docs.emqtt.cn/zh_CN/latest/mqtt.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/20888181&#34;&gt;https://zhuanlan.zhihu.com/p/20888181&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单的协议:&lt;a href=&#34;http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html&#34;&gt;http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于规范协议很简单，非常适合需要低功耗和网络带宽有限的IoT场景。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;AMQP&lt;/strong&gt;(Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开发标准，为面向消息的中间件设计)：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;XMPP&lt;/strong&gt;(可扩展消息处理现场协议，Extensible Messaging and Presence Protocol）是基于可扩展标记语言的协议，多用于即时消息)：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;消息队列原理why&#34;&gt;&lt;strong&gt;消息&lt;/strong&gt;队列原理why&lt;/h2&gt;
&lt;h2 id=&#34;消息队列使用场景where&#34;&gt;消息队列使用场景where&lt;/h2&gt;
&lt;h2 id=&#34;如何设计消息队列how&#34;&gt;如何设计消息队列how&lt;/h2&gt;
&lt;h2 id=&#34;开源消息队列&#34;&gt;开源消息队列&lt;/h2&gt;
&lt;h3 id=&#34;kafka&#34;&gt;kafka&lt;/h3&gt;
&lt;h3 id=&#34;nsq&#34;&gt;NSQ&lt;/h3&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
</description>
      
    </item>
    
    <item>
      <title>golang学习笔记</title>
      <link>https://weedge.github.io/post/golang/</link>
      <pubDate>Wed, 01 Nov 2017 01:16:30 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/golang/</guid>
      
        <description>&lt;p&gt;刚开始接触golang的时候是在大学时候，当时大概是2010年左右，对这门新语言比较好奇，但是没有深入去了解，只是道听途说这门语言在并发处理上很方便，对于协程这个东西也是第一次听说。自从工作之后，就一直没有接触过这门语言,最近公司想往golang上转，开发新的项目平台，毕竟golang运行效率和开发效率都要比其他语言要简单方便很多(听说c++都快20了)。&lt;/p&gt;
&lt;p&gt;吉祥物：（憨厚小地鼠 move~move~move~ Bui~~~~    go~go~go~ ）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/weedge/weedge.github.io/master/image/go-mascot.png&#34; alt=&#34;地鼠&#34;&gt;&lt;/p&gt;
&lt;p&gt;（萌萌の勤劳小地鼠~）并发协作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/weedge/weedge.github.io/master/image/go-concurrence.png&#34; alt=&#34;并发协作&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;语言&#34;&gt;语言&lt;/h2&gt;
&lt;p&gt;看七周七语言中提到的，语言各有特色，用于不同的开发场景，对应团队的工具栈；经常用自己熟悉的编程语言，思维模式也会有所不同；总的来说，支持KISS原则，方便高效开发/测试/部署/运行，并发运行解决问题，流出更多时间关注业务或者&lt;code&gt;kick ass &amp;amp;&amp;amp; Chew bubblegum (just a joke~)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;发展历史&#34;&gt;发展历史：&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;发明这个语言的初衷，「不忘初心，方得始终」&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;为毛需要这个语言：https://www.oschina.net/translate/go-at-google-language-design-in-the-service-of-software-engineering&lt;/li&gt;
&lt;li&gt;初心：简单,开发简洁，方便快速开发编译发布(开发语言的作者来自c和java, 作者Rob Pike实现并发思想,布道者，他相关的视频和文章需要多看，精髓哦，This guy is a genius~ )&lt;/li&gt;
&lt;li&gt;源码：https://github.com/golang/go&lt;/li&gt;
&lt;li&gt;特殊节点：2008 6.6 ~1.5版本去除了c代码实现自举(1.5+直接用go来编译安装即可)， now 10年+ golang2.0 版  &lt;a href=&#34;https://github.com/golang/go/wiki/Go2&#34;&gt;https://github.com/golang/go/wiki/Go2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Hello,Gopher（golang作者之一Rob Pike 讲的golang发展史，及众家语言之所长，发明这个语言的初衷）:https://www.youtube.com/watch?v=VoS7DsT1rdM&amp;amp;list=PL3NQHgGj2vtsJkK6ZyTzogNUTqe4nFSWd &lt;a href=&#34;https://talks.golang.org/2014/hellogophers.slide##12&#34;&gt;slide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Go Concurrency Patterns(一些并发模式case, goroutine通过channel组合传递共享数据, no race like DAG): &lt;a href=&#34;https://www.youtube.com/watch?v=f6kdp27TYZs&amp;amp;list=PL3NQHgGj2vtsJkK6ZyTzogNUTqe4nFSWd&#34;&gt;https://www.youtube.com/watch?v=f6kdp27TYZs&amp;amp;list=PL3NQHgGj2vtsJkK6ZyTzogNUTqe4nFSWd&lt;/a&gt;  &lt;a href=&#34;https://talks.golang.org/2012/concurrency.slide&#34;&gt;slide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Concurrency Is Not Parallelism: &lt;a href=&#34;https://blog.golang.org/concurrency-is-not-parallelism&#34;&gt;https://blog.golang.org/concurrency-is-not-parallelism&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Simplicity is Complicated: &lt;a href=&#34;https://www.youtube.com/watch?v=rFejpH_tAHM&amp;amp;list=PL3NQHgGj2vtsJkK6ZyTzogNUTqe4nFSWd&#34;&gt;https://www.youtube.com/watch?v=rFejpH_tAHM&amp;amp;list=PL3NQHgGj2vtsJkK6ZyTzogNUTqe4nFSWd&lt;/a&gt; &lt;a href=&#34;https://talks.golang.org/2015/simplicity-is-complicated.slide#1&#34;&gt;slide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The Design of the Go Assembler：https://www.youtube.com/watch?v=KINIAgRpkDA&amp;amp;list=PL3NQHgGj2vtsJkK6ZyTzogNUTqe4nFSWd &lt;a href=&#34;https://talks.golang.org/2016/asm.slide#1&#34;&gt;slide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;特征&#34;&gt;特征：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;KISS；简单朴实 （做工程的人最喜欢的就是简单实用的东西）；&lt;/li&gt;
&lt;li&gt;运行占用资源低(可运行在嵌入式平台linux arm)，跨平台&lt;/li&gt;
&lt;li&gt;((内存)数据结构+算法+抽象定义接口)；&lt;/li&gt;
&lt;li&gt;语法简单，25个关键字；&lt;/li&gt;
&lt;li&gt;c语言结构体形式模拟继承方法重写机制；&lt;/li&gt;
&lt;li&gt;基础数据结构类型：byte,string, array; slice, map,chanel 引用类型；(其他数据结构heap(优先队列),list,ring(circular list)这些在官方提供的公共库中)&lt;/li&gt;
&lt;li&gt;强类型语言，interface{} 表示通用类型(相当于stl中的模板)；&lt;/li&gt;
&lt;li&gt;异常处理: defer, panic, recover 抛出一个panic的异常（异常指的是意料之外的情况，比如引用了空指针，下标越界，除数为0，不应该出现的分支，比如default），然后在defer中通过recover捕获这个异常，最后正常处理；注意如果没有recover去捕获异常，程序就会退出；&lt;/li&gt;
&lt;li&gt;错误机制: error，错误指的是意料之中的情况，比如文件可能会打开失败，网络连接可能断开导致连接失败等等，错误是业务过程的一部分，而异常不是 (业务需定义常见的错误码标识对应错误信息)&lt;/li&gt;
&lt;li&gt;变量对象内存分配通过tcmalloc来申请一块span, 分成多个page提供使用，充分利用内存空间，通过gc回收runtime对象(随着版本迭代，对gc的效率逐渐提高，有专门的runtime团队支持)&lt;/li&gt;
&lt;li&gt;并发程序通过channel共享内存(share memory by communicating)；&lt;/li&gt;
&lt;li&gt;适合web后端开发(官方golang.org已提供的基础库 &lt;a href=&#34;https://golang.org/pkg/&#34;&gt;https://golang.org/pkg/&lt;/a&gt; ，net/http(请求，响应，client，server), http/template, 数据库客户端驱动接口定义database/sql(三方根据接口标准可以自定义实现，也可以自己单独定义一套标准实现)，数据加密crypto）；&lt;/li&gt;
&lt;li&gt;通过goroutine(协程，用户级别轻量级线程)支持并发， 协程通过channel通信( &amp;lt;-chan interface{} 接收chan；chan&amp;lt;-interface{} 发送chan；同步通过sync机制(lock(锁接口) mutex(某个goroutine加互斥锁) rwlock(对读写操作加锁) WaitGroup(pv操作,对goroutine组) ，Cond(条件变量，信号量))；&lt;/li&gt;
&lt;li&gt;Golang实现了 CSP(Communicating Sequential Process &lt;a href=&#34;http://www.usingcsp.com/cspbook.pdf&#34;&gt;http://www.usingcsp.com/cspbook.pdf&lt;/a&gt; )并发模型做为并发基础，底层使用goroutine做为并发实体，goroutine非常轻量级可以创建几十万个实体；实体间通过 channel 继续匿名消息传递使之解耦，在语言层面实现了自动调度，这样屏蔽了很多内部细节，对外提供简单的语法关键字(go,select,channel)，大大简化了并发编程的思维转换和管理线程的复杂性；&lt;/li&gt;
&lt;li&gt;SO OPEN，import 三方库源(大部分git的方式来自github/gitlib，还支持hg)，源码直接可以修改编译(取之于源用之源)；&lt;/li&gt;
&lt;li&gt;Go 命令工具方便开发自测调试： &lt;a href=&#34;https://golang.org/cmd/go/&#34;&gt;https://golang.org/cmd/go/&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;通过go test来单元测试，覆盖测试，性能测试(cpu,pprof)，直接可以测试用例先行，&lt;/li&gt;
&lt;li&gt;go tool,  pprof (进行性能分析 &lt;a href=&#34;http://cizixs.com/2017/09/11/profiling-golang-program&#34;&gt;http://cizixs.com/2017/09/11/profiling-golang-program&lt;/a&gt; ）objdump(dump出汇编代码）&lt;/li&gt;
&lt;li&gt;go get -u ~=  download to go build and install , go run 单独运行&lt;/li&gt;
&lt;li&gt;go fmt 代码格式化，统一编码风格，方便协同编程&lt;/li&gt;
&lt;li&gt;go mod: &lt;a href=&#34;https://github.com/golang/go/wiki/Modules&#34;&gt;https://github.com/golang/go/wiki/Modules&lt;/a&gt; 1.11新引入的功能，方便package依赖管理，类似nodejs中的npm&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Go 2.0正待发布，10年+发展，会有一些优化和新特性  &lt;a href=&#34;https://www.youtube.com/watch?v=RIvL2ONhFBI&#34;&gt;https://www.youtube.com/watch?v=RIvL2ONhFBI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;More…..&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;工作上使用语言进化&#34;&gt;工作上使用语言进化&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/weedge/weedge.github.io/master/image/coder.jpg&#34; alt=&#34;coder&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;C/C++ -&amp;gt; *.so -&amp;gt; php/python  |   java -&amp;gt; *.jar  ==&amp;raquo;  go -&amp;gt; *.a -import-&amp;gt; pkg -compile-&amp;gt;  binary program&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;编写运行：复杂  -&amp;gt;  简单&lt;/p&gt;
&lt;p&gt;Go 相当于兼顾了c的执行效率，python的开发效率，择中方案，适合服务端开发(业务开发，基础组件开发(网关，db，AI)，自动化运维工具开发devops);
如果用go来调用.so动态链接库，需要用cgo机制&lt;/p&gt;
&lt;p&gt;语法对比参考：http://hyperpolyglot.org/c&lt;/p&gt;
&lt;h2 id=&#34;学习&#34;&gt;学习&lt;/h2&gt;
&lt;ol start=&#34;0&#34;&gt;
&lt;li&gt;开始入门：https://golang.org/doc/code.html&lt;/li&gt;
&lt;li&gt;golang的基本语法知识，可以通过gotour来进行简单的学习入门，godoc查看具体基础文档和get到本地的三方库接口文档，
Gotour简单入门 ——&amp;gt; &lt;a href=&#34;https://github.com/qyuhen/book/blob/master/Go%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%9B%9B%E7%89%88.pdf&#34;&gt;语法快速入门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;练习习题：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://goquiz.github.io/&#34;&gt;Go语言经典笔试题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gobyexample.com&#34;&gt;Go实例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;最佳实践：(这个会根据实践场景逐渐完善，最终可能会形成一个标准规范)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://talks.golang.org/2013/bestpractices.slide&#34;&gt;12条最佳实践&lt;/a&gt; &lt;a href=&#34;http://maiyang.me/2017/10/21/twelve-best-practices-in-golang/&#34;&gt;中文解释&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;面向对象设计SOLID：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.gokit.info/post/go-solid-design/&#34;&gt;SOLID&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;业务常用依赖阶级开发：(掌握一些三方库，方便快速集成开发)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Web开发框架：
&lt;ul&gt;
&lt;li&gt;beego &lt;a href=&#34;https://github.com/astaxie/beego&#34;&gt;https://github.com/astaxie/beego&lt;/a&gt;  支持mvc, orm; 适用于cms，mis管理后台开始开发 （重量点，开发框架已经搭好，基础web开发组件已有，RBAC规范后台权限）
&lt;ul&gt;
&lt;li&gt;gin &lt;a href=&#34;https://github.com/gin-gonic/gin&#34;&gt;https://github.com/gin-gonic/gin&lt;/a&gt; 利用httprouter实现高性能路由 (轻量点，适合diy)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据库 （client driver）
&lt;ul&gt;
&lt;li&gt;msyql: &lt;a href=&#34;https://github.com/go-sql-driver/mysql&#34;&gt;https://github.com/go-sql-driver/mysql&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;Redis: &lt;a href=&#34;https://github.com/garyburd/redigo&#34;&gt;https://github.com/garyburd/redigo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Mongo: &lt;a href=&#34;https://github.com/go-mgo/mgo&#34;&gt;https://github.com/go-mgo/mgo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ZK client: &lt;a href=&#34;https://github.com/samuel/go-zookeeper/zk&#34;&gt;https://github.com/samuel/go-zookeeper/zk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Grpc: &lt;a href=&#34;https://github.com/grpc/grpc-go&#34;&gt;https://github.com/grpc/grpc-go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Log: &lt;a href=&#34;https://github.com/sirupsen/logrus&#34;&gt;https://github.com/sirupsen/logrus&lt;/a&gt; (以hook机制添加自定的日志，lograte:https://github.com/sirupsen/logrus##rotation，或者https://github.com/natefinch/lumberjack)&lt;/li&gt;
&lt;li&gt;队列: &lt;a href=&#34;https://github.com/nsqio/nsq&#34;&gt;https://github.com/nsqio/nsq&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;订阅资源blog:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.golang.org&#34;&gt;https://blog.golang.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.goinggo.net&#34;&gt;https://www.goinggo.net&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gocn.io/&#34;&gt;https://gocn.io/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;实践踩的坑：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/29545675&#34;&gt;https://zhuanlan.zhihu.com/p/29545675&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/31395716&#34;&gt;https://zhuanlan.zhihu.com/p/31395716&lt;/a&gt; (channel,引发的死锁）&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;应用场景：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/26777189&#34;&gt;新闻实时推送&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;More:  DIY （u can do it）&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;好的开源项目：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hackstoic/golang-open-source-projects&#34;&gt;golang-open-source-projects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/avelino/awesome-go&#34;&gt;awesome-go&lt;/a&gt; (full-stack dev for venture company )&lt;/li&gt;
&lt;li&gt;Web server服务：
&lt;ul&gt;
&lt;li&gt;Caddy：类似nginx,apache,middleware chain(责任链模式) 管理方式，独立的mw也可拆分单独运行，比如负载均衡模块，反向代理，fastcgi代理 &lt;a href=&#34;https://github.com/mholt/caddy&#34;&gt;https://github.com/mholt/caddy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;网关：
&lt;ul&gt;
&lt;li&gt;krakend: &lt;a href=&#34;https://github.com/devopsfaith/krakend&#34;&gt;https://github.com/devopsfaith/krakend&lt;/a&gt;  （高性能，相比kong&amp;hellip;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;微服务：
&lt;ul&gt;
&lt;li&gt;go-micro (&lt;a href=&#34;https://github.com/micro/go-micro&#34;&gt;https://github.com/micro/go-micro&lt;/a&gt;  +  plugins: &lt;a href=&#34;https://github.com/micro/go-plugins&#34;&gt;https://github.com/micro/go-plugins&lt;/a&gt;  )
&lt;ul&gt;
&lt;li&gt;Go-kit (&lt;a href=&#34;https://github.com/go-kit/kit&#34;&gt;https://github.com/go-kit/kit&lt;/a&gt;  very nice micro-service lib framework) diy 借鉴 相关介绍：https://www.youtube.com/watch?v=NX0sHF8ZZgw&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务发现：
&lt;ul&gt;
&lt;li&gt;etcd: &lt;a href=&#34;https://github.com/coreos/etcd&#34;&gt;https://github.com/coreos/etcd&lt;/a&gt; (功能介绍: &lt;a href=&#34;http://www.infoq.com/cn/articles/etcd-interpretation-application-scenario-implement-principle&#34;&gt;http://www.infoq.com/cn/articles/etcd-interpretation-application-scenario-implement-principle&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Consul: &lt;a href=&#34;https://github.com/hashicorp/consul&#34;&gt;https://github.com/hashicorp/consul&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Rpc：
&lt;ul&gt;
&lt;li&gt;grpc: &lt;a href=&#34;https://github.com/grpc/grpc-go&#34;&gt;https://github.com/grpc/grpc-go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;thrift: &lt;a href=&#34;https://github.com/apache/thrift/tree/master/lib/go&#34;&gt;https://github.com/apache/thrift/tree/master/lib/go&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Web开发框架：
&lt;ul&gt;
&lt;li&gt;beego(支持mvc模式开发,https://github.com/astaxie/beego)，&lt;/li&gt;
&lt;li&gt;gin(高性能路由请求处理,https://github.com/gin-gonic/gin )&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据库服务：
&lt;ul&gt;
&lt;li&gt;Tidb (NewSQL 数据库，水平扩展，强一致，分布式事务，多种数据引擎选择，mysql协议通信 &lt;a href=&#34;https://github.com/pingcap/tidb&#34;&gt;https://github.com/pingcap/tidb&lt;/a&gt; 国内公司用的比较多）&lt;/li&gt;
&lt;li&gt;Cockroachdb  (NewSQL 数据库，有百度的同学提交维护 &lt;a href=&#34;https://github.com/cockroachdb/cockroach&#34;&gt;https://github.com/cockroachdb/cockroach&lt;/a&gt; ）&lt;/li&gt;
&lt;li&gt;Influxdb (时序数据库，应用于监控日志数据存储，提供实时数据展现，https://github.com/influxdata/influxdb）&lt;/li&gt;
&lt;li&gt;Bboltdb (本地嵌入式数据库 , LMDB的go实现版本,https://github.com/coreos/bbolt)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;推送：
&lt;ul&gt;
&lt;li&gt;Gorush: &lt;a href=&#34;https://github.com/appleboy/gorush&#34;&gt;https://github.com/appleboy/gorush&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;爬虫：
&lt;ul&gt;
&lt;li&gt;Gocolly: &lt;a href=&#34;https://github.com/gocolly/colly&#34;&gt;https://github.com/gocolly/colly&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Gocrawl: &lt;a href=&#34;https://github.com/PuerkitoBio/gocrawl&#34;&gt;https://github.com/PuerkitoBio/gocrawl&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文件：
&lt;ul&gt;
&lt;li&gt;Upspin: &lt;a href=&#34;https://github.com/upspin/upspin&#34;&gt;https://github.com/upspin/upspin&lt;/a&gt; (Rob Pike 主导的一个实验项目，https://www.youtube.com/watch?v=ENLWEfi0Tkg)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;链路跟踪：
&lt;ul&gt;
&lt;li&gt;Opentracing: &lt;a href=&#34;https://github.com/opentracing/opentracing-go&#34;&gt;https://github.com/opentracing/opentracing-go&lt;/a&gt;  结合zipkin&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实时消息队列平台：
&lt;ul&gt;
&lt;li&gt;NSQ: &lt;a href=&#34;https://github.com/nsqio/nsq&#34;&gt;https://github.com/nsqio/nsq&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;监控:
&lt;ul&gt;
&lt;li&gt;grafana：https://github.com/grafana/grafana&lt;/li&gt;
&lt;li&gt;prometheus: &lt;a href=&#34;https://github.com/prometheus/prometheus&#34;&gt;https://github.com/prometheus/prometheus&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;容器管理：
&lt;ul&gt;
&lt;li&gt;Kubernetes(K8S): &lt;a href=&#34;https://github.com/kubernetes/kubernetes&#34;&gt;https://github.com/kubernetes/kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Kubernetes Handbook: &lt;a href=&#34;https://jimmysong.io/kubernetes-handbook/&#34;&gt;https://jimmysong.io/kubernetes-handbook/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码仓库服务：
&lt;ul&gt;
&lt;li&gt;gogs (轻量级的代码工具，可以运行在pi上, 界面和github相似, &lt;a href=&#34;https://github.com/gogits/gogs&#34;&gt;https://github.com/gogits/gogs&lt;/a&gt; ）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CI/CD(Continuous Delivery):
&lt;ul&gt;
&lt;li&gt;Drone: &lt;a href=&#34;https://github.com/drone/drone&#34;&gt;https://github.com/drone/drone&lt;/a&gt; （可配套自研上线运维平台）&lt;/li&gt;
&lt;li&gt;jenkins-x: &lt;a href=&#34;https://github.com/jenkins-x/jx&#34;&gt;https://github.com/jenkins-x/jx&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;工具：
&lt;ul&gt;
&lt;li&gt;Gotty: &lt;a href=&#34;https://github.com/yudai/gotty&#34;&gt;https://github.com/yudai/gotty&lt;/a&gt; （webshell)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;静态网页生成器：
&lt;ul&gt;
&lt;li&gt;hugo: &lt;a href=&#34;https://github.com/gohugoio/hugo&#34;&gt;https://github.com/gohugoio/hugo&lt;/a&gt; (可以用来写个人技术博客)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据科学(cheat sheet)： &lt;a href=&#34;https://www.cheatography.com/chewxy/cheat-sheets/data-science-in-go-a/pdf/&#34;&gt;https://www.cheatography.com/chewxy/cheat-sheets/data-science-in-go-a/pdf/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;深入理解&#34;&gt;深入理解&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/weedge/weedge.github.io/master/image/goroutine.jpg&#34; alt=&#34;goroutine实现机制&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;goroutine实现机制：https://www.zhihu.com/question/20862617 （M:内核OS线程；G:goroutine用户态轻量级线程，自己的栈，正在等待的channel等；P: 调度的上下文，是调度协调的处理器，P的数量代表了真正的并发度)
（tips：相对于java中并发库实现是不是要简洁高效些呢，https://golang.org/doc/faq##goroutines  这个解释了golang为什么用协成代替线程）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同步机制：sync lock(锁接口) mutex(某个goroutine加互斥锁) rwlock(对读写操作加锁) WaitGroup(pv操作,对goroutine组) ，Cond(条件变量，信号量) 用法参考：https://deepzz.com/post/golang-sync-package-usage.html  (其实就是OS中的同步机制实现)   锁的话是一个原子操作，要么锁住，要么不做，通过atomic操作底层的cpu指令(CHANGE*, SWAP* &amp;hellip;.etc指令根据不同的cpu/gpu厂商定义，intel/amd)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存管理： &lt;a href=&#34;http://legendtkl.com/2017/04/02/golang-alloc/&#34;&gt;http://legendtkl.com/2017/04/02/golang-alloc/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GC机制：http://legendtkl.com/2017/04/28/golang-gc/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;深入了解golang的执行原理，https://github.com/qyuhen/book/blob/master/Go%201.5%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.pdf (底层的运行时逻辑有点像php的执行过程, php7底层运行结构也借鉴了golang的设计思想，比如内存的申请)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;faq&#34;&gt;FAQ:&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://golang.org/doc/faq&#34;&gt;https://golang.org/doc/faq&lt;/a&gt;  相当有用值得一读&lt;/p&gt;
&lt;p&gt;热更新方案： &lt;a href=&#34;https://studygolang.com/topics/1194&#34;&gt;https://studygolang.com/topics/1194&lt;/a&gt;  (监控一个当前版本文件是否变动了，如果变动然后将老的执行文件软连指向新的执行文件(rm 软连,ln 创建新的软连，然后通过hup信号优雅的重启由endless启动的服务)&lt;/p&gt;
&lt;h2 id=&#34;开发工具&#34;&gt;开发工具&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;vim-go: &lt;a href=&#34;https://github.com/fatih/vim-go&#34;&gt;https://github.com/fatih/vim-go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;vscode-go: &lt;a href=&#34;https://github.com/Microsoft/vscode-go&#34;&gt;https://github.com/Microsoft/vscode-go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;goland: &lt;a href=&#34;https://www.jetbrains.com/go/&#34;&gt;https://www.jetbrains.com/go/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;diy&#34;&gt;DIY&lt;/h2&gt;
&lt;p&gt;(熟悉三方源码，基础库，自行diy服务)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 网关服务&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 网关后台&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; abtest&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; abtest后台&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 微服务
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; passport&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; activity&lt;/li&gt;
&lt;li&gt;More…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 资源管理(K8S)&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 监控&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; ci/cd构建发布上线&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 队列&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>更换博客</title>
      <link>https://weedge.github.io/post/use-hugo-blog/</link>
      <pubDate>Thu, 12 Oct 2017 10:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/use-hugo-blog/</guid>
      
        <description>&lt;p&gt;  博客有段时间一直没有跟新过了，说白了，就是太懒了，或者没有动力去push你去干好这件事情；看着以前的博客，寥寥无几的几篇，质量也不高；早上上班经常看一些公众号文章，有个作者每天坚持写一篇文章，都已经坚持了大半年了，从生活的思考记录，到技术的积累，而且输出的文章质量不错，至少自己读了之后会产生一些共鸣，或者学到一些知识点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;经常听到技术人总结的话：技术是一个积累的过程，从别人那里看到的，和自己去动手实现的是两回事，别人趟过的坑，你再重新踩一次，也许会遇到新的坑，这些踩过之后，把这些知识点和满坑方案记录下来，日积月累，是对以后是有帮助的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  以前的博客是用&lt;a href=&#34;http://octopress.org/docs/&#34;&gt;octopress&lt;/a&gt;来生成博客的静态文件的，最近发现这个没有更新了; 自己在想是不是可以自己按照这个思路生成一套，加上最近在学习golang；在网上索搜了用golang生成博客的工具，确实有个不错的开源工具&lt;a href=&#34;https://gohugo.io/&#34;&gt;hugo&lt;/a&gt;，使用后，发现超级方便，生成到发布就两步，相比繁琐操作的octopress,要简单方便的多，而且生成的前端模板用的是&lt;a href=&#34;https://mustache.github.io/&#34;&gt;mustache&lt;/a&gt;，模板语法在前端比较常用;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;macOS下安装，直接可以通过brew来安装&lt;code&gt;sudo brew install hugo&lt;/code&gt;就可以使用了；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建立自己的博客，用markdown写文章，然后本地查看，检查ok在发布到github page上；具体操作看&lt;a href=&#34;https://gohugo.io/documentation/&#34;&gt;官方文档&lt;/a&gt;吧， 这里就不介绍了哈。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;  现在就开始新的写作记录旅程吧!&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;路漫漫其修远兮，吾将上下而求索(The road ahead will be long, I shall search)&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
    </item>
    
    <item>
      <title>附近POI: geohash原理</title>
      <link>https://weedge.github.io/post/geohash/</link>
      <pubDate>Wed, 03 Jun 2015 00:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/geohash/</guid>
      
        <description>&lt;h3 id=&#34;问题&#34;&gt;问题&lt;/h3&gt;
&lt;p&gt;  现在吃穿住行的app大都有定位的功能；如何让手机app所在的定位寻找出附近的POI(Point of Interest)呢？至于用户手机是如何获取定位的可以自行Google/Baidu，有时间整理一下。&lt;/p&gt;
&lt;p&gt;地图上定位一个地方，通过经度(longitude)和纬度(latitude)来标记，由WGS84规定(为GPS全球定位系统使用而建立的坐标系统)；比如地球🌍作为一个球体，纬度是指&lt;code&gt;所在位置的纬线到地心的直线&lt;/code&gt;和&lt;code&gt;赤道的纬线到地心的直线&lt;/code&gt;的夹角，通常北纬为正，南纬为负；经度是指&lt;code&gt;所在位置的经线平面&lt;/code&gt;和&lt;code&gt;规定的本初子午线平面&lt;/code&gt;的夹角，以东为东经，以西为西经，通常东经为正，西经为负；&lt;/p&gt;
&lt;p&gt;一个地点的经度一般与它于协调世界时之间的时差相应：每天有24小时，而一个圆圈有360度，因此地球每小时自转15度。因此假如一个人的地方时比协调世界UTC(Coordinated Universal Time)时早3小时的话，那么他在东经45度左右，比如北京是在东经116左右，那时区+8作为中国标准时间CST(China Standard Time)&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;解决方案&#34;&gt;解决方案&lt;/h3&gt;
&lt;p&gt;通过app可以获取到定位信息经维度，以及后台POI(实时/离线)录入的经纬度信息，如何获取附近POI呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接按距离计算：定位的经纬度确定对应的地区；然后和所在地区中的所有商户POI经纬度信息进行距离计算，然后排序，找出最近几公里内的商户POI；这种方法比较暴力，遇到数据量大的时候，比较耗时；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既然数据量大，采用分而治之的办法筛选查找：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用Mysql的B+tree索引进行范围筛选：直接按距离计算(经纬度建立索引)/GeoHash；&lt;/li&gt;
&lt;li&gt;利用Mysql的Rtree空间索引(5.7.4+,InnoDB支持)：mysql空间数据类型(Point,LineString, Polygon)来进行检索；&lt;/li&gt;
&lt;li&gt;利用PostgreSQL的PostGIS模块：通过R树 或 GIST树索引来实现空间索引，PostGIS 实现了Open Geospatial Consortium所提出的基本要素类（点、线、面、多点、多线、多面等）的SQL查询；&lt;/li&gt;
&lt;li&gt;利用MongoDB: 依赖MongoDB的空间搜索算法(geoNear,near),底层也是对GeoHash进行B+tree索引;命令如下：  &lt;code&gt;db.runCommand({ geoNear: &amp;quot;places&amp;quot;, near: [30.545162, 104.062018], num:1000 })&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将经纬度转换成GeoHash字符串，利用字典树查找term,找到对应倒排索引中的商户信息；&lt;/li&gt;
&lt;li&gt;利用Redis(3.2+) GEO命令 &lt;code&gt;GEOADD GEOHASH GEOPOS GEODIST GEORADIUS GEORADIUSBYMEMBER&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://s2geometry.io/&#34;&gt;谷歌的 S² 算法&lt;/a&gt;: 将基于希尔伯特曲线实现，算法性能要优于geohash；具体看官网介绍，具体细节还没有弄清楚，待续~&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从这些解决方案中可以总结出，根据对位置经纬度信息进行转换，然后结合具体的数据结构和算法来实现，适用不同场景:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将经纬度信息转成一维的GeoHash字符串(表示对应位置的区块)，通过ziplist,B+树,字典树trie(倒排索引中的term存储结构)来索引，提供索搜查询；&lt;/li&gt;
&lt;li&gt;将经纬度信息转换成多维的点线面空间信息，通过四叉树,R树,GIST树来索引，提供索搜查询;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;方案概要&#34;&gt;方案概要&lt;/h3&gt;
&lt;p&gt;以上给出的具体实施方案，篇幅有限，这里主要是讨论GeoHash编码方式来表示空间信息。具体空间信息采集可以采集高德地图的接口，或者&lt;a href=&#34;https://github.com/lzxue/WeiboDataShare&#34;&gt;微博的一份数据&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;geohash&#34;&gt;GeoHash&lt;/h3&gt;
&lt;p&gt;geohash 是 Gustavo Niemeyer 发明的一种对地理位置进行编码的算法；它是一种分级的数据结构，把空间划分为网格。Geohash 属于空间填充曲线中的 Z 阶曲线(&lt;a href=&#34;https://en.wikipedia.org/wiki/Z-order_curve&#34;&gt;Z-order curve&lt;/a&gt;)的实际应用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过二维的经纬度所在的区块表示成一维的字符串信息，字符串的长度越长，表示的区域范围更加精确。长度为9的geohash编码的精度能达到4米左右，10位的geohash经度能达到0.6米，一般情况下能满足我们大部分的需求；&lt;/li&gt;
&lt;li&gt;geohash 生成的字符串代表的不是地图上的一个点，而是地图上一个矩形区域，在一定程度上能保证隐私(知道大概的位置)；&lt;/li&gt;
&lt;li&gt;geohash编号后方便索引和缓存，具有公共前缀的geohash编码作为key/term 索引、查找附近区域的的POI信息；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;原理&#34;&gt;原理&lt;/h4&gt;
&lt;h4 id=&#34;编码步骤&#34;&gt;编码步骤&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;首先将纬度范围(-90, 90)平分成两个区间(-90, 0)、(0, 90)， 如果目标纬度位于前一个区间，则编码为0，否则编码为1; 以此类推，直到精度符合要求为止;&lt;/li&gt;
&lt;li&gt;经度也用同样的算法，对(-180, 180)依次细分;&lt;/li&gt;
&lt;li&gt;接下来组码，将经度和纬度的编码合并，奇数位是纬度，偶数位是经度，得到二进制编码；&lt;/li&gt;
&lt;li&gt;最后使用base32（0-9、b-z，去掉a,i,l,o，比较常用）或者base36编码(base36的版本对大小写敏感，用了36个字符，“23456789bBCdDFgGhHjJKlLMnNPqQrRtTVWX”)；这里采用base32方式进行操作，首先将组合好的二进制码转成对应的十进制（二进制每5位表示一个base32字符）；十进制对应base32编码表如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/weedge/weedge.github.io/master/image/base32.png&#34; alt=&#34;base32&#34;&gt;&lt;/p&gt;
&lt;p&gt;例如：将坐标 (39.97696,116.3764874)（latitude, longitude）编码成长度为12的字符串(base32编码) wx4g2jwf8tqx&lt;/p&gt;
&lt;p&gt;精度表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;length&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;latitude bits&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;longitude bits&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;latitude error&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;longitude error&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;km error&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±23&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±23&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±2500&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±2.8&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±5.6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±630&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±0.70&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±0.70&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±78&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±0.087&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±0.18&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;12&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;13&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±0.022&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±0.022&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±2.4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;15&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;15&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±0.0027&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±0.0055&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±0.61&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;17&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;18&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±0.00068&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±0.00068&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±0.076&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;20&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;20&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±0.00008&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±0.00017&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±0.019&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;9&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;22&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;23&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±0.00002&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±0.000021&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±0.00478&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;25&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;25&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±0.00000268&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±0.00000536&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±0.0005971&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;11&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;27&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;28&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±0.00000067&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±0.00000067&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±0.0001492&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;12&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;30&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;30&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±0.00000008&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±0.00000017&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;±0.0000186&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;geohash编码长度对应区域大小：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;length&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;width&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;height&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5000km&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5000km&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1250km&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;625km&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;156km&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;156km&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;39.1km&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;19.5km&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4.89km&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4.89km&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.22km&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.61km&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;153m&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;153m&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;38.2m&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;19.1m&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;9&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4.77m&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4.77m&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;10&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1.19m&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;0.596m&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;11&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;149mm&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;149mm&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;12&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;37.2mm&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;18.6mm&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;解码步骤&#34;&gt;解码步骤&lt;/h4&gt;
&lt;p&gt;解码操作为编码操作的逆向过程，这里就省略(后续补上)&lt;/p&gt;
&lt;h4 id=&#34;获取相邻区域&#34;&gt;获取相邻区域&lt;/h4&gt;
&lt;p&gt;为啥要获取相邻区域呢？？？&lt;/p&gt;
&lt;p&gt;根据编码算法定义不难看出，如果需要寻找附近多少米的POI，根据精度只要前缀匹配规定长度的字符串(可以把经常访问的前缀匹配的字符串表示的区域POI信息缓存起来)，比如坐标 (39.97696,116.3764874)对应成长度为12的字符串wx4g2jwf8tqx，想找附近500m的POI，长度为6的geohash编码能表示矩形区域在0.744平方千米左右（区域大小和geohash编码长度对应关系见上表），那么查询的时候就可缩小范围，找出那些前缀为wx4g2j的POI，与wx4g2jwf8tqx公共前缀匹配的长度越大，离得距离也就越近；&lt;/p&gt;
&lt;p&gt;但是这种前缀匹配的方式存在一个临近边界问题，就是在区域的边界地方，在这个区域的相邻区域的公共前缀不同（长度按照区域大小选出），按照公共前缀匹配的方法会少筛选出一部分附近的POI;&lt;/p&gt;
&lt;p&gt;解决的办法是将相邻的8块区域也算进来，扩大寻找范围，计算这些区域中的POI和所在位置的距离， 然后按距离排序筛选；&lt;/p&gt;
&lt;h4 id=&#34;待续-geohash-vs-s&#34;&gt;待续 (Geohash vs S²)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Geohash 有12级，从5000km 到 3.7cm。中间每一级的变化比较大。有时候可能选择上一级会大很多，选择下一级又会小一些。比如选择字符串长度为4，它对应的区域宽度是39.1km，需求可能是50km，那么选择字符串长度为5，对应的区域宽度就变成了156km，瞬间又大了3倍了。这种情况选择多长的 Geohash 字符串就比较难选。选择不好，每次判断可能就还需要取出周围的8个格子再次进行判断。Geohash 需要 12 bytes 存储。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;S² 有30级，从 0.7cm² 到 85,000,000km² 。中间每一级的变化都比较平缓，接近于4次方的曲线。所以选择精度不会出现 Geohash 选择困难的问题。S2 的存储只需要一个 uint64 即可存下。S²算法待续&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;抛出问题&#34;&gt;抛出问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 运动的个体(个体也可以当做POI)，如何获取附近实时运动的POI呢？ 实时计算方案呢？(像多人约会涉猎app)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%BB%8F%E5%BA%A6&#34;&gt;经度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%BA%AC%E5%BA%A6&#34;&gt;维度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Geohash&#34;&gt;GeoHash&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.movable-type.co.uk/scripts/gis-faq-5.1.html&#34;&gt;空间距离计算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tech.meituan.com/lucene_distance.html&#34;&gt;地理空间距离计算优化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/spatial-types.html&#34;&gt;Mysql8.0 - Spatial Data Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://postgis.net/workshops/postgis-intro/&#34;&gt;PostGIS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.mongoing.com/mongodb-geo-index-1/&#34;&gt;MongoDB地理索引初探&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.huangz.me/diary/2015/redis-geo.html&#34;&gt;Redis GEO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.huangz.me/diary/2015/annotated-redis-geo-source.html&#34;&gt;Redis GEO源码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://halfrost.com/go_spatial_search/&#34;&gt;高效的多维空间点索引算法 — Geohash 和 Google S2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/LBSer/p/3310455.html&#34;&gt;GeoHash核心原理解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://geohash.gofreerange.com/&#34;&gt;GeoHash在线演示&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mmcloughlin/geohash&#34;&gt;Geohash-GO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/weedge/geo&#34;&gt;Geohash-PHP扩展&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>工具盒子-GNU global</title>
      <link>https://weedge.github.io/post/gnu-global/</link>
      <pubDate>Sat, 15 Nov 2014 21:04:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/gnu-global/</guid>
      
        <description>&lt;h3 id=&#34;gnu-global&#34;&gt;gnu global&lt;/h3&gt;
&lt;p&gt;源码标记，浏览源码挺好用的工具,轻量级的，简单易用。 gtags类似ctags,但是效率比ctags高，具体比较查看&lt;a href=&#34;https://github.com/OpenGrok/OpenGrok/wiki/Comparison-with-Similar-Tools&#34;&gt;这里&lt;/a&gt;(OpenGrok使用相对比较复杂)，而且未来支持的语言也比较多。对Linux-2.6.32源码390M的文件进行标签产出289MB的标签文件。&lt;/p&gt;
&lt;p&gt;可以通过源码安装就OK &lt;!-- raw HTML omitted --&gt;wget &lt;a href=&#34;http://tamacom.com/global/global-6.3.2.tar.gz;&#34;&gt;http://tamacom.com/global/global-6.3.2.tar.gz;&lt;/a&gt; tar zxvf global-6.3.2.tar.gz; cd global-6.3.2; ./configure; make &amp;amp;&amp;amp; make install&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;在需要查找的目录下运行&lt;!-- raw HTML omitted --&gt;gtags&lt;!-- raw HTML omitted --&gt;,会生成三个文件： GTAGS&amp;ndash;定义的函数变量； GRTAGS&amp;ndash;引用的函数变量； GPATH&amp;ndash;函数变量所在文件的路径。&lt;/p&gt;
&lt;p&gt;有用的命令：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;global -f DIR/fileC.c &amp;ndash;color&lt;!-- raw HTML omitted --&gt;这个命令看这个文件下有哪些函数，比较有用,加-l在当前目录下查找&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;global -r func&lt;!-- raw HTML omitted --&gt;函数在哪些文件中引用&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;global -ax func&lt;!-- raw HTML omitted --&gt;函数所在的目录文件具体哪些行&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;global -P file&lt;!-- raw HTML omitted --&gt;匹配文件目录文件，类似&lt;!-- raw HTML omitted --&gt;find ./ -type d | grep file&lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;&lt;!-- raw HTML omitted --&gt;global -g func&lt;!-- raw HTML omitted --&gt;匹配有func字符的文件，和grep功能一样&lt;/li&gt;
&lt;li&gt;如果代码跟新了，需要更新标签文件，&lt;!-- raw HTML omitted --&gt;global -vu&lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过globash进入global命令模式，其中&lt;!-- raw HTML omitted --&gt;show -e/v/l/g Nth&lt;!-- raw HTML omitted --&gt;分别用emacs,vi,less,mozilla 来浏览第N个文件标记所搜得关键词的内容，或者不指定用编辑器，采用环境变量EDITOR定义号的编辑器来查看(在.bashrc中添加&lt;!-- raw HTML omitted --&gt;export EDITOR=vim&lt;!-- raw HTML omitted --&gt;)，个人比较喜欢用vim；使用tags查看已经查看过的tags；使用mark来标记查询过的标签tag,&lt;!-- raw HTML omitted --&gt;mark -l&lt;!-- raw HTML omitted --&gt;列出mark列表，&lt;!-- raw HTML omitted --&gt;mark Nth&lt;!-- raw HTML omitted --&gt;通过默认编辑器浏览mark的第N个文件；&lt;!-- raw HTML omitted --&gt;pop&lt;!-- raw HTML omitted --&gt;对记录过的查找标签命令的结果栈退出栈顶结果，并显示处理后的栈顶结果；&lt;!-- raw HTML omitted --&gt;cookie&lt;!-- raw HTML omitted --&gt;用来记录当前的文件夹，&lt;!-- raw HTML omitted --&gt;cookie -l&lt;!-- raw HTML omitted --&gt;查看cookie记录的文件夹，&lt;!-- raw HTML omitted --&gt;warp Nth&lt;!-- raw HTML omitted --&gt;返回列出的第N个文件夹。&lt;br&gt;
其他简单的命令可以通过ghelp查看。&lt;/p&gt;
&lt;p&gt;还有个htags是用来生成超文本文件的，方便在浏览器下查看，如果在命令行的开发坏境下，这个有个毛用哦~&lt;/p&gt;
&lt;p&gt;使用gtags-cscope进入client模式具体操作按？帮助文档操作，(哈哈，貌似像个搜索引擎，tag的缓存文件采用的b-tree)。具体见&lt;a href=&#34;https://www.gnu.org/software/global/globaldoc_toc.html#Requesting-the-initial-search&#34;&gt;https://www.gnu.org/software/global/globaldoc_toc.html#Requesting-the-initial-search&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;gtags,global其他具体命令，参考帮助文档或者查看&lt;a href=&#34;https://www.gnu.org/software/global/globaldoc_toc.html&#34;&gt;Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;gtags可以作为ctags的扩展进行使用，具体参考&lt;a href=&#34;https://www.gnu.org/software/global/globaldoc_toc.html#Plug_002din&#34;&gt;https://www.gnu.org/software/global/globaldoc_toc.html#Plug_002din&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;vim中使用global&#34;&gt;VIM中使用global&lt;/h3&gt;
&lt;p&gt;可以之间从安装好的global文件间share中将gtags.vim复制到~/.vim/plugin文件夹中：&lt;!-- raw HTML omitted --&gt;cp /usr/local/share/gtags/gtags.vim $HOME/.vim/plugin&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;或者如果使用vundle来管理的话，BundleSearch gtags 安装；或者直接&lt;!-- raw HTML omitted --&gt;cd $HOME/.vim/bundle &amp;amp;&amp;amp; git clone &lt;a href=&#34;https://github.com/vim-scripts/gtags.vim&#34;&gt;https://github.com/vim-scripts/gtags.vim&lt;/a&gt; gtags&lt;!-- raw HTML omitted --&gt;，或者用git submodule来管理，原理都差不多，自己vim以前用vundle管理过，就直接将自己用的插件全部整合在一起了，去掉vundle插件，采用git submodule管理插件模块，但是vundle整体管理框架还在，&lt;a href=&#34;https://github.com/weedge/Vim-PHP-IDE&#34;&gt;vim配置&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在vim的命令模式下采用Gtags命令，参数和shell命令行一样，查找出来的list列表在quickfix window 中展现，操作的话与grep命令差不多，但是筛选比较细些，用-g参数就和grep一样，后面可以加上grep一样的参数。&lt;/p&gt;
&lt;p&gt;具体参考&lt;a href=&#34;https://www.gnu.org/software/global/globaldoc_toc.html#Vim-editor&#34;&gt;https://www.gnu.org/software/global/globaldoc_toc.html#Vim-editor&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;global作为一个轻量级的源码标记，浏览源码挺好用的工具，总体体验了吧，gtags生成的文件进行了细分，tag的检索效率相对提高了，如果源码比较大型的话，采用global -vu 来更新tag文件，要快很多；用vim进行开发，可以使用gtags.vim这个插件，与grep配合使用吧(当所检索的函数/变量tag比较模糊的时候，可以先用grep查询，在使用Gtags定位).好用程度，只有继续体验一段时间吧。。。&lt;/p&gt;</description>
      
    </item>
    
  </channel>
</rss>
