<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术 on 时间飘过</title>
    <link>https://weedge.github.io/categories/%E6%8A%80%E6%9C%AF/</link>
    <description>Recent content in 技术 on 时间飘过</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 23 Feb 2023 10:26:23 +0800</lastBuildDate><atom:link href="https://weedge.github.io/categories/%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go tips-笔记: 优化 91-100 mistakes</title>
      <link>https://weedge.github.io/post/notions/go-tips/go-tips-12-optimizations/</link>
      <pubDate>Thu, 23 Feb 2023 10:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/notions/go-tips/go-tips-12-optimizations/</guid>
      <description>&lt;h1 id=&#34;引言&#34;&gt;引言&lt;/h1&gt;
&lt;p&gt;在大多数情况下，编写可读、清晰的代码比编写经过优化但更复杂、更难理解的代码要好，不要过早的优化。建议遵循软件工程师 Wes Dyer 的这句名言：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Make it correct, make it clear, make it concise, make it fast, in that order.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;并不意味着禁止为速度和效率优化应用程序, 了解并掌握这些优化点，以备不时之需；文中给出了常见的优化技术；有些特定于 Go 内存模型，内存分配，GPM调度模型；有些是关于了解硬件有助于写出好的代码(适用于不同语言)，其中会有硬件方面的术语，可以结合wiki进行学习；&lt;/p&gt;
&lt;p&gt;tips: 学习一些和编程优化相关的底层计算机组成原理，并且结合相关硬件进行基准压测实践。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go tips-笔记: 测试 82-90 mistakes</title>
      <link>https://weedge.github.io/post/notions/go-tips/go-tips-11-testing/</link>
      <pubDate>Mon, 20 Feb 2023 14:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/notions/go-tips/go-tips-11-testing/</guid>
      <description>&lt;h1 id=&#34;引言&#34;&gt;引言&lt;/h1&gt;
&lt;p&gt;测试是项目生命周期的一个重要方面。它提供了无数的好处，例如建立对应用程序的信心、充当代码文档以及使重构更容易。与其他一些语言相比，Go 具有强大的编写测试原语。主要讨论测试过程变得脆弱、效率低下和准确性低的常见错误。这类问题属于工程规范实践，有些case同样适用于其他语言。&lt;/p&gt;
&lt;p&gt;Go 中提供 go test 工具来执行测试，可以查看具体的开发文档： &lt;strong&gt;&lt;a href=&#34;https://pkg.go.dev/cmd/go#hdr-Testing_flags&#34;&gt;https://pkg.go.dev/cmd/go#hdr-Testing_flags&lt;/a&gt;&lt;/strong&gt;  里面介绍了每个模式的具体使用方式，使用好这些测试模式flag，可以更快执行或更好地发现可能错误，进而保证代码质量，工程代码稳定性建设上的重要一环。Go中支持4种测试函数：单测函数，基准压测函数，模糊测试，以及打印输出样例测试。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;TestXxx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;testing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;BenchmarkXxx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;testing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;FuzzXxx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;testing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ExampleXxx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;The output of\\nthis example.&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// Output: The output of
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// this example.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Go tips-笔记: 标准库 75-81 mistakes</title>
      <link>https://weedge.github.io/post/notions/go-tips/go-tips-10-standard-lib/</link>
      <pubDate>Sun, 19 Feb 2023 14:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/notions/go-tips/go-tips-10-standard-lib/</guid>
      <description>&lt;h1 id=&#34;引言&#34;&gt;引言&lt;/h1&gt;
&lt;p&gt;从程序中产生的错误中大多是使用姿势的不对，以及没有仔细阅读标准库相关包的开发文档，未查看源码导致，但是没有实践过这些问题，即使熟读文档和源码也可能避免不了。笔记中会以书中的mistake为切入点，结合源码升入分析其背后产生的原因，以及提出解决方案来避免。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go tips-笔记: 并发实践 61-74 mistakes</title>
      <link>https://weedge.github.io/post/notions/go-tips/go-tips-09-concurrency-practice/</link>
      <pubDate>Sat, 18 Feb 2023 14:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/notions/go-tips/go-tips-09-concurrency-practice/</guid>
      <description>&lt;h1 id=&#34;引言&#34;&gt;引言&lt;/h1&gt;
&lt;p&gt;这里主要介绍并发实践中遇到的问题，这些问题在golang开源项目中也经常会出现，如果编写并发也会一直伴随在开发当中出现，也有工程实践相关的论文进行统计归纳总结(PS: 用这种方式发个论文还是比较轻松的~)：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://songlh.github.io/paper/go-study.pdf&#34;&gt;Understanding Real-World Concurrency Bugs in Go&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;tips: 作者对golang和rust都有研究，结合相关的代码都可以一起学习下, 语言方面的小细节&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://arxiv.org/pdf/2204.00764.pdf&#34;&gt;&lt;strong&gt;A Study of Real-World Data Races in Golang&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Go 官方提供race工具来检查并发场景下的数据竞争问题： &lt;a href=&#34;https://go.dev/doc/articles/race_detector&#34;&gt;https://go.dev/doc/articles/race_detector&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/google/sanitizers/wiki/ThreadSanitizerGoManual&#34;&gt;https://github.com/google/sanitizers/wiki/ThreadSanitizerGoManual&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注：Go要使用-race，需启用CGO，依赖sanitizers；一般用于开发测试进行检测&lt;/p&gt;
&lt;p&gt;如果想更加深入的了解并发并行，可以一起学习这本书： &lt;a href=&#34;https://mirrors.edge.kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html&#34;&gt;&lt;strong&gt;Is Parallel Programming Hard, And, If So, What Can You Do About It?&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go tips-笔记: 并发概念 55-60 mistakes</title>
      <link>https://weedge.github.io/post/notions/go-tips/go-tips-08-concurrency-foundations/</link>
      <pubDate>Fri, 17 Feb 2023 14:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/notions/go-tips/go-tips-08-concurrency-foundations/</guid>
      <description>笔记 55.混淆并发和并行 这个在处理大数据的场景中经常可以看到，可以这么抽象，比如将一个job 分成 很多的 task 事件， 比如 读取文件 task, 切割文件task</description>
    </item>
    
    <item>
      <title>Go tips-笔记: 错误管理 48-54 mistakes</title>
      <link>https://weedge.github.io/post/notions/go-tips/go-tips-07-error-management/</link>
      <pubDate>Thu, 16 Feb 2023 14:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/notions/go-tips/go-tips-07-error-management/</guid>
      <description>笔记 48.panic Go 新手对错误处理感到困惑是很常见的。在 Go 中，错误通常由返回的函数或方法管理类型error作为最后一个参数（这个是代码风格，error可</description>
    </item>
    
    <item>
      <title>Go tips-笔记: 函数和方法 42-47 mistakes</title>
      <link>https://weedge.github.io/post/notions/go-tips/go-tips-06-functions-methods/</link>
      <pubDate>Wed, 15 Feb 2023 14:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/notions/go-tips/go-tips-06-functions-methods/</guid>
      <description>笔记 42.结构体方法不知道使用哪种类型的接收者 文中说了很多，感觉为了凑数，主要就是围绕着值传递还是指针传递，值传递给接收者，如果结构体中没有</description>
    </item>
    
    <item>
      <title>Go tips-笔记: string 36-41 mistakes</title>
      <link>https://weedge.github.io/post/notions/go-tips/go-tips-05-strings/</link>
      <pubDate>Tue, 14 Feb 2023 14:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/notions/go-tips/go-tips-05-strings/</guid>
      <description>&lt;h1 id=&#34;笔记&#34;&gt;笔记&lt;/h1&gt;
&lt;p&gt;在 Go 中，string是一种不可变的数据结构，包含以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指向不可变字节序列的指针，指向一个byte类型的数组&lt;/li&gt;
&lt;li&gt;此序列中的总字节数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;string在Go中的内部结构是&lt;code&gt;reflect.StringHeader&lt;/code&gt;位于&lt;code&gt;reflect/value.go&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// StringHeader is the runtime representation of a string.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// It cannot be used safely or portably and its representation may
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// change in a later release.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// Moreover, the Data field is not sufficient to guarantee the data
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// it references will not be garbage collected, so programs must keep
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// a separate, correctly typed pointer to the underlying data.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;StringHeader&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Data&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uintptr&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Len&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//uintptr  an unsigned integer large enough to store the uninterpreted bits of a pointer value
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Go tips-笔记: 控制语句 30-35 mistakes</title>
      <link>https://weedge.github.io/post/notions/go-tips/go-tips-04-control-structures/</link>
      <pubDate>Tue, 14 Feb 2023 10:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/notions/go-tips/go-tips-04-control-structures/</guid>
      <description>笔记 30.忽略了元素在 for range循环中被复制 (重要) 需要注意，range循环中的值元素是一个复制的副本。因此，如果值是需要改变结构，只会更</description>
    </item>
    
    <item>
      <title>Go tips-笔记: 数据类型 17-29 mistakes</title>
      <link>https://weedge.github.io/post/notions/go-tips/go-tips-03-data-types/</link>
      <pubDate>Mon, 13 Feb 2023 20:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/notions/go-tips/go-tips-03-data-types/</guid>
      <description>笔记 17.与八进制文字混淆 Go 可以处理二进制、十六进制、虚数和八进制数。八进制数字以 0 开头。但是，为了提高可读性并避免未来代码阅读器可能犯的错</description>
    </item>
    
    <item>
      <title>Go tips-笔记: 代码和项目组织 1-16 mistakes</title>
      <link>https://weedge.github.io/post/notions/go-tips/go-tips-02-code-project-organization/</link>
      <pubDate>Mon, 13 Feb 2023 14:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/notions/go-tips/go-tips-02-code-project-organization/</guid>
      <description>&lt;h1 id=&#34;引言&#34;&gt;引言&lt;/h1&gt;
&lt;p&gt;从错误中学习效率更高，而且从错误失败的场景下学习，往往比直接交代正确性的理论知识，没有上下文的结果去 记忆巩固知识，在错误失败场景下往往印象更深刻；可以帮助我们更好地避免错误并做出更明智、更有意识的决定，因为我们现在了解了错误背后的基本原理，有种该死的，恍然大悟的感觉，拨开雨雾见月明；&lt;/p&gt;
&lt;p&gt;涵盖了可能导致各种软件错误的案例，包括数据竞争、泄漏、逻辑错误和其他缺陷。虽然准确的测试应该是尽早发现此类错误的一种方式，但有时可能会因为时间限制或复杂性等不同因素而错过案例。因此，使用Golang开发，确保避免常见错误至关重要。&lt;/p&gt;
&lt;p&gt;有些坑可能曾经踩过，通过这些mistakes产生共鸣，加深印象，同时可以继续追加一些新的坑来填充,比如系统性能调优，包括IO,  网络，数据编解码压缩，分布式系统，业务系统组织架构，逐步学习实践试错过程。学习笔记开个头。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>源码阅读草稿-leveldb</title>
      <link>https://weedge.github.io/todo/leveldb-viewcode/</link>
      <pubDate>Tue, 07 Feb 2023 10:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/todo/leveldb-viewcode/</guid>
      <description>安装 leveldb源码使用tag 1.23, 在本地macOS 下通过vscode查看源码，编译debug如下： git clone --recurse-submodules https://github.com/google/leveldb.git &amp;amp;&amp;amp; cd leveldb &amp;amp;&amp;amp; git checkout 1.23 brew install gflags brew install snappy mkdir -p build &amp;amp;&amp;amp;</description>
    </item>
    
    <item>
      <title>设计-直播间赠送礼物功能</title>
      <link>https://weedge.github.io/post/zb-gift/</link>
      <pubDate>Mon, 21 Nov 2022 10:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/zb-gift/</guid>
      <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;直播线上互动，已成为当下生活的一部分，特别是受疫情影响，成为互联网的主要流量入口；研究了下各个平台直播间送礼物的功能，发现大同小异，在礼物分组，一些定制化的礼物有区分，整体交互流程大致相同，主要是直播间主播上播，用户通过礼物打赏给主播们(一个直播间可能有多名主播在互动)，礼物是通过虚拟币(**币) 换算，早期互联网用户线上互动礼物，玩家最多的应该是QQ币了，只不过以前的打赏赠送场景是在web2.0刚开始的时候，交互的大多是文字和图片，相关产品场景，虚拟空间(个人空间，博客，种菜等娱乐互动场景)；随着底层网络基建的发展，4G之后出现了大量的视频网站，用户可以录一些视频内容来互动；到后来音视频流媒体的发展，相关的在线直播间开始涌现，用户之间享受一波直播红利带来的互动，当然影响相对于前面的形式更加实时和直接；现在的5G和未来6G，以及物联网都会给直播形式带来新的互动场景,比如：虚拟会场，人机互动；其中早期培养起来的打赏送礼行为功能经常用于有主播的娱乐互动直播中，也是增值盈利的一部分；&lt;/p&gt;
&lt;p&gt;tips: 除了送礼功能，根据不同直播场景，还有语音视频连麦，电商带货商品，没有主播，节目直播/转播，会议直播，自习室，基本的点赞，计数，聊天基础服务功能；还有些抽奖功能，答题功能(教育类直播居多)，投票，红包这些功能服务可在开播时设置，是否启用；有用户基础的流量平台可能还会以竞价排名的方式推荐一波；这些功能可以作为一个可管理的插件，通过组合的方式应用于直播中，方便管理，后续可以添加新功能满足某类型直播场景。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>让ML跑起来</title>
      <link>https://weedge.github.io/post/let-ml-go/</link>
      <pubDate>Tue, 08 Nov 2022 10:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/let-ml-go/</guid>
      <description>&lt;h3 id=&#34;介绍&#34;&gt;介绍&lt;/h3&gt;
&lt;p&gt;上文提到通过用户的行为数据存放在S3中，这些数据包括结构化和非结构化数据，怎么让这些数据变得有价值呢？一种是人为进行数据挖掘，对相关指标转化率进行评估；还有一种是通过这些数据来训练模型，然后将预测模型用于生产环境中进行A/B测试，选出适合的模型，这个模型需要不断更新迭代，并且自动化半自动化运行起来；&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://docs.aws.amazon.com/zh_cn/sagemaker/latest/dg/images/ml-concepts-10.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>用户行为分析方案设计</title>
      <link>https://weedge.github.io/post/user-behavior-analytics-solution/</link>
      <pubDate>Wed, 02 Nov 2022 10:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/user-behavior-analytics-solution/</guid>
      <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;用户在手机和pc端使用客户业务产品，比如浏览网页，购买商品，查看文档，观看视频，直播，IOT场景；会产生大量的用户行为数据，主要包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;非结构化数据：日志(前端事件埋点日志，服务端处理事件日志)，还有些非结构化的图片，音视频数据等等，主要存放在文件存储系统中；&lt;/li&gt;
&lt;li&gt;结构化和半结构化数据： 用户操作产品写入的结构化数据存放于数据库表中，将文档型半结构化的数据放入文档数据库中；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要分析用户的行为数据，进行决策；分为实时流式处理和离线批处理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实时流处理，主要用于实时展现客户端看板，后台BI实时分析，实时风控/推荐，异常报警等场景；&lt;/li&gt;
&lt;li&gt;离线批处理，分析用户历史数据，进行推荐算法等机器学习算法模型训练使用，数据仓库中根据不同维度对数据过滤聚合，进行上卷下钻分析，比如计算DAU,WAU,MAU，转化率(购买率，注册率)分析等，通常对数据建设投入多的话， 会把用户产生的结构化非结构化的数据都存下，放在一个大的池子里待使用时进行分析，即所谓的数据湖，围湖而建挖掘数据价值；而数仓相对精细化的分析，前置建模建表分析；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对此进行方案分析，本文将介绍一种实时离线处理分析用户行为数据方案，即能帮助企业低成本地使用海量数据，又能更快速地响应业务需求，同时借助亚马逊云科技的托管服务，能够快速实施和轻松运维。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>全栈开发</title>
      <link>https://weedge.github.io/post/shop/</link>
      <pubDate>Sun, 02 Jan 2022 10:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/shop/</guid>
      <description>&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;以前工作中有过前端的开发经验，使用后端模版Smarty(主要是外部需求，现在新项目中应该很少使用这个了)，前端模版Mustache，页面中使用 js jquery交互逻辑，直接服用一些开源的UI组件Bootstrap，开源的后台UI系统，主要是建设内部后台的时候使用，自动生成CRUD页面；前端的技术栈更新迭代相对后端快些，通过以全栈技术栈为切入点，通过一个简单的系统，学习下最新技术栈工具，主要目的如下：&lt;/p&gt;
&lt;p&gt;根据需求，实现一个简单功能的购物系统，目的是为了学习ts-&amp;gt;js on node.js全栈开发，了解整体开发构建工具，熟悉下工具开发流程，主要还是了解前端框架工具的使用，以及熟悉通过js运行时环境运行在后端服务上的应用开发工具，以便在后续开发后台系统的时候可以熟练使用这些技术进行开发，这些工具的设计思想可以借鉴到其他后端业务开发语言中。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CRDT</title>
      <link>https://weedge.github.io/post/crdt/</link>
      <pubDate>Tue, 28 Dec 2021 10:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/crdt/</guid>
      <description>&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;无冲突复制数据类型&lt;/strong&gt;(CRDT: &lt;strong&gt;conflict-free replicated data type&lt;/strong&gt;) 是一种简化分布式数据存储系统和多用户应用程序的数据结构。&lt;/p&gt;
&lt;p&gt;在许多系统中，某些数据的副本需要存储在多台计算机上。此类系统的示例包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在本地设备上存储数据，并且需要将该数据同步到属于同一用户的其他设备（同一用户多端设备同步，例如日历、笔记、联系人或提醒）的移动应用程序；&lt;/li&gt;
&lt;li&gt;分布式数据库，维护数据的多个副本（在同一数据中心或不同位置,一般是不同数据中心的多活场景），以便在某些副本离线时系统继续正常工作；&lt;/li&gt;
&lt;li&gt;协作软件，例如 Google Docs、Trello、Figma 或许多其他软件，其中多个用户可以同时更改同一文件或数据；&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/shows/tech-exceptions/concordant-always-know-what-to-expect-from-your-data&#34;&gt;边缘计算场景&lt;/a&gt;，比如多个手机/车载app 在无信号的森林中，产生的本地离线协同数据，多个设备同步到云上处理;&lt;/li&gt;
&lt;li&gt;大规模数据存储和处理系统，复制数据以实现全球可扩展性。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>pool</title>
      <link>https://weedge.github.io/post/pool/</link>
      <pubDate>Thu, 02 Dec 2021 12:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/pool/</guid>
      <description>&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;平常想到不浪费资源的方法，是对资源进行复用，减少资源消耗和浪费(小时候大人经常在吃饭时说的那句话)；在计算机工程领域，存在大量消耗资源的场景，多路复用和池化是最常用的性能优化手段；多路复用存在系统调用，由系统内核层面去支持优化(I/O多路复用select/poll/epoll/kqueue)，而池化可以应用用户使用层面来优化；池化(&lt;a href=&#34;https://en.wikipedia.org/wiki/Pool_(computer_science)&#34;&gt;pool&lt;/a&gt;)是一种资源复用优化技术，减少资源回收处理，提高资源利用率，资源最好是固定大小，如果在复用资源过程中，资源在逐渐增大，一直复用，也会导致资源消耗过多，到了一定大小之后，通过系统释放掉；在程序启动的时候提前申请加载好资源放到池子中，运行时根据不同的调度管理资源策略从池子中获取准备好的资源，或者运行时新建资源放入池子中，用户程序中进行自定义处理操作，操作完之后将资源重新放入池子中复用，有些资源可以动态扩缩； 资源主要是程序运行时对象，当然这些操作资源实际都是分配在虚拟内存空间的内核空间和用户空间中，比如，&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B&#34;&gt;进程&lt;/a&gt;(process &lt;a href=&#34;https://en.wikipedia.org/wiki/Process_control_block&#34;&gt;PCB&lt;/a&gt; 内核态)、&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%9F%B7%E8%A1%8C%E7%B7%92&#34;&gt;线程&lt;/a&gt;(thread &lt;a href=&#34;https://en.wikipedia.org/wiki/Thread_control_block&#34;&gt;TCB &lt;/a&gt; 内核态)、&lt;a href=&#34;https://zh.wikipedia.org/zh-hans/%E5%8D%8F%E7%A8%8B&#34;&gt;协程&lt;/a&gt;(coroutine 用户态协作式调度,尽量减少内核调度)为载体的工作任务(work task 在用户态分配栈空间)；内存对象(heap object)，长链接(tcp connect) 等；主要对这些资源对象进行池化技术进行介绍，了解池化对应场景。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>深入理解Linux的Page Cache 「转载的哦」</title>
      <link>https://weedge.github.io/%E8%BD%AC%E8%BD%BD/page-cache/</link>
      <pubDate>Fri, 26 Nov 2021 11:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/%E8%BD%AC%E8%BD%BD/page-cache/</guid>
      <description>from: 互联网，了解下备个份而已啦～！unix 请看个 man 1、Page Cache 1.1 Page Cache 是什么？ 为了理解 Page Cache，我们不妨先看一下 Linux 的文件 I/O 系统，如下图所示</description>
    </item>
    
    <item>
      <title>WAL</title>
      <link>https://weedge.github.io/post/wal/</link>
      <pubDate>Sun, 21 Nov 2021 10:26:23 +0800</pubDate>
      
      <guid>https://weedge.github.io/post/wal/</guid>
      <description>&lt;h2 id=&#34;序言&#34;&gt;序言&lt;/h2&gt;
&lt;p&gt;​	数据落地之前，如果出现持久化存储引擎实例重启，或者服务当机重启，如何进行故障恢复（Crash Recovery）呢？数据写操作增删改，这些操作状态数据，是如何保证事务中原子性和持久性的呢？ 这些问题数据大拿们提出了&lt;a href=&#34;https://en.wikipedia.org/wiki/Algorithms_for_Recovery_and_Isolation_Exploiting_Semantics&#34;&gt;Algorithms for Recovery and Isolation Exploiting Semantics&lt;/a&gt; ，基于语义的恢复与隔离算法,现代数据库的基础理论；当前主流关系型数据在事务实现上都受到该理论的影响，其中有两种故障恢复的方法： 预写日志(write-ahead logging (WAL) ) 和shadow-page technique；shadow-page 方法简单介绍就是每次事务操作，以page为单位，写时复制的方式，分为Current和Shadow，类似主备的形式，如果commit成功，Current中的page合并到 Shadow中; 如果abort不成功丢弃Current的page; 如果Crash了，从Shadow中的page恢复，对所有未提交事务的回滚操作； 由于shadow-page技术的实现以page为单位，page内无法并发操作，commit/回滚时会有大量垃圾回收操作；本文主要介绍WAL，以及对应持久化存储引擎的实现机制介绍。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
