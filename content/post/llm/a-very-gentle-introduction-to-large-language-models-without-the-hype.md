---
author: "weedge"
title: "译：大型语言模型入门介绍"
date: 2023-12-04T10:26:23+08:00
tags: [
	"oneday","LLM","transformer"
]
categories: [
	"技术",
]


---

![原始的 Transformer 模型结构](https://raw.githubusercontent.com/weedge/mypic/master/llm/a-very-gentle-introduction-to-large-language-models-without-the-hype/transformers.svg)

## 简介

本文旨在让没有计算机科学背景的人深入了解 ChatGPT 和类似的 AI 系统（GPT-3、GPT-4、Bing Chat、Bard 等）的工作原理。ChatGPT 是一个聊天机器人——一种构建的对话式人工智能——但建立在*大型语言模型*之上。我们将把它们全部分解。在此过程中，我们将讨论它们背后的核心概念。本文不需要任何技术或数学背景。我们将大量使用隐喻来说明这些概念。我们将讨论为什么核心概念以它们的方式工作，以及我们可以期望或不期望像 ChatGPT 这样的大型语言模型做什么。

这就是我们要做的事情。我们将温和地介绍一些与大型语言模型和 ChatGPT 相关的术语，不使用任何行话。如果我必须使用行话，我会不使用行话来分解它。我们将从“什么是人工智能”开始，然后逐步提高。我会尽可能地使用一些反复出现的隐喻。我将讨论这些技术的影响，即我们应该期望它们做什么或不应该期望它们做什么。let's go~!

注：主要是结合论文「[Attention Is All You Need](https://arxiv.org/pdf/1706.03762.pdf)」理解Transformer。[Transformer论文逐段精读](https://www.youtube.com/watch?v=nzqlFIcCSWQ)

附：[Transformer学习笔记](https://github.com/weedge/doraemon-nb/blob/main/transformer.ipynb) | [Annotated Transformer](https://github.com/weedge/doraemon-nb/blob/main/AnnotatedTransformer.ipynb) 

[**Intro to Large Language Models**](https://www.youtube.com/watch?v=zjkBMFhNj_g)

<!--more-->

## 1.什么是人工智能？

但首先，让我们从一些您可能经常听到的基本术语开始。什么是*人工智能*？

>  *人工智能*：如果人类做类似的事情，则执行人们可以合理地称为智能行为的实体。

用“智能 intelligent”这个词来定义人工智能有点问题，但没有人能就“智能”的一个好的定义达成一致。不过，我认为这仍然相当有效。它基本上是说，如果我们看到一些人造的东西，它做了一些引人入胜、有用的事情，而且看起来有些不平凡，那么我们可以称之为智能。例如，我们经常将“AI”一词归因于电脑游戏中由计算机控制的角色。大多数这些机器人都是简单的*if-then-else*代码（例如，“如果玩家在射程内，则射击，否则移动到最近的巨石进行掩护”）。但如果我们所做的工作是让我们保持参与和娱乐，而不是做任何明显愚蠢的事情，那么我们可能会认为它们比实际情况更复杂。

一旦我们了解了某些东西是如何工作的，我们可能不会留下深刻的印象，并期望幕后有更复杂的东西。这完全取决于您对幕后发生的事情的了解。

**他们的关键点是人工智能不是魔法。而且因为它不是魔法，所以可以解释。**

那么让我们开始吧。

## 2.什么是机器学习？

经常听到的与人工智能相关的另一个术语是*机器学习*。

> *机器学习*：一种通过获取数据、形成模型然后执行该模型来创建行为的方法。

有时，手动创建一堆 if-then-else 语句来捕获一些复杂的现象（例如语言）太困难了。在这种情况下，我们尝试找到一堆数据并使用可以在数据中找到模式的算法来建模。

但什么是模型？模型是某些复杂*现象*的简化。例如，模型车只是真车的更小、更简单的版本，具有许多属性，但并不意味着完全取代原车。模型车可能看起来很真实并且对某些用途有用，但我们无法将它开到商店。

![img](https://raw.githubusercontent.com/weedge/mypic/master/llm/a-very-gentle-introduction-to-large-language-models-without-the-hype/1.jpeg)

*DALL-E 生成的桌面上模型汽车的图像*。

就像我们可以制造更小、更简单的汽车一样，我们也可以制造更小、更简单的人类语言。我们使用“*大语言模型* ”这个术语，因为从使用它们需要多少内存的角度来看，这些模型很大。生产中最大的模型（例如 ChatGPT、GPT-3 和 GPT-4）足够大，需要在数据中心服务器中运行的大量超级计算机才能创建和运行。

## 3.什么是神经网络(Neural Network)？

从数据中学习模型的方法有很多。神经网络就是这样一种方式。该技术大致基于人类大脑是如何由相互连接的脑细胞网络（称为神经元）组成的，*神经元*来回传递电信号，以某种方式允许我们做我们所做的所有事情。神经网络的基本概念是在 20 世纪 40 年代发明的，而如何训练神经网络的基本概念是在 20 世纪 80 年代发明的。神经网络的效率非常低，直到 2017 年左右，计算机硬件才足够好，可以大规模使用它们。

但我喜欢用电路来比喻神经网络，而不是大脑。您不必是一名电气工程师就知道电流通过电线流动，并且我们有一种称为电阻器(resistors)的东西，可以使电流更难流过电路的某些部分。

想象一下，您想要制造一辆可以在高速公路上行驶的自动驾驶汽车。您已在汽车的正面、背面和侧面配备了接近传感器。当有物体非常接近时，接近传感器报告值 1.0；当附近检测不到任何物体时，接近传感器报告值 0.0。

您还装备了您的汽车，以便机器人机构可以转动方向盘、踩刹车和踩油门。当加速器接收到值1.0时，它使用最大加速度，0.0表示没有加速度。同样，发送到制动机构的值 1.0 表示猛踩刹车，0.0 表示不制动。转向机构的值介于 -1.0 到 +1.0 之间，负值表示向左转向，正值表示向右转向，0.0 表示保持直行。

您还记录了有关您驾驶方式的数据。当前面的道路畅通时，您就会加速。当前面有车时，你就减速。当一辆车距离左侧太近时，您会向右转并改变车道。当然，除非您右边也有一辆车。这是一个复杂的过程，涉及基于不同的传感器信息组合的不同动作组合（向左转向、向右转向、或多或少加速、制动）。

现在您必须将传感器连接到机器人机构。你怎么做到这一点？目前还不清楚。因此，您将每个传感器连接到每个机器人执行器。

![img](https://raw.githubusercontent.com/weedge/mypic/master/llm/a-very-gentle-introduction-to-large-language-models-without-the-hype/2.png)

*神经网络作为连接传感器和执行器的电路*。

当你把车开到路上时会发生什么？电流从所有传感器流向所有机器人执行器，汽车同时向左转向、向右转向、加速和制动。一团糟。

![img](https://raw.githubusercontent.com/weedge/mypic/master/llm/a-very-gentle-introduction-to-large-language-models-without-the-hype/3.gif)

*当我们的一些传感器发送能量时，该能量会流向所有执行器，汽车会同时加速、制动和转向*。

那可不好。因此，我拿起电阻器(resistors)，开始将它们放在电路的不同部分，以便电流可以在某些传感器和某些机器人执行器之间更自由地流动。例如，我希望电流能够更自由地从前接近传感器流向制动器，而不是流向方向盘。我还放入了称为“门(gates)”的东西，它会停止电流流动，直到积累足够的电流来翻转开关（仅当前接近传感器和后接近传感器报告高数字时才允许电流流动），或者仅在以下情况下向前发送电能：输入电气强度低（当前接近传感器报告低值时，向加速器发送更多电力）。

但我该把这些电阻器(resistors)和门(gates)放在哪里呢？我不知道。我开始将它们随机地放在各处。然后我再试一次。也许这次我的车开得更好，这意味着有时当数据表明最好制动时它会制动，当数据表明最好转向时它会转向，等等。但它并没有把所有事情都做对。有些事情它做得更糟（当数据表明最好刹车时加速）。所以我不断随机尝试电阻器(resistors)和门(gates)的不同组合。最终我会偶然发现一个效果很好的组合，我宣布成功。也许它看起来像这样：

![img](https://raw.githubusercontent.com/weedge/mypic/master/llm/a-very-gentle-introduction-to-large-language-models-without-the-hype/4.png)

一个经过充分训练的神经网络。较暗的线表示电路中能量流动更自由的部分。中间的圆圈是门(gates)，在将任何能量发送到顶部之前，可能会从下方积累大量能量，或者甚至可能在下方能量很少时向上发送能量。

（实际上，我们不会添加或减少门(gates)，它们总是存在的，但我们修改门(gates)，以便它们用更少的能量从下面激活或需要更多的能量从下面，或者只有当存在时才释放大量能量来自下面的能量非常少。机器学习纯粹主义者可能会在这种表征中吐出一点点。从技术上讲，这是通过调整门(gates)上的*偏差*来完成的，这通常不会在诸如此类的图表中显示，而是在以下方面显示：电路比喻可以被认为是进入每个门(gates)的一根电线，直接插入电源，然后可以像所有其他电线一样进行修改。）

让我们来试驾一下吧！

![img](https://raw.githubusercontent.com/weedge/mypic/master/llm/a-very-gentle-introduction-to-large-language-models-without-the-hype/5.gif)

随意尝试事情很糟糕。一种称为*反向传播的*算法相当擅长猜测如何改变电路的配置。算法的细节并不重要，只是要知道它对电路进行了微小的改变，以使电路的行为更接近数据建议的情况，并且经过数千或数百万次调整，最终可以得到接近一致的结果数据。

我们称电阻器(resistors)和门(gates)为**参数**，因为实际上它们无处不在，反向传播算法所做的就是声明每个电阻器(resistors)更强或更弱。因此，如果我们知道电路的布局和参数值，则可以在其他汽车上复制整个电路。

## 4.什么是深度学习(Deep Learning)？

*深度学习*认识到除了电阻器(resistors)和门(gates)之外，我们还可以在电路中添加其他东西。例如，我们可以在电路中间进行数学计算，在向前发送电力之前将事物相加和相乘。深度学习仍然使用相同的基本增量猜测参数技术。

## 5.什么是语言模型(Language Model)？

当我们做汽车的例子时，我们试图让我们的神经网络执行与我们的数据一致的行为。我们询问是否可以创建一个电路来操纵汽车中的机制，就像驾驶员在类似情况下所做的那样。我们可以用同样的方式对待语言。我们可以查看人类编写的文本，并想知道电路是否可以产生看起来很像人类倾向于产生的单词序列的单词序列。现在，当我们看到单词时，我们的传感器就会启动，我们的输出机制也是单词。

我们想做什么？我们正在尝试创建一个电路，在给定一堆输入单词的情况下猜测输出单词。例如：

> “Once upon a ____”

似乎应该用“time”而不是“armadillo”来填补空白。

我们倾向于从概率的角度来谈论语言模型。从数学上讲，我们将上面的例子写为：

![img](https://raw.githubusercontent.com/weedge/mypic/master/llm/a-very-gentle-introduction-to-large-language-models-without-the-hype/6.png)

如果您不熟悉该符号，请不要担心。这只是数学谈话，`|`意思是在给定（条形符号表示*给定*）一堆单词“once”、“upon”和“a”的情况下，单词“time”的概率（ *P* ）。我们期望一个好的语言模型产生“time”一词比“armadillo”一词更高的概率。

我们可以将其概括为：

![img](https://raw.githubusercontent.com/weedge/mypic/master/llm/a-very-gentle-introduction-to-large-language-models-without-the-hype/7.png)

这只是意味着在给定其之前的所有单词（位置 1 到n -1的单词）的情况下，计算序列中第n个单词的概率。

想想老式打字机，那种带有striker arms的打字机。

![img](https://raw.githubusercontent.com/weedge/mypic/master/llm/a-very-gentle-introduction-to-large-language-models-without-the-hype/8.jpeg)

*DALL-E2 制作了此图像。看看所有的striker arms！*

除了每个字母都有不同的striker arms之外，我们为每个单词都有一个striker撞针。如果英语有 50,000 个单词，那么这就是一台大打字机！

考虑一个类似的网络，而不是汽车网络，不同之处在于我们电路的顶部有 50,000 个输出连接到striker arms，每个单词一个。相应地，我们将拥有 50,000 个传感器，每个传感器检测不同输入单词的存在。因此，我们最终要做的就是选择一个能够获得最高电信号的striker arms，这就是空白处的单词。

我们的立场是这样的：如果我想制作一个接受单个单词并生成单个*单词*的简单电路，我必须制作一个具有 50,000 个传感器（每个单词一个）和 50,000 个输出（每个striker arm）的电路。我只需将每个传感器连接到每个striker arm，总共 50,000 x 50,000 = 25 亿根电线。

![img](https://raw.githubusercontent.com/weedge/mypic/master/llm/a-very-gentle-introduction-to-large-language-models-without-the-hype/9.gif)

*底部的每个圆圈都代表一个单词。需要 50,000 个传感器才能识别“once”这个词。该能量通过某个任意网络发送。顶部的所有圆圈都连接到每个单词的striker arms。所有striker arms都会接收到一些能量，但其中一只臂会比其他臂接收到更多的能量。*

那是一个大网络！

但情况变得更糟。如果我想做“Once Upon a ___”示例，我需要感知三个输入位置中的每一个中是哪个单词。我需要 50,000 x 3 = 150,000 个传感器。连接多达 50,000 个striker arms，相当于 150,000 x 50,000 = 75 亿根电线。截至 2023 年，大多数大型语言模型可以容纳 4,000 个单词，最大的可以容纳 32,000 个单词。

![img](https://raw.githubusercontent.com/weedge/mypic/master/llm/a-very-gentle-introduction-to-large-language-models-without-the-hype/10.gif)

*以三个单词作为输入的网络每个单词需要 50,000 个传感器。*

我们需要一些技巧来处理这种情况。我们将分阶段进行。

### 5.1 编码器(Encoders)

我们要做的第一件事是将电路分成两个电路，一个称为*编码器*，另一个称为*解码器*。许多单词的含义大致相同。考虑以下短语：

> The king sat on the __ 
>
> The queen sat on the __
>
> The princess sat on the __
>
> The regent sat on the __

对上述所有空白的合理猜测是“throne”（或者可能是“toilet”）。这就是说，我可能不需要在“king”和“throne”之间，或者“queen”和“throne”之间等之间使用单独的电线。相反，如果我有一些大约意味着皇室的东西，并且每次我看到“king”或“queen”，我用这个中间的东西代替。然后我只需要担心哪些词的意思大致相同，然后该怎么办（向“throne”发送大量能量）。

这就是我们要做的。我们将建立一个电路，该电路需要 50,000 个字传感器并映射到一些较小的输出集，例如 256 个而不是 50,000 个。我们不仅能够触发一个striker arms，还可以一次粉碎一堆臂。striker arms的每种可能组合都可以代表不同的概念（例如“royalty”或“armored mammals”）。这 256 个输出将使我们能够表示 2²⁵⁶ = 1.15 x 10⁷⁸ 的概念。事实上，更重要的是，就像在汽车示例中我们可以半踩刹车一样，这 256 个输出中的每一个都可以不仅仅是 1.0 或 0.0，而是中间的任何数字。因此，也许更好的比喻是，所有 256 个striker arms都猛烈撞击，但每个猛烈撞击的力量不同。

好吧……以前一个单词需要 50,000 个传感器(sensors)中的一个才能触发。现在，我们已将 1 个激活的传感器和 49,999 个关闭的传感器精简为 256 个数字。因此，“king”可能是 [0.1, 0.0 , 0.9, …, 0.4]，“queen”可能是 [0.1, 0.1 , 0.9, …, 0.4]，它们几乎彼此相同。我将这些数字列表称为*编码encodings*（由于历史原因也称为*隐藏状态*，但我不想解释这一点，所以我们将坚持使用编码）。我们将把 50,000 个传感器压缩成 256 个输出的电路称为*编码器encoder*。它看起来像这样：

![img](https://raw.githubusercontent.com/weedge/mypic/master/llm/a-very-gentle-introduction-to-large-language-models-without-the-hype/11.gif)

*编码器网络将检测单个单词所需的 50,000 个传感器值压缩为 256 个数字的编码（较浅和较深的蓝色用于指示较高或较低的值）。*

### 5.2 解码器 (Decoders)

但编码器并没有告诉我们接下来应该出现哪个单词。因此，我们将编码器与解码器网络配对。解码器是另一个电路，它采用 256 个数字进行编码，并激活原来的 50,000 个撞击臂(striker arms)，每个单词一个。然后我们会选择电力输出最高的单词。它看起来是这样的：

![img](https://raw.githubusercontent.com/weedge/mypic/master/llm/a-very-gentle-introduction-to-large-language-models-without-the-hype/12.gif)

*解码器网络，将编码中的 256 个值扩展为与每个可能单词相关的 50,000 个撞击臂的激活值。*

### 5.3 编码器和解码器一起使用

这是编码器和解码器一起工作以构成一个大型神经网络：

![img](https://raw.githubusercontent.com/weedge/mypic/master/llm/a-very-gentle-introduction-to-large-language-models-without-the-hype/13.png)

*编码器-解码器网络，它只是位于编码器之上的解码器。*

顺便说一句，单个单词输入到单个单词输出经过编码只需要 (50,000 x 256) x 2 = 2560 万个参数。这看起来好多了。

该示例针对一个单词输入并生成一个单词输出，因此如果我们想要读取n个单词，我们将有 50,000 x n个输入，以及 256 x n 的编码

但为什么这会起作用呢？通过强制将 50,000 个单词全部放入一小组数字中，我们迫使网络做出妥协并将单词组合在一起，这可能会触发相同的输出单词猜测。这很像文件压缩。当您压缩文本文档时，您会得到一个不再可读的较小文档。但您可以解压缩文档并恢复原始可读文本。这是可以做到的，因为 zip 程序用速记符号替换了某些单词模式。然后，当它解压缩时，它知道要换回什么文本来替换速记符号。我们的编码器和解码器电路学习压缩然后解压缩单词的电阻器(resistors)和门(gates)的配置。

### 5.4 自我监督(Self-Supervision)

我们如何知道每个单词的最佳编码？换句话说，我们如何知道“king”的编码应该类似于“queen”而不是“armadillo”的编码？

作为一个思想实验，考虑一个编码器-解码器网络，它应该接收单个单词（50,000 个传感器）并产生完全相同的单词作为输出。这是一件愚蠢的事情，但对接下来的事情很有启发。

![img](https://raw.githubusercontent.com/weedge/mypic/master/llm/a-very-gentle-introduction-to-large-language-models-without-the-hype/14.gif)

编码器-解码器网络经过训练，输出与输入相同的单词（与之前的图像相同，但具有用于激活的颜色）。

我输入“king”一词，单个传感器通过编码器发送电信号，并部分打开中间编码中的 256 个值。如果编码正确，那么解码器将向同一个单词“king”发送最高的电信号。对吧，容易吗？没那么快。很可能会看到带有“armadillo”一词且激活能量最高的撞击臂striker arm。假设“king”的撞击臂收到 0.051 电信号，“armadillo”的撞击臂收到 0.23 电信号。事实上，甚至不关心“armadillo”的价值是多少。只要看看“king”的输出能量就知道它不是1.0。1.0 和 0.051 之间的差异是错误（也称为*损失loss*），可以使用反向传播对解码器和编码器进行一些更改，以便下次我们看到“king”一词时进行稍微不同的编码。

我们对所有单词都这样做。编码器必须做出妥协，因为 256 比 50,000 小得多。也就是说，有些单词必须在中间使用相同的激活才能组合。因此，当有选择时，它会希望“king”和“queen”的编码几乎相同，而“armadillo”的编码则非常不同。这将使解码器能够通过查看 256 个编码值更好地猜测单词。如果解码器看到 256 个值的特定组合并猜测“king”为 0.43，“queen”为 0.42，只要“king”和“queen”获得最高的电信号并且每个49,998 个striker arms中的数字较小。另一种说法是，与网络在king和armadillo之间混淆相比，我们可能更愿意接受网络在king和queen之间混淆。

我们说神经网络是*自我监督的*，因为与汽车示例不同，不必收集单独的数据来测试输出。我们只需将输出与输入进行比较 - 我们不需要输入和输出的单独数据。

### 5.5 遮盖语言模型（Masked Language Models）

如果上面的思想实验看起来很愚蠢，那么它是一种被称为“*遮盖语言模型* ”的东西的构建模块。遮盖语言模型的思想是接收单词序列并生成单词序列。输入和输出中的单词之一被空白。

> The [MASK] sat on the throne.

网络猜测所有单词。嗯，很容易猜出未遮盖的单词。我们只关心网络对遮盖词的猜测。也就是说，对于输出中的每个单词，我们有 50,000 个striker arms。我们看看 50,000 个striker arms中的遮盖词。

![img](https://raw.githubusercontent.com/weedge/mypic/master/llm/a-very-gentle-introduction-to-large-language-models-without-the-hype/15.png)

*遮盖序列。厌倦了画很多连接线，所以我只会画红线来表示上面和下面的所有东西之间有很多很多的连接*。

可以移动遮盖，让网络在不同的地方猜测不同的单词。

一种特殊类型的遮盖语言模型仅在末尾有遮盖。这称为*生成模型generative model*，因为它猜测的遮盖始终是序列中的下一个单词，这相当于生成下一个单词，就好像下一个单词不存在一样。像这样：

> The [MASK]
>
> The queen [MASK]
>
> The queen sat [MASK]
>
> The queen sat on [MASK]
>
> The queen sat on the [MASK]

我们也称其为*自回归auto-regressive模型*。regressive回归这个词听起来不太好。但回归只是意味着试图理解事物之间的关系，比如已经输入的单词和应该输出的单词。Auto的意思是“self”。自回归模型是自我预测的。它预测一个词；然后该单词用于预测下一个单词，下一个单词又用于预测下一个单词，依此类推。这有一些有趣的含义，我们稍后会再讨论。

## 6.什么是transformer？

截至撰写本文时，我们听到了很多有关 GPT-3、GPT-4 和 ChatGPT 的信息。GPT 是 OpenAI 公司开发的一种大型语言模型的特定品牌。GPT 代表*基于转换器的生成式预训练模型 Generative Pre-trained transformer*。让我们来分解一下：

- *生成式 Generative*。该模型能够生成所提供输入的延续。也就是说，给定一些文本，模型会尝试猜测接下来出现哪些单词。
- *预训练 Pre-trained*。该模型是在非常大的通用文本语料库上进行训练的，并且意味着只需训练一次即可用于许多不同的事情，而无需从头开始重新训练。

有关预训练的更多信息…… 该模型是在一个非常大的通用文本语料库上进行训练的，该语料库表面上涵盖了大量可以想象的主题。这或多或少意味着“从互联网上抓取”，而不是从一些专门的文本存储库中获取。通过对一般文本进行训练，语言模型比在非常特定类型的文本（例如来自医疗文档的文本）上训练的语言模型更能够响应更广泛的输入。理论上，在通用语料库上训练的语言模型可以合理地响应互联网文档中可能出现的任何内容。它可能适合医学文本。仅针对医疗文档进行训练的语言模型可能会对与医疗环境相关的输入做出很好的响应，但在响应闲聊或食谱等其他输入时却表现不佳。

要么模型在很多方面都足够好，以至于人们永远不需要训练自己的模型，要么可以进行称为*微调fine-tuning*的操作，这意味着采用预先训练的模型并对其进行一些更新以使其更好地工作执行专门任务（例如医疗）。

- transformer。一种特定类型的自监督编码器-解码器深度学习模型，具有一些非常有趣的属性，使其擅长语言建模。

转换器transformer是一种特殊类型的深度学习模型，它以特定方式转换编码，从而更容易猜测空白单词。Vaswani 等人在一篇名为[*《Attention is All You Need》*](https://arxiv.org/abs/1706.03762)的论文中介绍了它。2017 年。Transformer 的核心是经典的编码器-解码器网络(encoder-decoder network)。编码器执行非常标准的编码过程。如此香草，你会感到震惊。但随后它添加了其他东西，称为*self-attention*。

### 6.1 自注意力(Self-Attention)

这是自注意力的想法：序列中的某些单词与序列中的其他单词相关。考虑一下这句话“外星人登陆地球是因为它需要躲在一个星球上。” 如果我们要掩盖第二个词“外星人alien”并要求神经网络猜测这个词，那么由于“landed”和“earth”等词，它的猜测会更好。同样，如果我们屏蔽“it”并要求网络猜测这个词，“alien”这个词的存在可能会让它更喜欢“it”而不是“he”或“she”。

![img](https://raw.githubusercontent.com/weedge/mypic/master/llm/a-very-gentle-introduction-to-large-language-models-without-the-hype/16.png)

*单词通过功能、指代同一事物或通过告知彼此的含义而与其他单词相关。*

我们说序列中的单词关注其他单词，因为它们捕获了某种关系。这种关系不一定是已知的。它可以是解析代词，可以是动词和主语关系，可以是与同一概念相关的两个单词（“地球”和“行星”）。不管是什么，知道单词之间存在某种关系对于预测很有用。

下一节将讨论自注意力的数学原理，但主要要点是transformer学习输入序列中的哪些单词是相关的，然后为输入序列中的每个位置创建一个新的编码，该编码是所有单词的合并。相关词汇。你可以将其视为学习创造一个由“外星人alien”、“登陆landed”和“地球earth”混合而成的新词（aliandearth？）。这是可行的，因为每个单词都被编码为数字列表。如果*Alien* = [0.1, 0.2, 0.3, …, 0.4] 且*landed* = [0.5, 0.6, 0.7, …, 0.8] 且*Earth* = [0.9, 1.0, 1.1, …, 1.2]，则第二个单词位置可能是编码为所有这些编码的总和，[1.5, 1.8, 2.1, …, 2.4]，它本身不对应于任何单词，但捕获所有单词的片段。这样，当解码器最终在第二个位置看到该单词的新编码时，它就可以获得有关该单词在序列中如何使用的大量信息，从而更好地猜测任何遮盖。（该示例只是将编码添加在一起，但会比这更复杂一些）。

### 6.2. 自注意力如何发挥作用？

自注意力是对普通编码器-解码器网络的显着改进，因此如果您想了解更多有关其工作原理的信息，请继续阅读。否则，请随意跳过本节。TL;DR：自注意力是称为*点积dot product*的数学运算的一个奇特名称。

自注意力发生在三个阶段。

1. 像平常一样对输入序列中的每个单词进行编码。我们制作了四个单词编码副本。我们将其中的一种称为*残留物 residual*并设置安全保存。

2. 我们对其他三个运行第二轮编码（我们正在编码）。每个都经历了不同的编码过程，因此它们都变得不同。我们将其中一个称为查询 ( *q* )，将一个称为键 ( *k* )，将一个称为值 ( *v* )。

我想让你考虑一下哈希表（在 python 中也称为字典）。在表中存储了大量信息。表中的每一行都有一个*key*、一些唯一标识符和*value*，即存储在该行中的数据。要从哈希表中检索一些信息，需要发出查询。如果查询与键匹配，则提取值。

![img](https://raw.githubusercontent.com/weedge/mypic/master/llm/a-very-gentle-introduction-to-large-language-models-without-the-hype/17.png)

*可以使用哈希表来查询教授在哪所大学工作*。

自注意力的工作原理有点像*模糊 Fuzzy*哈希表(LSH属于这类hash)。提供一个查询，它不会查找与键的精确匹配，而是根据查询和键之间的相似性查找近似匹配。但如果匹配不是完美匹配怎么办？它返回值的一部分。嗯，只有当查询、键和值都是数字时，这才有意义。它们是：

![img](https://raw.githubusercontent.com/weedge/mypic/master/llm/a-very-gentle-introduction-to-large-language-models-without-the-hype/18.png)

*具有部分匹配的哈希表*。

这就是我们要做的。对于输入中的每个单词位置，我们将采用*q*编码和*k*编码并计算相似度。我们使用称为点积的东西，也称为余弦相似度。这不重要，关键是每个单词都是 256 个数字的列表（基于我们之前的示例），我们可以计算数字列表的相似度并将相似度记录在矩阵中。我们将此矩阵称为*自注意力分数 self-attention scores*。如果我们有一个三个单词的输入序列，我们的注意力分数可能如下所示：

![img](https://raw.githubusercontent.com/weedge/mypic/master/llm/a-very-gentle-introduction-to-large-language-models-without-the-hype/19.png)

*每个单元格指示一个位置中的编码字对另一位置中的编码字的关注程度。*

网络将第一个单词视为查询，并与第二个键进行匹配（我们可以说第一个单词“参与”第二个单词）。如果第二个单词是查询，它将与第三个键匹配。如果第三个单词是查询，它将与第一个键匹配。事实上，我们永远不会有这样的 1 和 0；我们将在 0 和 1 之间进行部分匹配，并且每个查询（行）将部分匹配多个键（列）。

现在继续使用检索隐喻，我们将该矩阵与*v*编码相乘，然后发生了一些有趣的事情。假设我们的*v*编码如下所示：

![img](https://raw.githubusercontent.com/weedge/mypic/master/llm/a-very-gentle-introduction-to-large-language-models-without-the-hype/20.png)

每行都是序列中一个单词的编码。

也就是说，第一个单词被编码为数字0.10…0.19的列表，第二个单词被编码为数字0.20…0.29的列表，第三个单词被编码为数字0.30…0.39的列表。这些数字是为了说明目的而编造的，永远不会如此整齐。

![img](https://raw.githubusercontent.com/weedge/mypic/master/llm/a-very-gentle-introduction-to-large-language-models-without-the-hype/21.png)

*将注意力与值相乘*。

第一个查询与第二个键匹配，因此检索第二个编码字。第二个查询与第三个键匹配，因此检索第三个编码字。第三个查询与第一个键匹配，因此检索第一个编码的单词。我们有效地做的是交换行！

![img](https://raw.githubusercontent.com/weedge/mypic/master/llm/a-very-gentle-introduction-to-large-language-models-without-the-hype/22.png)

实际上，分数不会是完美的 1 和 0，结果将是每种编码的一点点混合在一起（例如 97% 的单词 1 加 1% 或单词 3 加 2% 的单词 2）。但这说明了自注意力是如何混合和交换的。在这个极端版本中，第一个单词已被交换为第二个单词，依此类推。所以也许“earth”这个词已经被“planet”这个词互换了。

我们如何知道我们正确编码了*q*、*k*和*v*？如果整个网络猜测遮盖的最佳单词的能力得到提高，那么我们就可以正确编码*q*、*k*和*v*。如果没有，我们下次会更改参数以进行稍微不同的编码。

3. 我们做的第三件事是获取所有数学结果并将其添加到残差中。请记住我们预留的原始编码的第一个副本。没错，我们添加了混合和交换的版本。现在“earth”不仅仅是“earth”的编码，而是某种虚构的单词，是“earth”和“planet”的混搭……pearth？ealanet？不是那样的。无论如何，这是将发送到解码器的最终转换编码。我们可能会同意，在每个位置都有一个真正编码两个或多个单词的假单词对于基于每个位置的单个单词进行预测更有用。

然后，再一次又一次地重复此操作几次（多层）。

我省略了很多关于编码器的最终编码如何进入解码器的细节（另一种注意力，称为*source-attention*，其中编码器的每个位置的编码用作*q*和*k*来应用于另一个位置*v*的不同版本），但此时您应该有一个大概的要点。最后，解码器从编码器接收编码，将能量发送到单词的撞击臂，然后我们选择能量最强的单词。

## 7. 为什么大型语言模型如此强大？

那么，这意味着什么？大型语言模型，包括 ChatGPT、GPT-4 等，只做一件事：它们接收一堆单词并尝试猜测接下来应该出现什么单词。如果这是“推理”或“思考”，那么它只是一种非常专业的形式。

但即使是这种专门的形式似乎也非常强大，因为 ChatGPT 和类似的东西可以做很多看起来非常好的事情：写诗、回答有关科学和技术的问题、总结文档、起草电子邮件，甚至编写代码，仅举几例。为什么他们应该工作得这么好？

秘诀有两个。第一个我们已经讨论过：transformer学习以一种使其非常擅长猜测下一个单词的方式混合单词上下文。另一部分是系统的训练方式。大型语言模型是根据从互联网上抓取的大量信息进行训练的。这包括书籍、博客、新闻网站、维基百科文章、reddit 讨论、社交媒体对话。在训练期间，我们从这些来源之一提供一段文本，并要求它猜测下一个单词。记住：自我监督。如果它猜错了，我们会稍微调整模型，直到猜对为止。**如果我们要考虑LLM接受训练的目的，那就是生成可以合理出现在互联网上的文本**。它无法记住互联网，因此它使用编码来做出妥协，并让事情变得有点错误，但希望不会错得太离谱。

重要的是不要低估互联网上文本主题的多样性。LLM 已经看到了这一切。他们已经看到了几乎每个主题的数十亿次对话。因此，LLM可以产生看起来像是在与您对话的语言。它已经看到了数十亿首诗歌和音乐歌词，几乎涵盖了所有可以想象的内容，因此它可以生成看起来像诗歌的文本。它已经看到了数十亿份作业及其解决方案，因此即使略有不同，它也可以对您的作业做出合理的猜测。它已经看到了数十亿的标准化测试问题及其答案。我们真的认为今年的 SAT 题目与去年有很大不同吗？它见过人们谈论他们的假期计划，因此它可以猜测看起来像假期计划的单词。它已经看到了数十亿个执行各种操作的代码示例。计算机程序员所做的很多事情都是将用于执行非常典型和易于理解的事情的代码片段组装成更大的代码块。因此，LLM可以为您编写那些小的、常见的片段。人们在 stackoverflow.com 上看到了数十亿个错误代码的示例及其更正。是的，所以它可以接收损坏的代码并提出修复建议。数十亿人在推特上表示，他们触摸了热炉并烧伤了手指，因此LLM知道一些常识。它阅读了大量的科学论文，因此它可以猜测众所周知的科学事实，即使它们对你来说并不熟悉。它已经看到了数十亿个人们总结、将文本重写为要点的例子，描述了如何使文本更加语法、简洁或有说服力。

重点是：当您要求 ChatGPT 或其他大型语言模型做一些聪明的事情（并且它有效）时，您很有可能要求它做一些它已经见过数十亿个示例的事情。即使你想出一些非常独特的东西，比如“告诉我闪电侠戈登吃了六个墨西哥卷饼后会做什么”（这是独特的，我什至不知道），它已经看到了关于闪电侠戈登的粉丝小说，它已经看到了人们谈论吃太多墨西哥卷饼，并且由于自我关注，可以混合搭配零碎的东西来组合出听起来合理的反应。

与大型语言模型交互时，我们的第一直觉不应该是“哇这些东西一定非常聪明或非常有创意或非常理解”。我们的第一直觉应该是“我可能要求它做一些它以前见过的事情”。这可能意味着它仍然非常有用，即使它不是“认真思考”或“做一些非常复杂的推理”。

我们不必使用拟人化来理解它正在做什么来为我们提供响应。

关于这个主题的最后一点是：由于大型语言模型的工作方式和它们的训练方式，它们往往提供的答案在某种程度上是中值响应。对于我来说，模型在询问有关飞侠戈登的故事后往往会给出平均的回答，这似乎很奇怪。但在一个故事或一首诗的背景下，这些回应可以被认为是很多人（在互联网上写作）如果不得不妥协的话会想到的。不会是坏事。按照一个人坐着思考自己的事情的标准来看，这可能相当不错。但你的故事和诗歌可能也只是一般（但它们对你来说很特别）。

## 8. 我应该注意什么？

transformer的工作方式和训练方式会产生一些非常微妙的影响。以下是技术细节的直接影响。

1. 大型语言模型是在互联网上训练的。这意味着他们也对人性的所有黑暗部分进行了训练。大型语言模型接受过种族主义咆哮、性别歧视长篇大论、针对各种类型的人的各种侮辱、人们对他人做出刻板假设、阴谋论、政治错误信息等的训练。这意味着语言模型选择生成的单词可能会重复出现这样的语言。
2. 大型语言模型没有“核心信念”。他们是猜词者；他们试图预测如果同一个句子出现在互联网上，下一个单词会是什么。因此，人们可以要求大型语言模型写出一个支持某事物或反对同一事物的句子，并且语言模型将遵守这两种方式。这些并不表明它相信一件事或另一件事，或者改变它的信念，或者一个比另一个更正确。如果训练数据有更多的一件事与另一件事的例子，那么大型语言模型往往会对其训练数据中更频繁出现的内容做出更一致的响应，因为它更频繁地出现在互联网上。请记住：该模型正在努力模拟最常见的响应。
3. 大型语言模型没有任何真理或正确或错误的感觉。有些事情我们认为是事实，比如地球是圆的。LLM 往往会这么说。但如果上下文正确，它也会说相反的内容，因为互联网上确实有关于地球是平的文字。无法保证LLM会提供真相。可能会倾向于猜测我们同意的词语是真实的，但这是我们可能对LLM“知道”真相或正确或错误做出任何声明的最接近的说法。
4. 大型语言模型可能会出错。训练数据可能有很多不一致的材料。当我们提出问题时，自我注意力可能不会关注到我们想要关注的所有事情。作为一个单词猜测器，它可能会做出不幸的猜测。有时，训练数据多次看到一个单词，以至于它更喜欢该单词，即使它对输入没有意义。上述情况导致了一种称为“**幻觉**”的现象，其中一个单词是猜测的，既不是从输入中得出的，也不是“正确的”。LLM倾向于猜测小数字而不是大数字，因为小数字更常见。所以LLM不擅长数学。LLM偏爱数字“42”，因为人类会因为一本特别的名著而偏爱数字“42”。LLM更喜欢更常见的名字，因此可能会使用作者的名字。
5. 大型语言模型是自回归的。因此，当他们做出我们可能认为很差的猜测时，这些猜测的单词会被添加到他们自己的输入中，以进行下一个单词的猜测。即：错误不断累积。即使只有 1% 的错误机会，自注意力也可以注意到错误的选择，并加倍关注该错误。即使只犯了一个错误，随后发生的所有事情都可能与该错误有关。然后语言模型可能会在此基础上产生额外的错误。transformer没有办法“改变主意”、重试或自我纠正。他们随波逐流。
6. 人们应该始终验证大型语言模型的输出。如果你要求它做你自己无法胜任的事情，那么你应该考虑一下你是否愿意对所犯的任何错误采取行动。对于低风险任务，比如写短篇小说，这可能没问题。对于高风险任务，例如尝试获取信息来决定投资哪些股票，这些错误可能会导致您做出代价高昂的决定。
7. 自注意力意味着您在输入提示中提供的信息越多，响应就会越专业，因为它会将您的更多单词混合到其猜测中。响应的质量与输入提示的质量成正比。更好的提示会产生更好的结果。尝试几种不同的提示，看看哪种最适合您。不要假设语言模型“理解”了您想要做的事情，并且会在第一次就给出最好的结果。
8. 并没有真正与大型语言模型“对话”。大型语言模型不会“记住”交换中发生的事情。初始化输入，响应出来，LLM什么都不记得。初始输入、响应以及对响应的响应都会输入。因此，如果它看起来像是在记住，那是因为对话日志变成了全新的输入。这是front-end的一个编程技巧，使大语言模型看起来像是在进行对话。由于这个技巧，它可能会留在主题上，但不能保证它不会与之前的回应相矛盾。此外，可以输入大型语言模型的单词数量也有限制（目前 ChatGPT 允许大约 4,000 个单词，GPT-4 允许大约 32,000 个单词）。输入大小可能非常大，因此对话通常会在一段时间内显得保持连贯。最终，累积的日志将变得太大，对话的开头将被删除，系统将“忘记”之前的事情。
9. 大型语言模型不解决问题或规划。但你可以要求他们制定计划并解决问题。我要在这里吹毛求疵。*问题解决Problem-solving*和*规划planning*是人工智能研究社区中某些团体保留的术语，含义非常具体。特别是，它们意味着有一个目标——你想在未来完成的事情——并通过在可能使人更接近该目标的替代方案之间做出选择来努力实现该目标。大型语言模型没有目标。他们的目标是选择一个最有可能出现在给定输入序列的训练数据中的单词。它们是模式匹配的。特别是规划，通常涉及所谓的“*前瞻look-ahead* ”。当人类进行规划时，他们会想象自己行动的结果，并根据目标分析未来。如果看起来离目标更近了，那么这是一个很好的举动。如果没有，我们可能会尝试想象另一个行动的结果。事情远不止这些，但关键点是大型语言模型没有*目标*，也不做*前瞻*。transformer是向后看的。自注意力只能应用于已经出现过的输入词。现在，大型语言模型可以生成看起来像计划的输出，因为它们在训练数据中看到了很多计划。他们知道计划是什么样子，他们知道关于他们所看到的某些主题的计划中应该出现什么内容。它将对该计划做出很好的猜测。该计划可能会忽略有关世界的特定细节，而倾向于最通用的计划。大型语言模型当然没有“仔细考虑替代方案”，或者尝试了一件事然后回溯并尝试另一件事。transformer内部没有任何机制可以指出可以对未来进行如此反复的考虑。（对此有一个警告，将在下一节中提出。）在询问计划时始终验证输出。

## 9. 是什么让 ChatGPT 如此特别？

“所以我听说 RLHF 使 ChatGPT 变得非常智能。”

“ChatGPT 使用强化学习，这就是它如此智能的原因。”

嗯……有点。

截至撰写本文时，人们对 *RLHF* (即人类反馈强化学习)感到非常兴奋。我们做了一些事情来特别训练 ChatGPT（以及越来越多的其他大型语言模型）。它们并不是全新的，但在 ChatGPT 发布时被广泛引入并产生了巨大的效果。

ChatGPT 是一个基于 Transformer 的大型语言模型。ChatGPT 因其非常擅长对输入提示做出响应以及拒绝回答有关某些可能被认为有毒或固执己见的主题的问题而赢得了声誉。它没有做任何与上面描述的特别不同的事情。事实上，它很香。但有一个区别：它是如何训练的。ChatGPT 的训练方式与往常一样——抓取互联网的一大块内容，获取该文本的片段，然后让系统预测下一个单词。这产生了一个已经是非常强大的单词预测器的基本模型（相当于 GPT-3）。但接下来还有两个额外的训练步骤。通过人类反馈进行指令调整和强化学习。

### 9.1. 指令调优 Instruction Tuning

大型语言模型有一个特殊问题：它们只想获取输入的单词序列并生成接下来的内容。大多数时候，这就是一个人想要的。但不总是。考虑以下输入提示：

> “写一篇关于亚历山大·汉密尔顿的文章。”

你认为回应应该是什么。您可能认为应该是这样的内容：“亚历山大·汉密尔顿 1757 年出生于尼维斯。他是一位政治家、律师、陆军上校和美国第一任财政部长……”但您实际上可能会这样想得到的是：

> “你的文章应该至少有五页，双倍行距，并且至少包含两次引用。”

刚刚发生了什么？好吧，语言模型可能已经看到了很多学生作业的例子，这些例子以“写一篇关于……”的文章开头，并包含详细说明长度和格式的单词。当然，当你写“写一篇文章……”时，你认为你正在向语言模型编写指令，就好像它是一个理解意图的人一样。语言模型不理解你的意图或者有自己的意图；他们只将输入与他们在训练数据中看到的模式进行匹配。

为了解决这个问题，可以采取一种称为*指令调整的*方法。这个想法相当简单。如果您得到错误的响应，请写下正确的响应应该是什么，并通过神经网络发送原始输入和新的校正输出作为训练数据。有了足够多的校正输出示例，系统将学习改变其电路，以便首选新答案。

一个人不必做任何太花哨的事情。**只需让很多人与大型语言模型进行交互，并要求它做很多事情，并在其行为不正确时写下更正即可；然后收集所有出错的例子和新的、正确的输出，并进行更多的训练**。

这使得大语言模型表现得好像它理解输入提示的意图并且表现得好像它正在遵循指令一样。除了尝试猜测下一个单词之外，它没有做任何其他事情。但现在新的训练数据可以猜测似乎对输入更敏感的单词。

### 9.2. 从人类反馈中强化学习

训练的下一步是根据人类反馈进行强化学习。我认为这需要一些解释。

**强化学习**是一种传统上用于一些机器人研究和虚拟游戏代理的人工智能技术（想想可以下国际象棋、围棋或星际争霸的人工智能系统）。*强化学习*特别擅长弄清楚当获得奖励时要做什么。奖励只是一个数字，表明它做得有多好（+100 表示做得很好；-100 表示做得很差）。在现实世界和游戏中，奖励通常很少给予。在游戏中，您可能需要做很多动作才能获得分数。也许你只有在比赛结束时才能获得积分。在现实世界中，当你做得很好时，没有足够多的人告诉你（你确实做得很好）。除非你是一只狗（他们都是好孩子）。您真正需要知道的唯一一件事是，强化学习系统尝试预测他们将获得多少未来奖励，然后选择最有可能获得更多未来奖励的行动。这与人们使用狗粮来教狗行为的方式并非完全不同。

好的，把它们全部藏起来并考虑以下提示：

> What is Mark an expert in? (马克是哪方面的专家？)

假设语言模型的输出为：

> Mark has many publications in artificial intelligence, graphics, and human-computer interaction. (马克在人工智能、图形学和人机交互方面发表了许多出版物。)

这只是部分正确。我不以图形形式发布。我真的只是想给它一个反对，或者-1分。但只有一处是错误的：图形一词。如果我告诉系统整个句子都是错误的，语言模型可能会知道应该避免所有这些单词。嗯，其中很多话都是有道理的。

这就是强化学习的用武之地。强化学习的工作原理是尝试不同的替代方案，看看哪些替代方案能获得最大的回报。假设我要求它对原始提示生成三个不同的响应。

> Mark has many publications in artificial intelligence, graphics, and human-computer interaction. (马克在人工智能、图形学和人机交互方面发表了许多出版物。)
>
> Mark has worked in artificial intelligence, safe NLP systems, and human-computer interaction. (马克曾从事人工智能、安全 NLP 系统和人机交互领域的工作。)
>
> Mark as researched artificial intelligence, game AI, and graphics. (标记为研究人工智能、游戏人工智能和图形。)

我可以对第一个选项表示反对 (-1)，对第二个选项表示赞成 (+1)，对第三个选项表示反对 (-1)。就像玩游戏一样，强化学习算法可以回顾并找出导致 -1 的共同点是“图形”一词。现在，系统可以将该单词归零，并调整神经网络电路，以不将该单词与特定的输入提示结合使用。

我们将再次让一群人与大型语言模型进行交互。这次我们将为人们提供三种（或更多）可能的答案。我们可以通过要求大型语言模型多次响应提示并为前锋武器的选择引入一点随机性来做到这一点（没有忘记这些，不是吗？）。我们有时可能会选择第二或第三高激活的striker arms，而不是选择最高激活的striker arms。这会给出不同的文本响应，我们要求人们选择他们最喜欢的第一个响应、第二个最喜欢的响应，依此类推。现在我们有替代方案，我们有数字。现在我们可以使用强化学习来调整神经网络电路。

[实际上，我们使用这些赞成和反对反馈来训练第二个神经网络来预测人们是否会赞成或反对。如果该神经网络足以预测人们的喜好，那么我们可以使用第二个神经网络来猜测语言模型的响应是否会得到赞成或反对，并用它来训练语言模型。]

强化学习将文本的生成视为一个游戏，其中每个动作都是一个单词。在序列结束时，语言模型会被告知它是赢得了一些分数还是失去了一些分数。语言模型并不完全像上一节中讨论的那样进行前瞻，但在某种意义上它已经被训练来预测哪些单词会获得好评。大语言模型仍然没有明确的目标，但它有一个“获得点赞”的隐含目标（或者我们也可以说它有“让普通人满意”的隐含目标），并且已经学会了关联对某些提示的某些响应并获得竖起大拇指。这具有很多规划特性，但没有明确的前瞻机制。更像是它记住了在很多情况下都有效的获得奖励的策略。

重要的是 RLHF 是否使 ChatGPT 更加智能……它使 ChatGPT 更有可能产生我们希望看到的响应类型。它看起来更聪明，因为它的输出似乎传达了一种感觉，即它理解我们输入的意图并有自己的响应意图。这是一种错觉，因为它仍然只是对单词进行编码和解码。但话又说回来，这就是我们开始这篇文章的地方。

指令调整和 RLHF 还使 ChatGPT 能够抵抗某些类型的滥用，例如生成种族主义、性别歧视或带有政治色彩的内容。它仍然可以做到，而且无论如何旧版本的 GPT-3 始终能够做到这一点。然而，作为一项免费的面向公众的服务，ChatGPT 针对某些类型的滥用行为产生的摩擦传达了一种安全感。它还拒绝将意见作为事实提供，这也消除了对用户的一种潜在伤害。

使用强化学习来修改预先训练的语言模型并不新鲜。它至少可以追溯到 2016 年，并已被用于使大型语言模型更加安全。大多数基于强化学习的大型语言模型调整都使用第二个模型来提供奖励，这也是通过 ChatGPT 完成的。ChatGPT 值得注意的是通过强化学习调整的系统规模，以及大规模的人类反馈收集工作。	

## 10. 结论

当手绘神经网络时，它看起来像鲸须。不管怎样，希望能够过滤掉一些围绕大型语言模型的炒作。

LLM 可视化过程： https://bbycroft.net/llm

## Reference

1. https://mark-riedl.medium.com/a-very-gentle-introduction-to-large-language-models-without-the-hype-5f67941fa59e
2. https://en.wikipedia.org/wiki/Transformer_(machine_learning_model)
3. https://bbycroft.net/llm
4. https://arxiv.org/pdf/1706.03762.pdf
5. https://time.geekbang.org/column/article/682762
6. https://mp.weixin.qq.com/s/owgDAUGnrsXmNwUXY2Ya0w
7. https://mp.weixin.qq.com/s/PIh2gPhqF8r-9k8QZQ8GEw
8. https://nvidia.github.io/TensorRT-LLM/   https://github.com/NVIDIA/TensorRT-LLM
9. **https://transformers.run/**
10. **https://huggingface.co/learn/nlp-course/chapter1/4** 
11. **https://kexue.fm/archives/4765**